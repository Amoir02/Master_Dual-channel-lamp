---- D:\Work\project\遥控+接收主程序\双信道接收2\src\main.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "system.h"
3:                #include "WDT.h"
4:                #include "rf297L.h"
5:                #include "timer1.h"
6:                #include "PORTB_interrupt.h"
7:                #include "cUART.h"
8:                #include "24lc02.h"
9:                #include "timer1.h"
10:               #include "Key.h"
11:               #include "Buffer.H"
12:               #include "PWM.h"
13:               #include "recive.h"
14:               #include "userClock.h"
15:               #include "iic.h"
16:               
17:               #define T_NUMS  250
18:               
19:               usint Timecnt_3S=0;
20:               
21:               usint SysRunTimeCnt=1;
22:               uchar SysDingShiEn=0;
23:               
24:               const char ack_buf[8]= {0};
25:               extern uchar rf_buf[18];
26:               uchar RF_ADDRESS[5]={0,0,0,0,0};
27:               uchar RF_RxMark=0;
28:               
29:               uchar DingShi=0;
30:               
31:               extern unsigned char TX_ADDRESS_DEF[5];
32:               
33:               uchar PWM_CH_LED1=0;
34:               uchar PWM_CH_LED2=0;
35:               
36:                uchar LEDR1_Vol=0;
37:                uchar LEDR2_Vol=0;
38:                
39:                uchar SysRunTime_3S=0;
40:                
41:               extern uchar addr_buf[16];
42:                
43:               extern struct BriCoTem BriCoTem_Value; 
44:               usint Timecnt_LEDTrun=0; 
45:               uchar TimeEN_LEDTrun=0; 
46:               
47:               extern unsigned int Time1s_cot;
48:               
49:               void PWM_LED1(uchar PWM);
50:               void PWM_LED2(uchar PWM);
51:               void PWM_12SetVol(void);
52:               
53:               
54:               	
55:               void main()
56:               {
  0CAC    3071    LDIA	0x71
57:               	unsigned char i = 0;
58:               	unsigned char j = 0;
  0CAD    01E6    CLR	0x66
59:               	
60:               	system_set_CPU_frequency(CPU_FREQUENCY_8M);
  0CAE    158A    SETB	0xA,3
  0CAF    207E    CALL	0x7E
  0CB0    158A    SETB	0xA,3
61:               	soft_delay_ms(200);
  0CB1    30C8    LDIA	0xC8
  0CB2    00F3    LD	0x73,A
  0CB3    01F4    CLR	0x74
  0CB4    118A    CLRB	0xA,3
  0CB5    259E    CALL	0x59E
  0CB6    158A    SETB	0xA,3
  0CB7    0000    NOP
62:               	asm("nop");
63:               	TRISC = 0x00;
  0CB8    1683    SETB	0x3,5
  0CB9    1303    CLRB	0x3,6
  0CBA    0187    CLR	0x7
64:               	TRISB = 0x00;
  0CBB    0186    CLR	0x6
65:               	PORTC = 0x00;
  0CBC    1283    CLRB	0x3,5
  0CBD    0187    CLR	0x7
66:               	PORTB = 0x00;
  0CBE    0186    CLR	0x6
67:               	
68:               	CCPX_Init(1,61); 
  0CBF    303D    LDIA	0x3D
  0CC0    00F3    LD	0x73,A
  0CC1    3001    LDIA	0x1
  0CC2    158A    SETB	0xA,3
  0CC3    20DB    CALL	0xDB
  0CC4    158A    SETB	0xA,3
69:               	CCP1_set_duty_cycle(0);
  0CC5    01F3    CLR	0x73
  0CC6    01F4    CLR	0x74
  0CC7    118A    CLRB	0xA,3
  0CC8    2702    CALL	0x702
  0CC9    158A    SETB	0xA,3
70:               	CCP2_set_duty_cycle(0);
  0CCA    01F3    CLR	0x73
  0CCB    01F4    CLR	0x74
  0CCC    118A    CLRB	0xA,3
  0CCD    271B    CALL	0x71B
  0CCE    158A    SETB	0xA,3
71:               
72:               	soft_delay_ms(10);
  0CCF    300A    LDIA	0xA
  0CD0    00F3    LD	0x73,A
  0CD1    01F4    CLR	0x74
  0CD2    118A    CLRB	0xA,3
  0CD3    259E    CALL	0x59E
  0CD4    158A    SETB	0xA,3
  0CD5    300A    LDIA	0xA
  0CD6    158A    SETB	0xA,3
  0CD7    260C    CALL	0x60C
  0CD8    158A    SETB	0xA,3
73:               	i=EEPROM_Init(10); 
74:               	soft_delay_ms(10);
  0CD9    300A    LDIA	0xA
  0CDA    00F3    LD	0x73,A
  0CDB    01F4    CLR	0x74
  0CDC    118A    CLRB	0xA,3
  0CDD    259E    CALL	0x59E
  0CDE    158A    SETB	0xA,3
75:               
76:               	
77:               //----------------------------------------
78:               	i=EP_GetONOFFStep();
  0CDF    118A    CLRB	0xA,3
  0CE0    2022    CALL	0x22
  0CE1    158A    SETB	0xA,3
  0CE2    00E7    LD	0x67,A
79:               	switch(i)
  0CE3    2CF1    JP	0x4F1
  0CE4    30FA    LDIA	0xFA
  0CE5    00B5    LD	0x35,A
  0CE6    01B6    CLR	0x36
  0CE7    2CFF    JP	0x4FF
  0CE8    30FA    LDIA	0xFA
  0CE9    01B5    CLR	0x35
  0CEA    2CEF    JP	0x4EF
  0CEB    30FA    LDIA	0xFA
  0CEC    2CEE    JP	0x4EE
  0CED    3002    LDIA	0x2
  0CEE    00B5    LD	0x35,A
  0CEF    00B6    LD	0x36,A
  0CF0    2CFF    JP	0x4FF
  0CF1    0867    LD	A,0x67
  0CF2    3A00    XORIA	0x0
  0CF3    1903    SZB	0x3,2
  0CF4    2CE4    JP	0x4E4
  0CF5    3A01    XORIA	0x1
  0CF6    1903    SZB	0x3,2
  0CF7    2CE8    JP	0x4E8
  0CF8    3A03    XORIA	0x3
  0CF9    1903    SZB	0x3,2
  0CFA    2CEB    JP	0x4EB
  0CFB    3A01    XORIA	0x1
  0CFC    1903    SZB	0x3,2
  0CFD    2CED    JP	0x4ED
  0CFE    2CFF    JP	0x4FF
80:               	{
81:               		case 0: 	PWM_CH_LED1=LED_R_Max; PWM_CH_LED2=0; break;
82:               		case 1: 	PWM_CH_LED1=0; PWM_CH_LED2=LED_R_Max;break;
83:               		case 2: 	PWM_CH_LED1=LED_R_Max; PWM_CH_LED2=LED_R_Max;break;
84:               		case 3: 	PWM_CH_LED1=LED_R_Min; PWM_CH_LED2=LED_R_Min; break;
85:               	}
86:               	LEDR1_Vol=PWM_CH_LED1;
  0CFF    0835    LD	A,0x35
  0D00    00B3    LD	0x33,A
87:               	LEDR2_Vol=PWM_CH_LED2;
  0D01    0836    LD	A,0x36
  0D02    00B4    LD	0x34,A
88:               	PWM_12SetVol();
  0D03    118A    CLRB	0xA,3
  0D04    2019    CALL	0x19
  0D05    158A    SETB	0xA,3
89:               	if(++i>=4) i=0;
  0D06    3004    LDIA	0x4
  0D07    0AE7    INCR	0x67
  0D08    0267    SUBA	0x67
  0D09    1803    SZB	0x3,0
  0D0A    01E7    CLR	0x67
90:               	//soft_delay_ms(20);
91:               	EP_SetONOFFStep(i);
  0D0B    0867    LD	A,0x67
  0D0C    158A    SETB	0xA,3
  0D0D    260F    CALL	0x60F
  0D0E    158A    SETB	0xA,3
92:               //----------------------------------------
93:               	IIC_Init1();
  0D0F    158A    SETB	0xA,3
  0D10    2083    CALL	0x83
  0D11    158A    SETB	0xA,3
94:               	AT24C02_Read_Msg(30, addr_buf, 16);
  0D12    30C2    LDIA	0xC2
  0D13    00CB    LD	0x4B,A
  0D14    3010    LDIA	0x10
  0D15    00CC    LD	0x4C,A
  0D16    301E    LDIA	0x1E
  0D17    158A    SETB	0xA,3
  0D18    23B3    CALL	0x3B3
  0D19    158A    SETB	0xA,3
95:               	
96:               	
97:               	RF_Init();
  0D1A    118A    CLRB	0xA,3
  0D1B    2607    CALL	0x607
  0D1C    158A    SETB	0xA,3
98:               	RF_Set_RxMode();
  0D1D    118A    CLRB	0xA,3
  0D1E    2013    CALL	0x13
  0D1F    158A    SETB	0xA,3
99:               	soft_delay_ms(30);
  0D20    301E    LDIA	0x1E
  0D21    00F3    LD	0x73,A
  0D22    01F4    CLR	0x74
  0D23    118A    CLRB	0xA,3
  0D24    259E    CALL	0x59E
  0D25    158A    SETB	0xA,3
100:              	RF_ADDSSet(TX_ADDRESS_DEF);
  0D26    30E3    LDIA	0xE3
  0D27    118A    CLRB	0xA,3
  0D28    25D2    CALL	0x5D2
  0D29    158A    SETB	0xA,3
101:              	
102:              	//soft_delay_ms(10);
103:              
104:              	SetRunEn(0,1,LEDR1_Vol);
  0D2A    01F3    CLR	0x73
  0D2B    0AF3    INCR	0x73
  0D2C    0833    LD	A,0x33
  0D2D    00F4    LD	0x74,A
  0D2E    3000    LDIA	0x0
  0D2F    01F5    CLR	0x75
  0D30    118A    CLRB	0xA,3
  0D31    255D    CALL	0x55D
  0D32    158A    SETB	0xA,3
105:              	SetRunEn(1,1,LEDR2_Vol);
  0D33    01F3    CLR	0x73
  0D34    0AF3    INCR	0x73
  0D35    0834    LD	A,0x34
  0D36    00F4    LD	0x74,A
  0D37    3001    LDIA	0x1
  0D38    01F5    CLR	0x75
  0D39    118A    CLRB	0xA,3
  0D3A    255D    CALL	0x55D
  0D3B    158A    SETB	0xA,3
106:              	Enable_Interrupt();
  0D3C    158A    SETB	0xA,3
  0D3D    207C    CALL	0x7C
  0D3E    158A    SETB	0xA,3
107:              	
108:              	Timer1_Init(TIMER1_DIV_8);   /**<Timer is initialized and set to 8 frequency division*/
  0D3F    3030    LDIA	0x30
  0D40    158A    SETB	0xA,3
  0D41    208A    CALL	0x8A
  0D42    158A    SETB	0xA,3
109:                  Timer1_start(1000, 0);       /**< 5ms --> 5000, 25   2ms */ 
  0D43    30E8    LDIA	0xE8
  0D44    00F3    LD	0x73,A
  0D45    3003    LDIA	0x3
  0D46    00F4    LD	0x74,A
  0D47    01F5    CLR	0x75
  0D48    158A    SETB	0xA,3
  0D49    2091    CALL	0x91
  0D4A    158A    SETB	0xA,3
  0D4B    3007    LDIA	0x7
110:              	Time1s_cot = 0;
  0D4C    01A6    CLR	0x26
  0D4D    01A7    CLR	0x27
111:              	WDT_enable(7);
  0D4E    158A    SETB	0xA,3
  0D4F    20A1    CALL	0xA1
  0D50    158A    SETB	0xA,3
112:              
113:              	BriCoTem_Value.Brightness =100;
  0D51    3064    LDIA	0x64
  0D52    1283    CLRB	0x3,5
  0D53    1303    CLRB	0x3,6
  0D54    00A0    LD	0x20,A
114:              	BriCoTem_Value.ColorTemp = 50;
  0D55    3032    LDIA	0x32
  0D56    00A1    LD	0x21,A
115:              
116:              	while(1)
117:              	{
118:              		//
119:              		//
120:              		//*****EEPROM测试引脚为RB4，RB5*******
121:              		//*****原来的SCL和SDA为RB7和RB6*******
122:              		if(TimeEN_LEDTrun==0 && FCLK_1MS) 
  0D57    1283    CLRB	0x3,5
  0D58    1303    CLRB	0x3,6
  0D59    08BD    TESTZ	0x3D
  0D5A    1903    SZB	0x3,2
  0D5B    1C3E    SNZB	0x3E,0
  0D5C    2D76    JP	0x576
123:              		{
124:              			if(Timecnt_LEDTrun++>1700) 
  0D5D    0AAA    INCR	0x2A
  0D5E    1903    SZB	0x3,2
  0D5F    0AAB    INCR	0x2B
  0D60    3006    LDIA	0x6
  0D61    022B    SUBA	0x2B
  0D62    30A6    LDIA	0xA6
  0D63    1903    SZB	0x3,2
  0D64    022A    SUBA	0x2A
  0D65    1C03    SNZB	0x3,0
  0D66    2D76    JP	0x576
125:              			{
126:              				TimeEN_LEDTrun=1;
  0D67    01BD    CLR	0x3D
  0D68    0ABD    INCR	0x3D
127:              				soft_delay_ms(1);
  0D69    01F3    CLR	0x73
  0D6A    0AF3    INCR	0x73
  0D6B    01F4    CLR	0x74
  0D6C    118A    CLRB	0xA,3
  0D6D    259E    CALL	0x59E
  0D6E    158A    SETB	0xA,3
128:              				EP_SetONOFFStep(0);
  0D6F    3000    LDIA	0x0
  0D70    158A    SETB	0xA,3
  0D71    260F    CALL	0x60F
  0D72    158A    SETB	0xA,3
129:              				WDT_clear();				
  0D73    118A    CLRB	0xA,3
  0D74    259C    CALL	0x59C
  0D75    158A    SETB	0xA,3
130:              			}
131:              		}
132:              
133:              		if(SysRunTime_3S==0 && FCLK_1MS) 
  0D76    1283    CLRB	0x3,5
  0D77    1303    CLRB	0x3,6
  0D78    08BC    TESTZ	0x3C
  0D79    1903    SZB	0x3,2
  0D7A    1C3E    SNZB	0x3E,0
  0D7B    2DA0    JP	0x5A0
134:              		{
135:              			if(Timecnt_3S++>3000)//1600)
  0D7C    0AA8    INCR	0x28
  0D7D    1903    SZB	0x3,2
  0D7E    0AA9    INCR	0x29
  0D7F    300B    LDIA	0xB
  0D80    0229    SUBA	0x29
  0D81    30BA    LDIA	0xBA
  0D82    1903    SZB	0x3,2
  0D83    0228    SUBA	0x28
  0D84    1C03    SNZB	0x3,0
  0D85    2DA0    JP	0x5A0
136:              			{
137:              				SysRunTime_3S=1; 
  0D86    01BC    CLR	0x3C
  0D87    0ABC    INCR	0x3C
138:              				
139:              				i=EP_IsADDCfg();
  0D88    118A    CLRB	0xA,3
  0D89    202C    CALL	0x2C
  0D8A    158A    SETB	0xA,3
  0D8B    00E7    LD	0x67,A
140:              				if(i)
  0D8C    0867    LD	A,0x67
  0D8D    1903    SZB	0x3,2
  0D8E    2DA0    JP	0x5A0
141:              				{
142:              					EP_GetRFAdd(RF_ADDRESS);
  0D8F    303F    LDIA	0x3F
  0D90    118A    CLRB	0xA,3
  0D91    2745    CALL	0x745
  0D92    158A    SETB	0xA,3
143:              
144:              					soft_delay_ms(1);
  0D93    01F3    CLR	0x73
  0D94    0AF3    INCR	0x73
  0D95    01F4    CLR	0x74
  0D96    118A    CLRB	0xA,3
  0D97    259E    CALL	0x59E
  0D98    158A    SETB	0xA,3
145:              					RF_ADDSSet(RF_ADDRESS);
  0D99    303F    LDIA	0x3F
  0D9A    118A    CLRB	0xA,3
  0D9B    25D2    CALL	0x5D2
  0D9C    158A    SETB	0xA,3
146:              					WDT_clear();
  0D9D    118A    CLRB	0xA,3
  0D9E    259C    CALL	0x59C
  0D9F    158A    SETB	0xA,3
147:              				}
148:              			}  
149:              		}
150:              		
151:              		if(FCLK_16MS && Time1s_cot==0)
  0DA0    1283    CLRB	0x3,5
  0DA1    1303    CLRB	0x3,6
  0DA2    1E3E    SNZB	0x3E,4
  0DA3    2DBB    JP	0x5BB
  0DA4    0827    LD	A,0x27
  0DA5    0426    ORA	0x26
  0DA6    1D03    SNZB	0x3,2
  0DA7    2DBB    JP	0x5BB
152:              		{
153:              			if(j)
  0DA8    0866    LD	A,0x66
  0DA9    1903    SZB	0x3,2
  0DAA    2DB3    JP	0x5B3
154:              			{
155:              				j = 0;
  0DAB    01E6    CLR	0x66
156:              				RF_Init4();	//普通模式，单向
  0DAC    118A    CLRB	0xA,3
  0DAD    25E5    CALL	0x5E5
  0DAE    158A    SETB	0xA,3
157:              				RF_Set_RxMode1();				
  0DAF    118A    CLRB	0xA,3
  0DB0    200D    CALL	0xD
  0DB1    158A    SETB	0xA,3
158:              			}
  0DB2    2DBB    JP	0x5BB
159:              			else
160:              			{
161:              				j = 1;
  0DB3    01E6    CLR	0x66
  0DB4    0AE6    INCR	0x66
162:              				//RF_Init();
163:              				RF_Init3();	//增强模式，双向
  0DB5    118A    CLRB	0xA,3
  0DB6    203A    CALL	0x3A
  0DB7    158A    SETB	0xA,3
164:              				RF_Set_RxMode();		
  0DB8    118A    CLRB	0xA,3
  0DB9    2013    CALL	0x13
  0DBA    158A    SETB	0xA,3
165:              			}
166:              		}
167:              
168:              		if(j == 1)	
  0DBB    0B66    SZDECA	0x66
  0DBC    2DDB    JP	0x5DB
169:              		{			
170:              			if(RF_ENHANCE_RxData(rf_buf,PAYLOAD_WIDTH,ack_buf))
  0DBD    3008    LDIA	0x8
  0DBE    00C8    LD	0x48,A
  0DBF    305D    LDIA	0x5D
  0DC0    00C9    LD	0x49,A
  0DC1    30B0    LDIA	0xB0
  0DC2    158A    SETB	0xA,3
  0DC3    2237    CALL	0x237
  0DC4    158A    SETB	0xA,3
  0DC5    3A00    XORIA	0x0
  0DC6    1903    SZB	0x3,2
  0DC7    2DDB    JP	0x5DB
171:              			{
172:              	
173:              				Key_Handle(rf_buf);
  0DC8    30B0    LDIA	0xB0
  0DC9    00D6    LD	0x56,A
  0DCA    3002    LDIA	0x2
  0DCB    118A    CLRB	0xA,3
  0DCC    2A57    JP	0x257
174:              				 for(i=0;i<8;i++) rf_buf[i]=0; WDT_clear();
  0DCD    01E7    CLR	0x67
  0DCE    0867    LD	A,0x67
  0DCF    3EB0    ADDIA	0xB0
  0DD0    0084    LD	0x4,A
  0DD1    3008    LDIA	0x8
  0DD2    1383    CLRB	0x3,7
  0DD3    0180    CLR	0x0
  0DD4    0AE7    INCR	0x67
  0DD5    0267    SUBA	0x67
  0DD6    1C03    SNZB	0x3,0
  0DD7    2DCE    JP	0x5CE
  0DD8    118A    CLRB	0xA,3
  0DD9    259C    CALL	0x59C
  0DDA    158A    SETB	0xA,3
175:              			}		
176:              		}
177:              		if(j == 0)
  0DDB    1283    CLRB	0x3,5
  0DDC    1303    CLRB	0x3,6
  0DDD    08E6    TESTZ	0x66
  0DDE    1903    SZB	0x3,2
  0DDF    2DF1    JP	0x5F1
178:              		{
179:              			recive_task(); 	
  07FE    158A    SETB	0xA,3
  07FF    2DE0    JP	0x5E0
180:              		}
181:              		PWM_12SetVol(); 
  0DE0    118A    CLRB	0xA,3
  0DE1    2019    CALL	0x19
  0DE2    158A    SETB	0xA,3
182:              					
183:              		
184:              		getClock();
  0DE3    158A    SETB	0xA,3
  0DE4    20AC    CALL	0xAC
  0DE5    158A    SETB	0xA,3
185:              		if(FCLK_1MS)
  0DE6    1C3E    SNZB	0x3E,0
  0DE7    2E08    JP	0x608
186:              		{
187:              			Key_HandRunning();
  0DE8    158A    SETB	0xA,3
  0DE9    2149    CALL	0x149
  0DEA    158A    SETB	0xA,3
188:              			
189:              			if(++DingShi > 99)
  0DEB    3064    LDIA	0x64
  0DEC    0AAE    INCR	0x2E
  0DED    022E    SUBA	0x2E
  0DEE    1803    SZB	0x3,0
  0DEF    2DF4    JP	0x5F4
  0DF0    2E08    JP	0x608
  0DF1    30FE    LDIA	0xFE
  0DF2    118A    CLRB	0xA,3
  0DF3    2883    JP	0x83
190:              			{
191:              				DingShi=0;
  0DF4    01AE    CLR	0x2E
192:              			
193:              				if(SysDingShiEn) 
  0DF5    0839    LD	A,0x39
  0DF6    1903    SZB	0x3,2
  0DF7    2E08    JP	0x608
194:              				{
195:              					SysRunTimeCnt--;
  0DF8    3001    LDIA	0x1
  0DF9    02EA    SUBR	0x6A
  0DFA    3000    LDIA	0x0
  0DFB    1C03    SNZB	0x3,0
  0DFC    03EB    DECR	0x6B
  0DFD    02EB    SUBR	0x6B
196:              					if(SysRunTimeCnt==0)
  0DFE    086B    LD	A,0x6B
  0DFF    046A    ORA	0x6A
  0E00    1D03    SNZB	0x3,2
  0E01    2E08    JP	0x608
197:              					{					
198:              						SysDingShiEn=0;
  0E02    01B9    CLR	0x39
199:              						SysRunTimeCnt=0;
  0E03    01EA    CLR	0x6A
  0E04    01EB    CLR	0x6B
200:              						LED_ALLOFF();
  0E05    118A    CLRB	0xA,3
  0E06    215D    CALL	0x15D
  0E07    158A    SETB	0xA,3
201:              					}	
202:              				}	
203:              			}
204:              		}
205:              
206:              		WDT_clear();		
  0E08    118A    CLRB	0xA,3
  0E09    259C    CALL	0x59C
  0E0A    158A    SETB	0xA,3
  0E0B    2D57    JP	0x557
207:              	}
208:              
209:              }
210:              
211:              
212:              
213:              
214:              
215:              
216:              
217:              
218:              
219:              //--------------------------------------------------------
220:              
221:              
222:              void PWM_LED1(uchar PWM)
223:              {
  0596    00F3    LD	0x73,A
224:              	PWM_CH_LED1=PWM;
  0597    00B5    LD	0x35,A
  0598    0008    RET
225:              }
226:              
227:              
228:              void PWM_LED2(uchar PWM)
229:              {
  0599    00F3    LD	0x73,A
230:              	PWM_CH_LED2=PWM;
  059A    00B6    LD	0x36,A
  059B    0008    RET
231:              }
232:              
233:              
234:              void PWM_12SetVol(void)
235:              {
236:              	CCP1_set_duty_cycle(PWM_CH_LED2);
  0019    0836    LD	A,0x36
  001A    00F3    LD	0x73,A
  001B    01F4    CLR	0x74
  001C    2702    CALL	0x702
  001D    118A    CLRB	0xA,3
237:              	CCP2_set_duty_cycle(PWM_CH_LED1);
  001E    0835    LD	A,0x35
  001F    00F3    LD	0x73,A
  0020    01F4    CLR	0x74
  0021    2F1B    JP	0x71B
238:              }
239:              
240:              //--------------------------------------------------------
241:              
242:              
243:              
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\recive.c ----------------------------------------------------------------------
1:                #include "recive.h"
2:                #include "cms.h"
3:                #include "system.h"
4:                #include "WDT.h"
5:                #include "rf297L.h"
6:                #include "timer1.h"
7:                #include "24lc02.h"
8:                #include "timer1.h"
9:                #include "Key.h"
10:               #include "Buffer.H"
11:               #include "PWM.h"
12:               
13:               struct BriCoTem BriCoTem_Value;
14:               
15:               
16:               const unsigned char crc_2_4G_lib[21]={0xc7 ,0x8d ,0xd2 ,0x57 ,0xa1 ,0x3d ,0xa7 ,0x66 ,0xb0 ,0x75 ,0x31 ,0x11 ,0x48 ,0x96 ,0x77 ,0xf8 ,0xe3 ,0x46 ,0xe9,0xab ,0xd0 };
17:               const unsigned char crc_lab[16]={0x41,0x92,0x53,0x2A,0xFC,0xAB,0xCE,0x26,0x0D,0x1E,0x99,0x78,0x00,0x22,0x99,0xDE};
18:               const unsigned char ble_crc_38[42]={
19:               		0xD6, 0xC5, 0x44, 0x20, 0x59,
20:               		0xDE, 0xE1, 0x8F, 0x1B, 0xA5,
21:               		0xAF, 0x42, 0x7B, 0x4E, 0xCD,
22:               		0x60, 0xEB, 0x62, 0x22, 0x90,
23:               		0x2C, 0xEF, 0xF0, 0xC7, 0x8D,
24:               		0xD2, 0x57, 0xA1, 0x3D, 0xA7,
25:               		0x66, 0xB0, 0x75, 0x31, 0x11,
26:               		0x48, 0x96, 0x77 ,0xF8, 0xE3,
27:               		0x46, 0xE9
28:               	};
29:               uchar addr_buf[16];
30:               uchar rf_buf[18]= {0};
31:               uchar Count_Save = 0;
32:               uchar Pairing_Num;
33:               extern uchar SysDingShiEn=0;
34:               extern uchar LED_ON_Sat=1; 
35:               extern uchar LED_Chg_Cnt=0; 
36:               extern uchar LEDR1_Vol=0;
37:               extern uchar LEDR2_Vol=0;
38:               extern uchar SysRunTime_3S = 0;
39:               extern unsigned int Time1s_cot;
40:               
41:               extern void ledSetGradual(uint8_t set_brightness, uint8_t set_colour_tempr);
42:               extern void PWM_LED1(uchar PWM);
43:               extern void PWM_LED2(uchar PWM);
44:               extern void LEDCon_Chg(void);
45:               
46:               
47:               
48:               void recive_task(void);
49:               unsigned short UpdateCRC(unsigned char *CRC_input, unsigned int len);
50:               uchar rx_data(void);
51:               
52:               unsigned short UpdateCRC(unsigned char *CRC_input, unsigned int len)
53:               {
  0AE1    00C8    LD	0x48,A
  0AE2    3055    LDIA	0x55
54:                   unsigned char i,k = 0; 
  0AE3    01C9    CLR	0x49
55:                   unsigned short CRC_acc=0x5555;
  0AE4    00CB    LD	0x4B,A
  0AE5    00CC    LD	0x4C,A
56:                   #define POLY_  0x1021
57:                   while (len--)
  0AE6    3001    LDIA	0x1
  0AE7    02F3    SUBR	0x73
  0AE8    3000    LDIA	0x0
  0AE9    1C03    SNZB	0x3,0
  0AEA    03F4    DECR	0x74
  0AEB    02F4    SUBR	0x74
  0AEC    0A73    INCA	0x73
  0AED    1903    SZB	0x3,2
  0AEE    0A74    INCA	0x74
  0AEF    1903    SZB	0x3,2
  0AF0    2B13    JP	0x313
58:                   {
59:                       CRC_acc = CRC_acc ^ (CRC_input[k++] << 8);
  0AF1    0849    LD	A,0x49
  0AF2    0748    ADDA	0x48
  0AF3    00C5    LD	0x45,A
  0AF4    0084    LD	0x4,A
  0AF5    0800    LD	A,0x0
  0AF6    00C6    LD	0x46,A
  0AF7    01C7    CLR	0x47
  0AF8    00C7    LD	0x47,A
  0AF9    01C6    CLR	0x46
  0AFA    0846    LD	A,0x46
  0AFB    06CB    XORR	0x4B
  0AFC    0847    LD	A,0x47
  0AFD    06CC    XORR	0x4C
  0AFE    0AC9    INCR	0x49
60:                       
61:                       for (i = 0; i < 8; i++)
  0AFF    01CA    CLR	0x4A
62:                       {
63:                           if ((CRC_acc & 0x8000) == 0x8000)
  0B00    1FCC    SNZB	0x4C,7
  0B01    2B0A    JP	0x30A
  0B02    3021    LDIA	0x21
64:                           {
65:                               CRC_acc = CRC_acc << 1;
  0B03    1003    CLRB	0x3,0
  0B04    0DCB    RLCR	0x4B
  0B05    0DCC    RLCR	0x4C
66:                               CRC_acc ^= POLY_;
  0B06    06CB    XORR	0x4B
  0B07    3010    LDIA	0x10
  0B08    06CC    XORR	0x4C
67:                           }
  0B09    2B0D    JP	0x30D
68:                           else
69:                           {
70:                               CRC_acc = CRC_acc << 1;
  0B0A    1003    CLRB	0x3,0
  0B0B    0DCB    RLCR	0x4B
  0B0C    0DCC    RLCR	0x4C
  0B0D    3008    LDIA	0x8
  0B0E    0ACA    INCR	0x4A
  0B0F    024A    SUBA	0x4A
  0B10    1803    SZB	0x3,0
  0B11    2AE6    JP	0x2E6
  0B12    2B00    JP	0x300
71:                           }
72:                       }
73:                   }
74:                   return CRC_acc;
  0B13    084C    LD	A,0x4C
  0B14    00F4    LD	0x74,A
  0B15    084B    LD	A,0x4B
  0B16    00F3    LD	0x73,A
  0B17    0008    RET
75:               }
76:               
77:               
78:               
79:               uchar rx_data(void)
80:               {
  0A49    3012    LDIA	0x12
81:               	uchar rx_flag=0;
  0A4A    01D3    CLR	0x53
82:               	uchar rand=0;
83:               	uchar i=0;
  0A4B    01D4    CLR	0x54
84:               	uint crc16=0; 
  0A4C    01D0    CLR	0x50
  0A4D    01D1    CLR	0x51
85:               
86:               	if(RF_RxData(rf_buf,18))
  0A4E    00C8    LD	0x48,A
  0A4F    30B0    LDIA	0xB0
  0A50    2318    CALL	0x318
  0A51    158A    SETB	0xA,3
  0A52    3A00    XORIA	0x0
  0A53    1903    SZB	0x3,2
  0A54    2ADF    JP	0x2DF
87:               	{
88:               		for(i=0;i<18;i++)
  0A55    01D4    CLR	0x54
89:               			{
90:               				rf_buf[i]=rf_buf[i]^crc_2_4G_lib[3+i]^ble_crc_38[21+i];
  0A56    0854    LD	A,0x54
  0A57    3E16    ADDIA	0x16
  0A58    0084    LD	0x4,A
  0A59    158A    SETB	0xA,3
  0A5A    200A    CALL	0xA
  0A5B    158A    SETB	0xA,3
  0A5C    00CD    LD	0x4D,A
  0A5D    0854    LD	A,0x54
  0A5E    3E2E    ADDIA	0x2E
  0A5F    0084    LD	0x4,A
  0A60    158A    SETB	0xA,3
  0A61    200A    CALL	0xA
  0A62    158A    SETB	0xA,3
  0A63    00CE    LD	0x4E,A
  0A64    0854    LD	A,0x54
  0A65    3EB0    ADDIA	0xB0
  0A66    0084    LD	0x4,A
  0A67    1383    CLRB	0x3,7
  0A68    0800    LD	A,0x0
  0A69    064E    XORA	0x4E
  0A6A    064D    XORA	0x4D
  0A6B    00CF    LD	0x4F,A
  0A6C    0854    LD	A,0x54
  0A6D    3EB0    ADDIA	0xB0
  0A6E    0084    LD	0x4,A
  0A6F    084F    LD	A,0x4F
  0A70    0080    LD	0x0,A
  0A71    3012    LDIA	0x12
  0A72    0AD4    INCR	0x54
  0A73    0254    SUBA	0x54
  0A74    1C03    SNZB	0x3,0
  0A75    2A56    JP	0x256
91:               			}
92:               		crc16 = rf_buf[16]+rf_buf[17]*256;
  0A76    1683    SETB	0x3,5
  0A77    0841    LD	A,0x41
  0A78    1283    CLRB	0x3,5
  0A79    00CD    LD	0x4D,A
  0A7A    01CE    CLR	0x4E
  0A7B    00CE    LD	0x4E,A
  0A7C    01CD    CLR	0x4D
  0A7D    1683    SETB	0x3,5
  0A7E    0840    LD	A,0x40
  0A7F    1283    CLRB	0x3,5
  0A80    074D    ADDA	0x4D
  0A81    00D0    LD	0x50,A
  0A82    084E    LD	A,0x4E
  0A83    1803    SZB	0x3,0
  0A84    0A4E    INCA	0x4E
  0A85    00D1    LD	0x51,A
93:               		for(i=0;i<16;i++)
  0A86    01D4    CLR	0x54
94:               			{
95:               				rf_buf[i]=rf_buf[i]^crc_lab[i];
  0A87    0854    LD	A,0x54
  0A88    3E40    ADDIA	0x40
  0A89    0084    LD	0x4,A
  0A8A    158A    SETB	0xA,3
  0A8B    200A    CALL	0xA
  0A8C    158A    SETB	0xA,3
  0A8D    00CD    LD	0x4D,A
  0A8E    0854    LD	A,0x54
  0A8F    3EB0    ADDIA	0xB0
  0A90    0084    LD	0x4,A
  0A91    0800    LD	A,0x0
  0A92    064D    XORA	0x4D
  0A93    00CE    LD	0x4E,A
  0A94    0854    LD	A,0x54
  0A95    3EB0    ADDIA	0xB0
  0A96    0084    LD	0x4,A
  0A97    084E    LD	A,0x4E
  0A98    0080    LD	0x0,A
  0A99    3010    LDIA	0x10
  0A9A    0AD4    INCR	0x54
  0A9B    0254    SUBA	0x54
  0A9C    1C03    SNZB	0x3,0
  0A9D    2A87    JP	0x287
96:               			}
97:               		rand = rf_buf[15];
  0A9E    1683    SETB	0x3,5
  0A9F    083F    LD	A,0x3F
  0AA0    1283    CLRB	0x3,5
  0AA1    00D2    LD	0x52,A
98:               		for(i=7;i<15;i++)
  0AA2    3007    LDIA	0x7
  0AA3    00D4    LD	0x54,A
99:               			{
100:              				rf_buf[i]^=rand;
  0AA4    0854    LD	A,0x54
  0AA5    3EB0    ADDIA	0xB0
  0AA6    0084    LD	0x4,A
  0AA7    0852    LD	A,0x52
  0AA8    0680    XORR	0x0
  0AA9    300F    LDIA	0xF
  0AAA    0AD4    INCR	0x54
  0AAB    0254    SUBA	0x54
  0AAC    1C03    SNZB	0x3,0
  0AAD    2AA4    JP	0x2A4
101:              			}
102:              		if(crc16 ==UpdateCRC(rf_buf,16) )
  0AAE    3010    LDIA	0x10
  0AAF    00F3    LD	0x73,A
  0AB0    30B0    LDIA	0xB0
  0AB1    01F4    CLR	0x74
  0AB2    22E1    CALL	0x2E1
  0AB3    158A    SETB	0xA,3
  0AB4    0851    LD	A,0x51
  0AB5    0674    XORA	0x74
  0AB6    1D03    SNZB	0x3,2
  0AB7    2ABA    JP	0x2BA
  0AB8    0850    LD	A,0x50
  0AB9    0673    XORA	0x73
  0ABA    1D03    SNZB	0x3,2
  0ABB    2ADF    JP	0x2DF
103:              			{
104:              				if((rf_buf[3]==0)&&(rf_buf[4]==0)&&(rf_buf[5]==0)&&(rf_buf[6]==0))
  0ABC    1683    SETB	0x3,5
  0ABD    08B3    TESTZ	0x33
  0ABE    1D03    SNZB	0x3,2
  0ABF    2ACC    JP	0x2CC
  0AC0    08B4    TESTZ	0x34
  0AC1    1D03    SNZB	0x3,2
  0AC2    2ACC    JP	0x2CC
  0AC3    08B5    TESTZ	0x35
  0AC4    1D03    SNZB	0x3,2
  0AC5    2ACC    JP	0x2CC
  0AC6    08B6    TESTZ	0x36
  0AC7    1D03    SNZB	0x3,2
  0AC8    2ACC    JP	0x2CC
105:              					{
106:              						rx_flag=0;
  0AC9    1283    CLRB	0x3,5
  0ACA    01D3    CLR	0x53
107:              					}
  0ACB    2ADF    JP	0x2DF
108:              				else if((rf_buf[3]==0xff)&&(rf_buf[4]==0xff)&&(rf_buf[5]==0xff)&&(rf_buf[6]==0xff))
  0ACC    0833    LD	A,0x33
  0ACD    3AFF    XORIA	0xFF
  0ACE    1D03    SNZB	0x3,2
  0ACF    2ADC    JP	0x2DC
  0AD0    0834    LD	A,0x34
  0AD1    3AFF    XORIA	0xFF
  0AD2    1D03    SNZB	0x3,2
  0AD3    2ADC    JP	0x2DC
  0AD4    0835    LD	A,0x35
  0AD5    3AFF    XORIA	0xFF
  0AD6    1D03    SNZB	0x3,2
  0AD7    2ADC    JP	0x2DC
  0AD8    0836    LD	A,0x36
  0AD9    3AFF    XORIA	0xFF
  0ADA    1903    SZB	0x3,2
  0ADB    2AC9    JP	0x2C9
109:              					{
110:              						rx_flag=0;
111:              					}
112:              				else
113:              					rx_flag=1;
  0ADC    1283    CLRB	0x3,5
  0ADD    01D3    CLR	0x53
  0ADE    0AD3    INCR	0x53
114:              			}
115:              		
116:              	}
117:              	return rx_flag;
  0ADF    0853    LD	A,0x53
  0AE0    0008    RET
118:              }
119:              
120:              void Write_Remote_Addr(void)
121:              {
122:              	uint8_t i;
123:              	uint8_t j = 3;
  0B89    3003    LDIA	0x3
  0B8A    00CF    LD	0x4F,A
124:              	for(i = 15; i > 3; i--)
  0B8B    300F    LDIA	0xF
  0B8C    00D0    LD	0x50,A
125:              	{
126:              		addr_buf[i] = addr_buf[i - 4];
  0B8D    0850    LD	A,0x50
  0B8E    3EBE    ADDIA	0xBE
  0B8F    0084    LD	0x4,A
  0B90    0800    LD	A,0x0
  0B91    00CE    LD	0x4E,A
  0B92    0850    LD	A,0x50
  0B93    3EC2    ADDIA	0xC2
  0B94    0084    LD	0x4,A
  0B95    084E    LD	A,0x4E
  0B96    0080    LD	0x0,A
  0B97    3004    LDIA	0x4
  0B98    03D0    DECR	0x50
  0B99    0250    SUBA	0x50
  0B9A    1803    SZB	0x3,0
  0B9B    2B8D    JP	0x38D
127:              	}
128:              	for(i = 0; i < 4; i++)
  0B9C    01D0    CLR	0x50
129:              	{
130:              		addr_buf[i] = rf_buf[j];
  0B9D    084F    LD	A,0x4F
  0B9E    3EB0    ADDIA	0xB0
  0B9F    0084    LD	0x4,A
  0BA0    0800    LD	A,0x0
  0BA1    00CE    LD	0x4E,A
  0BA2    0850    LD	A,0x50
  0BA3    3EC2    ADDIA	0xC2
  0BA4    0084    LD	0x4,A
  0BA5    084E    LD	A,0x4E
  0BA6    0080    LD	0x0,A
  0BA7    3004    LDIA	0x4
131:              		j++;
  0BA8    0ACF    INCR	0x4F
  0BA9    0AD0    INCR	0x50
  0BAA    0250    SUBA	0x50
  0BAB    1C03    SNZB	0x3,0
  0BAC    2B9D    JP	0x39D
132:              	}
133:              	AT24C02_Write_Msg(30, addr_buf, 16);
  0BAD    30C2    LDIA	0xC2
  0BAE    00C9    LD	0x49,A
  0BAF    3010    LDIA	0x10
  0BB0    00CA    LD	0x4A,A
  0BB1    301E    LDIA	0x1E
  0BB2    2BF1    JP	0x3F1
134:              	//AT24C02_Read_Msg(30, addr_buf, 16);
135:              }
136:              
137:              uint8_t Data_Check(void)
138:              {
139:              	uint8_t i;
140:              	uint8_t j;
141:              	uint8_t p = 0;
  012F    1283    CLRB	0x3,5
  0130    3003    LDIA	0x3
  0131    01C6    CLR	0x46
142:              	uint8_t k = 3;
  0132    00C5    LD	0x45,A
143:              	uint8_t temp = 0;
144:              	for(i = 0; i < 4; i++)
  0133    01C9    CLR	0x49
145:              	{
146:              		temp = 0;
  0134    01C7    CLR	0x47
147:              		for(j = 0;j < 4; j++)
  0135    01C8    CLR	0x48
148:              		{
149:              			if(rf_buf[k + j] == addr_buf[p])
  0136    0846    LD	A,0x46
  0137    3EC2    ADDIA	0xC2
  0138    0084    LD	0x4,A
  0139    1383    CLRB	0x3,7
  013A    0800    LD	A,0x0
  013B    00F3    LD	0x73,A
  013C    30B0    LDIA	0xB0
  013D    0748    ADDA	0x48
  013E    00F4    LD	0x74,A
  013F    0845    LD	A,0x45
  0140    0774    ADDA	0x74
  0141    00F5    LD	0x75,A
  0142    0084    LD	0x4,A
  0143    0800    LD	A,0x0
  0144    0673    XORA	0x73
  0145    1903    SZB	0x3,2
150:              			{
151:              				temp++;
  0146    0AC7    INCR	0x47
  0147    3004    LDIA	0x4
152:              			}
153:              			p++;
  0148    0AC6    INCR	0x46
  0149    0AC8    INCR	0x48
  014A    0248    SUBA	0x48
  014B    1C03    SNZB	0x3,0
  014C    2936    JP	0x136
154:              		}
155:              		if(temp == 4)
  014D    0847    LD	A,0x47
  014E    3A04    XORIA	0x4
  014F    1D03    SNZB	0x3,2
  0150    2953    JP	0x153
156:              		{
157:              			return i;
  0151    0849    LD	A,0x49
  0152    0008    RET
158:              		}
159:              		if(i == 3)
  0153    0849    LD	A,0x49
  0154    3A03    XORIA	0x3
  0155    1903    SZB	0x3,2
160:              		{
161:              			return 0xFF;
  0156    34FF    RET	0xFF
  0157    3004    LDIA	0x4
  0158    0AC9    INCR	0x49
  0159    0249    SUBA	0x49
  015A    1803    SZB	0x3,0
  015B    0008    RET
  015C    2934    JP	0x134
162:              		}
163:              	}
164:              	
165:              }
166:              
167:              void Delete_One_RemoteAddr(void)
168:              {
169:              	uint8_t i;
170:              	uint8_t j;
171:              	uint8_t p;
172:              	i = Data_Check();
  0B51    118A    CLRB	0xA,3
  0B52    212F    CALL	0x12F
  0B53    158A    SETB	0xA,3
  0B54    00D1    LD	0x51,A
173:              	i = 4 * i;
  0B55    1003    CLRB	0x3,0
  0B56    0DD1    RLCR	0x51
  0B57    1003    CLRB	0x3,0
  0B58    0DD1    RLCR	0x51
174:              	p = 16 - i;
  0B59    0851    LD	A,0x51
  0B5A    3C10    SUBIA	0x10
  0B5B    00CF    LD	0x4F,A
175:              	for(j = 0; j < p; j++)
  0B5C    01D0    CLR	0x50
  0B5D    084F    LD	A,0x4F
  0B5E    0250    SUBA	0x50
  0B5F    1803    SZB	0x3,0
  0B60    2B6E    JP	0x36E
176:              	{
177:              		addr_buf[i] = addr_buf[i + 4];
  0B61    0851    LD	A,0x51
  0B62    3EC6    ADDIA	0xC6
  0B63    0084    LD	0x4,A
  0B64    0800    LD	A,0x0
  0B65    00CE    LD	0x4E,A
  0B66    0851    LD	A,0x51
  0B67    3EC2    ADDIA	0xC2
  0B68    0084    LD	0x4,A
  0B69    084E    LD	A,0x4E
  0B6A    0080    LD	0x0,A
178:              		i++;
  0B6B    0AD1    INCR	0x51
  0B6C    0AD0    INCR	0x50
  0B6D    2B5D    JP	0x35D
179:              	}
180:              	AT24C02_Write_Msg(30, addr_buf, 16);
  0B6E    30C2    LDIA	0xC2
  0B6F    00C9    LD	0x49,A
  0B70    3010    LDIA	0x10
  0B71    00CA    LD	0x4A,A
  0B72    301E    LDIA	0x1E
  0B73    2BF1    JP	0x3F1
181:              	//AT24C02_Read_Msg(30, addr_buf, 16);
182:              }
183:              
184:              
185:              
186:              uint8_t brightnessConvert(uint8_t src)
187:              {
188:                  return ((src * 10 + 100) / 11);
189:              }
190:              /******************************************************************************/
191:              //          色温亮度转换                      
192:              /******************************************************************************/
193:              
194:              uint16_t Convert_Duty_Cycle1(uint8_t Brightness,uint8_t Color_Temp)
195:              {
  019B    00CA    LD	0x4A,A
196:              	uint16_t temp = 0;
197:              	temp = Brightness * Color_Temp;
  019C    00F3    LD	0x73,A
  019D    01F4    CLR	0x74
  019E    0848    LD	A,0x48
  019F    00F5    LD	0x75,A
  01A0    01F6    CLR	0x76
  01A1    21D5    CALL	0x1D5
  01A2    118A    CLRB	0xA,3
198:              	temp /= 100;
  01A3    2795    CALL	0x795
  01A4    118A    CLRB	0xA,3
  01A5    21EE    CALL	0x1EE
  01A6    118A    CLRB	0xA,3
  01A7    0874    LD	A,0x74
  01A8    00CC    LD	0x4C,A
  01A9    0873    LD	A,0x73
  01AA    00CB    LD	0x4B,A
199:              	temp *= 255;
  01AB    30FF    LDIA	0xFF
  01AC    00F3    LD	0x73,A
  01AD    01F4    CLR	0x74
  01AE    084C    LD	A,0x4C
  01AF    00F6    LD	0x76,A
  01B0    084B    LD	A,0x4B
  01B1    00F5    LD	0x75,A
  01B2    21D5    CALL	0x1D5
  01B3    118A    CLRB	0xA,3
200:              	temp /= 100;
  01B4    2795    CALL	0x795
  01B5    118A    CLRB	0xA,3
  01B6    21EE    CALL	0x1EE
  01B7    118A    CLRB	0xA,3
  01B8    0874    LD	A,0x74
  01B9    00CC    LD	0x4C,A
  01BA    0873    LD	A,0x73
  01BB    00CB    LD	0x4B,A
201:              	if(temp >= 250) 
  01BC    3000    LDIA	0x0
  01BD    024C    SUBA	0x4C
  01BE    30FA    LDIA	0xFA
  01BF    1903    SZB	0x3,2
  01C0    024B    SUBA	0x4B
  01C1    1C03    SNZB	0x3,0
  01C2    29C6    JP	0x1C6
202:              	{
203:              		temp = 250;
  01C3    30FA    LDIA	0xFA
  01C4    00CB    LD	0x4B,A
  01C5    01CC    CLR	0x4C
204:              	}
205:              	if(temp <= 2) 
  01C6    3000    LDIA	0x0
  01C7    024C    SUBA	0x4C
  01C8    3003    LDIA	0x3
  01C9    1903    SZB	0x3,2
  01CA    024B    SUBA	0x4B
  01CB    1803    SZB	0x3,0
  01CC    29D0    JP	0x1D0
206:              	{
207:              		temp = 2;
  01CD    3002    LDIA	0x2
  01CE    00CB    LD	0x4B,A
  01CF    01CC    CLR	0x4C
208:              	}
209:              	return temp;
  01D0    084C    LD	A,0x4C
  01D1    00C9    LD	0x49,A
  01D2    084B    LD	A,0x4B
  01D3    00C8    LD	0x48,A
  01D4    0008    RET
210:              }
211:              
212:              uint16_t Convert_Duty_Cycle2(uint8_t Brightness,uint8_t Color_Temp)
213:              {
  0218    00CB    LD	0x4B,A
214:              	uint16_t temp = 0;
215:              	temp = Brightness * (100 - Color_Temp);
  0219    00F3    LD	0x73,A
  021A    3064    LDIA	0x64
  021B    01F4    CLR	0x74
  021C    00CA    LD	0x4A,A
  021D    0848    LD	A,0x48
  021E    024A    SUBA	0x4A
  021F    00F5    LD	0x75,A
  0220    01F6    CLR	0x76
  0221    1C03    SNZB	0x3,0
  0222    03F6    DECR	0x76
  0223    21D5    CALL	0x1D5
  0224    118A    CLRB	0xA,3
216:              	temp /= 100;
  0225    2789    CALL	0x789
  0226    118A    CLRB	0xA,3
  0227    21EE    CALL	0x1EE
  0228    118A    CLRB	0xA,3
  0229    0874    LD	A,0x74
  022A    00CD    LD	0x4D,A
  022B    0873    LD	A,0x73
  022C    00CC    LD	0x4C,A
217:              	temp *= 255;
  022D    30FF    LDIA	0xFF
  022E    00F3    LD	0x73,A
  022F    01F4    CLR	0x74
  0230    084D    LD	A,0x4D
  0231    00F6    LD	0x76,A
  0232    084C    LD	A,0x4C
  0233    00F5    LD	0x75,A
  0234    21D5    CALL	0x1D5
  0235    118A    CLRB	0xA,3
218:              	temp /= 100;
  0236    2789    CALL	0x789
  0237    118A    CLRB	0xA,3
  0238    21EE    CALL	0x1EE
  0239    118A    CLRB	0xA,3
  023A    0874    LD	A,0x74
  023B    00CD    LD	0x4D,A
  023C    0873    LD	A,0x73
  023D    00CC    LD	0x4C,A
219:              	if(temp >= 250) 
  023E    3000    LDIA	0x0
  023F    024D    SUBA	0x4D
  0240    30FA    LDIA	0xFA
  0241    1903    SZB	0x3,2
  0242    024C    SUBA	0x4C
  0243    1C03    SNZB	0x3,0
  0244    2A48    JP	0x248
220:              	{
221:              		temp = 250;
  0245    30FA    LDIA	0xFA
  0246    00CC    LD	0x4C,A
  0247    01CD    CLR	0x4D
222:              	}
223:              	if(temp <= 2) 
  0248    3000    LDIA	0x0
  0249    024D    SUBA	0x4D
  024A    3003    LDIA	0x3
  024B    1903    SZB	0x3,2
  024C    024C    SUBA	0x4C
  024D    1803    SZB	0x3,0
  024E    2A52    JP	0x252
224:              	{
225:              		temp = 2;
  024F    3002    LDIA	0x2
  0250    00CC    LD	0x4C,A
  0251    01CD    CLR	0x4D
226:              	}
227:              	return temp;
  0252    084D    LD	A,0x4D
  0253    00C9    LD	0x49,A
  0254    084C    LD	A,0x4C
  0255    00C8    LD	0x48,A
  0256    0008    RET
228:              }
229:              
230:              void LED_Dimming(uint8_t Brightness,uint8_t Color_Temp)
231:              {	
  0114    1283    CLRB	0x3,5
  0115    00CF    LD	0x4F,A
232:              	LEDR1_Vol = Convert_Duty_Cycle1(Brightness,Color_Temp);
  0116    084E    LD	A,0x4E
  0117    00C8    LD	0x48,A
  0118    084F    LD	A,0x4F
  0119    219B    CALL	0x19B
  011A    118A    CLRB	0xA,3
  011B    0848    LD	A,0x48
  011C    00B3    LD	0x33,A
233:              	LEDR2_Vol = Convert_Duty_Cycle2(Brightness,Color_Temp);
  011D    084E    LD	A,0x4E
  011E    00C8    LD	0x48,A
  011F    084F    LD	A,0x4F
  0120    2218    CALL	0x218
  0121    118A    CLRB	0xA,3
  0122    0848    LD	A,0x48
  0123    00B4    LD	0x34,A
234:              	
235:              	//SetRunEn(0,1,cycle1);
236:              	//SetRunEn(0,1,cycle2);
237:              	BufSetRun(0,LEDR1_Vol,1,3);
  0124    0833    LD	A,0x33
  0125    27A8    CALL	0x7A8
  0126    118A    CLRB	0xA,3
  0127    3000    LDIA	0x0
  0128    2572    CALL	0x572
  0129    118A    CLRB	0xA,3
238:              	BufSetRun(1,LEDR2_Vol,1,3);
  012A    0834    LD	A,0x34
  012B    27A8    CALL	0x7A8
  012C    118A    CLRB	0xA,3
  012D    3001    LDIA	0x1
  012E    2D72    JP	0x572
239:              	//CCP1_set_duty_cycle(cycle1);
240:              	//CCP2_set_duty_cycle(cycle2);
241:              }
242:              
243:              void Remote_Pairing(void)
244:              {
245:              	if(rf_buf[0] == 0x05)
  0B74    1683    SETB	0x3,5
  0B75    0830    LD	A,0x30
  0B76    3A05    XORIA	0x5
  0B77    1D03    SNZB	0x3,2
  0B78    2B85    JP	0x385
246:              	{
247:              		Pairing_Num = Data_Check();
  0B79    118A    CLRB	0xA,3
  0B7A    212F    CALL	0x12F
  0B7B    158A    SETB	0xA,3
  0B7C    00B7    LD	0x37,A
248:              		if(Pairing_Num == 0xFF)
  0B7D    3AFF    XORIA	0xFF
  0B7E    1D03    SNZB	0x3,2
  0B7F    2B83    JP	0x383
249:              		{
250:              			Write_Remote_Addr();
  0B80    2389    CALL	0x389
251:              			Pair_LED();
  0B81    118A    CLRB	0xA,3
  0B82    2050    CALL	0x50
252:              		}
253:              		Pairing_Num = 0xFF;
  0B83    30FF    LDIA	0xFF
  0B84    00B7    LD	0x37,A
254:              	}
255:              	SysRunTime_3S = 1;		
  0B85    1283    CLRB	0x3,5
  0B86    01BC    CLR	0x3C
  0B87    0ABC    INCR	0x3C
  0B88    0008    RET
256:              }
257:              
258:              
259:              
260:              void recive_task(void)
261:              {
  0083    00D5    LD	0x55,A
262:              	uint8_t i = 0;
263:              	uint8_t match_flag = 0;
264:              	uint8_t flag = 0;
265:              	uchar tmp_brightness = 0;
266:              	
267:                 	if(rx_data())					/**<Whether the data was received*/
  0084    158A    SETB	0xA,3
  0085    2249    CALL	0x249
  0086    118A    CLRB	0xA,3
  0087    3A00    XORIA	0x0
  0088    1903    SZB	0x3,2
  0089    2910    JP	0x110
268:                  	{
269:                  	Mark:   				
270:              				if(SysRunTime_3S == 0)
  008A    08BC    TESTZ	0x3C
  008B    1D03    SNZB	0x3,2
  008C    2890    JP	0x90
271:              				{
272:              					Remote_Pairing();
  008D    158A    SETB	0xA,3
  008E    2374    CALL	0x374
  008F    118A    CLRB	0xA,3
273:              				}
274:                              if (rf_buf[COUNT_INDEX] != Count_Save)
  0090    1683    SETB	0x3,5
  0091    0832    LD	A,0x32
  0092    1283    CLRB	0x3,5
  0093    062D    XORA	0x2D
  0094    1903    SZB	0x3,2
  0095    290D    JP	0x10D
275:                              {             
276:              					Count_Save = rf_buf[COUNT_INDEX];
  0096    1683    SETB	0x3,5
  0097    0832    LD	A,0x32
  0098    1283    CLRB	0x3,5
  0099    00AD    LD	0x2D,A
277:              					Pairing_Num = Data_Check();
  009A    212F    CALL	0x12F
  009B    118A    CLRB	0xA,3
  009C    00B7    LD	0x37,A
278:              					if(Pairing_Num == 0xFF)
  009D    3AFF    XORIA	0xFF
  009E    1903    SZB	0x3,2
  009F    2910    JP	0x110
279:              					{
280:              						 return;
281:              					}   
282:              					Time1s_cot = 1000;	   
  00A0    30E8    LDIA	0xE8
  00A1    00A6    LD	0x26,A
  00A2    3003    LDIA	0x3
  00A3    00A7    LD	0x27,A
283:              					if (rf_buf[CMD_INDEX] == CMD_DIM)
  00A4    1683    SETB	0x3,5
  00A5    0838    LD	A,0x38
  00A6    3A12    XORIA	0x12
  00A7    1D03    SNZB	0x3,2
  00A8    28D3    JP	0xD3
284:                                  {
285:                                      
286:                                      if (rf_buf[ADJUST_TYPE_INDEX] == ADJUST_BR_VALUE)                /**<调节亮度*/
  00A9    08B9    TESTZ	0x39
  00AA    1D03    SNZB	0x3,2
  00AB    28B6    JP	0xB6
287:                                      {      
288:              							BriCoTem_Value.Brightness = rf_buf[BRIGHTNESS_INDEX];                     
  00AC    083A    LD	A,0x3A
  00AD    1283    CLRB	0x3,5
  00AE    00A0    LD	0x20,A
289:                                          //tmp_brightness = brightnessConvert(rf_buf[BRIGHTNESS_INDEX]);
290:              							LED_Dimming(rf_buf[BRIGHTNESS_INDEX],BriCoTem_Value.ColorTemp);
  00AF    0821    LD	A,0x21
  00B0    00CE    LD	0x4E,A
  00B1    1683    SETB	0x3,5
  00B2    083A    LD	A,0x3A
  00B3    2114    CALL	0x114
  00B4    118A    CLRB	0xA,3
291:                                          //ledSetGradual(tmp_brightness, COLOUR_TEMPR_KEEP);
292:                                      }
  00B5    290D    JP	0x10D
293:                                      else if (rf_buf[ADJUST_TYPE_INDEX] == ADJUST_TEMPR_VALUE)        /**<调节色温*/
  00B6    0B39    SZDECA	0x39
  00B7    28C3    JP	0xC3
294:                                      {
295:              							BriCoTem_Value.ColorTemp = rf_buf[COLOUR_TEMP_INDEX]; 
  00B8    083B    LD	A,0x3B
  00B9    1283    CLRB	0x3,5
  00BA    00A1    LD	0x21,A
296:              							LED_Dimming(BriCoTem_Value.Brightness,rf_buf[COLOUR_TEMP_INDEX]); 
  00BB    1683    SETB	0x3,5
  00BC    083B    LD	A,0x3B
  00BD    1283    CLRB	0x3,5
  00BE    00CE    LD	0x4E,A
  00BF    0820    LD	A,0x20
  00C0    2114    CALL	0x114
  00C1    118A    CLRB	0xA,3
297:                                          //ledSetGradual(BRIGHTNESS_KEEP, rf_buf[COLOUR_TEMP_INDEX]);
298:                                      }
  00C2    290D    JP	0x10D
299:                                      else if (rf_buf[ADJUST_TYPE_INDEX] == ADJUST_TEMPR_BR_VALUE)     /**<调节亮度和色温*/
  00C3    0839    LD	A,0x39
  00C4    3A02    XORIA	0x2
  00C5    1D03    SNZB	0x3,2
  00C6    290D    JP	0x10D
300:                                      {
301:              							BriCoTem_Value.Brightness = rf_buf[BRIGHTNESS_INDEX];
  00C7    083A    LD	A,0x3A
  00C8    1283    CLRB	0x3,5
  00C9    00A0    LD	0x20,A
302:              							BriCoTem_Value.ColorTemp = rf_buf[COLOUR_TEMP_INDEX];
  00CA    1683    SETB	0x3,5
  00CB    083B    LD	A,0x3B
  00CC    1283    CLRB	0x3,5
  00CD    00A1    LD	0x21,A
303:              							LED_Dimming(BriCoTem_Value.Brightness,BriCoTem_Value.ColorTemp);
  00CE    00CE    LD	0x4E,A
  00CF    0820    LD	A,0x20
  00D0    2114    CALL	0x114
  00D1    118A    CLRB	0xA,3
  00D2    290D    JP	0x10D
304:              							
305:                                          //tmp_brightness = brightnessConvert(rf_buf[BRIGHTNESS_INDEX]);
306:                                          //ledSetGradual(tmp_brightness, rf_buf[COLOUR_TEMP_INDEX]);
307:                                      }               
308:              					} 
309:              					else if (rf_buf[CMD_INDEX] == CMD_SWITCH) 
  00D3    0838    LD	A,0x38
  00D4    3A11    XORIA	0x11
  00D5    1D03    SNZB	0x3,2
  00D6    2906    JP	0x106
310:              					{
311:              						if(rf_buf[ACTION_INDEX] == ACTION_OFF)
  00D7    08B9    TESTZ	0x39
  00D8    1D03    SNZB	0x3,2
  00D9    28DE    JP	0xDE
312:              						{						
313:              							LED_ALLOFF();
  00DA    215D    CALL	0x15D
  00DB    118A    CLRB	0xA,3
314:              							SysDingShiEn=0;
  00DC    01B9    CLR	0x39
315:              						}
  00DD    290D    JP	0x10D
316:              						else if(rf_buf[ACTION_INDEX] == ACTION_ON)
  00DE    0B39    SZDECA	0x39
  00DF    290D    JP	0x10D
317:              						{
318:              						
319:              							if(LED_ON_Sat==0)  
  00E0    1283    CLRB	0x3,5
  00E1    08ED    TESTZ	0x6D
  00E2    1D03    SNZB	0x3,2
  00E3    28FD    JP	0xFD
320:              							{
321:              								LED_ON_Sat=1;
  00E4    01ED    CLR	0x6D
  00E5    0AED    INCR	0x6D
322:              
323:              								PWM_LED1(LEDR1_Vol); 
  00E6    0833    LD	A,0x33
  00E7    2596    CALL	0x596
  00E8    118A    CLRB	0xA,3
324:              								PWM_LED2(LEDR2_Vol); 
  00E9    0834    LD	A,0x34
  00EA    2599    CALL	0x599
  00EB    118A    CLRB	0xA,3
325:              								SetRunEn(0,1,LEDR1_Vol);
  00EC    01F3    CLR	0x73
  00ED    0AF3    INCR	0x73
  00EE    0833    LD	A,0x33
  00EF    00F4    LD	0x74,A
  00F0    3000    LDIA	0x0
  00F1    01F5    CLR	0x75
  00F2    255D    CALL	0x55D
  00F3    118A    CLRB	0xA,3
326:              								SetRunEn(1,1,LEDR2_Vol);
  00F4    01F3    CLR	0x73
  00F5    0AF3    INCR	0x73
  00F6    0834    LD	A,0x34
  00F7    00F4    LD	0x74,A
  00F8    3001    LDIA	0x1
  00F9    01F5    CLR	0x75
  00FA    255D    CALL	0x55D
  00FB    118A    CLRB	0xA,3
327:              							}
  00FC    28DC    JP	0xDC
328:              							else 
329:              							{
330:              								LEDCon_Chg();
  00FD    2170    CALL	0x170
  00FE    118A    CLRB	0xA,3
331:              								if(++LED_Chg_Cnt>=6) LED_Chg_Cnt=0;
  00FF    3006    LDIA	0x6
  0100    0AF8    INCR	0x78
  0101    0278    SUBA	0x78
  0102    1C03    SNZB	0x3,0
  0103    28DC    JP	0xDC
  0104    01F8    CLR	0x78
  0105    28DC    JP	0xDC
332:              							}
333:              							SysDingShiEn=0;
334:              						}
335:              					
336:              					} 
337:              					else if(rf_buf[8] == CMD_CLR_ADDR)	
  0106    0838    LD	A,0x38
  0107    3A13    XORIA	0x13
  0108    1D03    SNZB	0x3,2
  0109    290D    JP	0x10D
338:              					{
339:              						Delete_One_RemoteAddr();
  010A    158A    SETB	0xA,3
  010B    2351    CALL	0x351
  010C    118A    CLRB	0xA,3
340:              					}               
341:                              }
342:                  			RF_ClearFIFO();
  010D    273A    CALL	0x73A
  010E    118A    CLRB	0xA,3
343:                  			RF_ClearStatus();
  010F    2741    CALL	0x741
  0110    3007    LDIA	0x7
  0111    008A    LD	0xA,A
  0112    0855    LD	A,0x55
  0113    0082    LD	0x2,A
344:                  	}
345:              }
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\24lc02.c ----------------------------------------------------------------------
1:                #include 	"24lc02.h"
2:                #include "WDT.h"
3:                
4:                #include "cms.h"
5:                #include "system.h"
6:                #include "cUART.h"
7:                #include "I2C_Base.h"
8:                #include "iic.h"
9:                
10:               
11:               #define EEPROM_ADDs_Base    0x50 
12:               #define EEPROM_BlockLen  	  8  //EEPROM内部块写最大缓存，24LC02为8字节
13:               
14:               
15:               /******************测试方法如下**************************
16:               
17:               for(k=0;k<256;k++) buf[k]=k;
18:               if(EEPROM_SendString_Any(0,256,buf)){lcd_ShowAscii_much("SendString_Fail||",0,40); while(1);}
19:               
20:               for(k=0;k<256;k++) buf[k]=0;
21:               if(EEPROM_ReceString(0,256,buf)) { lcd_ShowAscii_much("ReceString_Fail||",0,60);while(1);}
22:               
23:               for(k=0;k<256;k++)
24:               {
25:               if(buf[k]!=(uchar)(k&0x00ff)) {lcd_ShowAscii_much("CRC_Fail||",0,80);USART1_TxDat(k<<8);  USART1_TxDat(k); while(1);}
26:               }
27:               
28:               **********************************************/
29:               
30:               
31:               //返回0则空闲，1正在写
32:               uchar EEPROM_CheckBusy(void)
33:               {
34:               return(IIC_CheckBusy(EEPROM_ADDs_Base));
  0FF9    3050    LDIA	0x50
  0FFA    2E58    JP	0x658
35:               }
36:               
37:               
38:               uchar EEPROM_SendByte(uchar REGadds,uchar Wdat)   //写器件数据
39:               {
  0E40    00D0    LD	0x50,A
40:               	uchar cnt=0;
  0E41    01D1    CLR	0x51
41:               	
42:               	uchar i=IIC_SendByte(EEPROM_ADDs_Base|(REGadds>>8),REGadds,Wdat);
  0E42    00CC    LD	0x4C,A
  0E43    084F    LD	A,0x4F
  0E44    00CD    LD	0x4D,A
  0E45    3050    LDIA	0x50
  0E46    2681    CALL	0x681
  0E47    158A    SETB	0xA,3
  0E48    1283    CLRB	0x3,5
  0E49    00D2    LD	0x52,A
43:               	if(i) return(i);
  0E4A    0852    LD	A,0x52
  0E4B    1D03    SNZB	0x3,2
  0E4C    0008    RET
  0E4D    27F9    CALL	0x7F9
  0E4E    158A    SETB	0xA,3
  0E4F    3800    ORIA	0x0
  0E50    1903    SZB	0x3,2
  0E51    0008    RET
44:               	
45:               	while(EEPROM_CheckBusy())
46:               	{
47:               		if(cnt++>250){i=0xee; break;}
  0E52    30FC    LDIA	0xFC
  0E53    0AD1    INCR	0x51
  0E54    0251    SUBA	0x51
  0E55    1803    SZB	0x3,0
  0E56    0008    RET
  0E57    2E4D    JP	0x64D
48:               	}//等待空闲
49:               	
50:               	return(i);
51:               }
52:               
53:               uchar EEPROM_ReceByte(uchar REGadds,uchar *Rdat)   //读器件数据
54:               {
  075A    00D1    LD	0x51,A
55:               return(IIC_ReceByte(1,EEPROM_ADDs_Base|(REGadds>>8),REGadds,Rdat));
  075B    3050    LDIA	0x50
  075C    00CC    LD	0x4C,A
  075D    0851    LD	A,0x51
  075E    00CD    LD	0x4D,A
  075F    0850    LD	A,0x50
  0760    00CE    LD	0x4E,A
  0761    3001    LDIA	0x1
  0762    158A    SETB	0xA,3
  0763    2EE2    JP	0x6E2
56:               }
57:               
58:               /*
59:               uchar EEPROM_ReceString(usint Reg_Adds,usint R_LEN,uchar *buf)
60:               {
61:               return(IIC_ReceString(EEPROM_ADDs_Base|(Reg_Adds>>8),Reg_Adds,R_LEN,buf));
62:               }
63:               */
64:               
65:               
66:               
67:               /*
68:               返回0，设备OK
69:               */
70:               uchar EEPROM_Init(uchar SPD_I2C)
71:               {
  0E0C    00F6    LD	0x76,A
72:               
73:               IIC_Init(SPD_I2C); 
  0E0D    2615    CALL	0x615
74:               return(0);
  0E0E    3400    RET	0x0
75:               }
76:               
77:               
78:               
79:               //-----------------------------------------------------------------
80:               
81:               
82:               
83:               #define EEPROOM_Adds_ADDCfg		4
84:               #define EEPROOM_Adds_ONOFFStep	6  //通讯地址保存的起始地址 5个字节
85:               #define EEPROOM_Adds_RFAdd		8  //通讯地址保存的起始地址 5个字节
86:               #define EEPROOM_Adds_RFAdd1	  20	//通讯地址保存的起始地址 4个字节
87:               #define EP_ADDCfgByte		0xE5
88:               
89:               uchar EP_BP=0;
90:               
91:               //返回1：已经配对过了，使用非公地址
92:               uchar EP_IsADDCfg(void)
93:               {
94:               	EEPROM_ReceByte(EEPROOM_Adds_ADDCfg,&EP_BP);
  002C    3044    LDIA	0x44
  002D    00D0    LD	0x50,A
  002E    3004    LDIA	0x4
  002F    275A    CALL	0x75A
  0030    118A    CLRB	0xA,3
95:               	WDT_clear();
  0031    259C    CALL	0x59C
  0032    118A    CLRB	0xA,3
96:               	
97:               	if(EP_BP==EP_ADDCfgByte) return 1; else return 0;
  0033    1283    CLRB	0x3,5
  0034    1303    CLRB	0x3,6
  0035    0844    LD	A,0x44
  0036    3AE5    XORIA	0xE5
  0037    1903    SZB	0x3,2
  0038    3401    RET	0x1
  0039    3400    RET	0x0
98:               }
99:               
100:              
101:              //ID=0：清除已经有的配对标志字节
102:              //ID=1：增加配对标志字节
103:              uchar EP_SetADDCfg(uchar ID)
104:              {
  06F2    00D3    LD	0x53,A
105:              	if(ID) EP_BP=EP_ADDCfgByte; else EP_BP=0;
  06F3    0853    LD	A,0x53
  06F4    1903    SZB	0x3,2
  06F5    2EF9    JP	0x6F9
  06F6    30E5    LDIA	0xE5
  06F7    00C4    LD	0x44,A
  06F8    2EFA    JP	0x6FA
  06F9    01C4    CLR	0x44
106:              
107:              	WDT_clear();
  06FA    259C    CALL	0x59C
108:              	EEPROM_SendByte(EEPROOM_Adds_ADDCfg,EP_BP);	
  06FB    1283    CLRB	0x3,5
  06FC    1303    CLRB	0x3,6
  06FD    0844    LD	A,0x44
  06FE    00CF    LD	0x4F,A
  06FF    3004    LDIA	0x4
  0700    158A    SETB	0xA,3
  0701    2E40    JP	0x640
109:              	return 0;
110:              }
111:              
112:              
113:              
114:              //获取通信地址5字节到OutP
115:              uchar EP_GetONOFFStep(void)
116:              {
117:              	EEPROM_ReceByte(EEPROOM_Adds_ONOFFStep,&EP_BP);
  0022    3044    LDIA	0x44
  0023    00D0    LD	0x50,A
  0024    3006    LDIA	0x6
  0025    275A    CALL	0x75A
  0026    118A    CLRB	0xA,3
118:              	WDT_clear();
  0027    259C    CALL	0x59C
119:              	return EP_BP;
  0028    1283    CLRB	0x3,5
  0029    1303    CLRB	0x3,6
  002A    0844    LD	A,0x44
  002B    0008    RET
120:              }
121:              
122:              void EP_SetONOFFStep(uchar D)
123:              {
  0E0F    00D3    LD	0x53,A
124:              		EEPROM_SendByte(EEPROOM_Adds_ONOFFStep,D);
  0E10    00CF    LD	0x4F,A
  0E11    3006    LDIA	0x6
  0E12    2640    CALL	0x640
125:              		WDT_clear();
  0E13    118A    CLRB	0xA,3
  0E14    2D9C    JP	0x59C
126:              }
127:              
128:              
129:              
130:              //获取通信地址5字节到OutP
131:              void EP_GetRFAdd(uchar * OutP)
132:              {
  0745    00D2    LD	0x52,A
133:              	uchar i=0;
  0746    01D3    CLR	0x53
134:              	for(i=0;i<5;i++)
  0747    01D3    CLR	0x53
135:              	{
136:              		WDT_clear();
  0748    259C    CALL	0x59C
  0749    118A    CLRB	0xA,3
137:              		EEPROM_ReceByte(EEPROOM_Adds_RFAdd+i,&OutP[i]);
  074A    1283    CLRB	0x3,5
  074B    1303    CLRB	0x3,6
  074C    0853    LD	A,0x53
  074D    0752    ADDA	0x52
  074E    00D0    LD	0x50,A
  074F    0853    LD	A,0x53
  0750    3E08    ADDIA	0x8
  0751    275A    CALL	0x75A
  0752    118A    CLRB	0xA,3
  0753    1283    CLRB	0x3,5
  0754    3005    LDIA	0x5
  0755    0AD3    INCR	0x53
  0756    0253    SUBA	0x53
  0757    1C03    SNZB	0x3,0
  0758    2F48    JP	0x748
138:              		
139:              	}
140:              	WDT_clear();
  0759    2D9C    JP	0x59C
141:              }
142:              
143:              
144:              //设置通信地址5字节到OutP
145:              void EP_SetRFAdd(uchar * InP)
146:              {
  0E26    00D4    LD	0x54,A
147:              	uchar i=0;
  0E27    01D5    CLR	0x55
148:              	for(i=0;i<5;i++)
  0E28    01D5    CLR	0x55
149:              	{
150:              		WDT_clear();
  0E29    118A    CLRB	0xA,3
  0E2A    259C    CALL	0x59C
  0E2B    158A    SETB	0xA,3
151:              		EEPROM_SendByte(EEPROOM_Adds_RFAdd+i,InP[i]);
  0E2C    1283    CLRB	0x3,5
  0E2D    1303    CLRB	0x3,6
  0E2E    0855    LD	A,0x55
  0E2F    0754    ADDA	0x54
  0E30    00D3    LD	0x53,A
  0E31    0084    LD	0x4,A
  0E32    1383    CLRB	0x3,7
  0E33    0800    LD	A,0x0
  0E34    00CF    LD	0x4F,A
  0E35    0855    LD	A,0x55
  0E36    3E08    ADDIA	0x8
  0E37    2640    CALL	0x640
  0E38    158A    SETB	0xA,3
  0E39    3005    LDIA	0x5
  0E3A    0AD5    INCR	0x55
  0E3B    0255    SUBA	0x55
  0E3C    1C03    SNZB	0x3,0
  0E3D    2E29    JP	0x629
152:              	}
153:              	WDT_clear();
  0E3E    118A    CLRB	0xA,3
  0E3F    2D9C    JP	0x59C
154:              }
155:              
156:              void AT24C02_Write_Byte1(unsigned char addr ,unsigned char data)
157:              {
  0C14    00C5    LD	0x45,A
158:              	IIC_START1();
  0C15    245A    CALL	0x45A
  0C16    158A    SETB	0xA,3
159:              	I2C_SendByte1(0XA0);	 
  0C17    30A0    LDIA	0xA0
  0C18    2427    CALL	0x427
  0C19    158A    SETB	0xA,3
160:              	IIC_Wait_ACK1(); 
  0C1A    2442    CALL	0x442
  0C1B    158A    SETB	0xA,3
161:              	I2C_SendByte1(addr);
  0C1C    0845    LD	A,0x45
  0C1D    2427    CALL	0x427
  0C1E    158A    SETB	0xA,3
162:              	IIC_Wait_ACK1(); 
  0C1F    2442    CALL	0x442
  0C20    158A    SETB	0xA,3
163:              	I2C_SendByte1(data);
  0C21    0876    LD	A,0x76
  0C22    2427    CALL	0x427
  0C23    158A    SETB	0xA,3
164:              	IIC_Wait_ACK1(); 
  0C24    2442    CALL	0x442
  0C25    158A    SETB	0xA,3
165:              	IIC_STOP1();	
  0C26    2C67    JP	0x467
166:              }
167:              
168:              unsigned char AT24C02_Read_Byte1(unsigned char addr)
169:              {
  0BD5    00C9    LD	0x49,A
170:              	unsigned char temp = 0;		  	    																 
171:                 	IIC_START1();
  0BD6    245A    CALL	0x45A
  0BD7    158A    SETB	0xA,3
172:              
173:              	I2C_SendByte1(0XA0);	   		
  0BD8    30A0    LDIA	0xA0
  0BD9    2427    CALL	0x427
  0BDA    158A    SETB	0xA,3
174:              	IIC_Wait_ACK1();
  0BDB    2442    CALL	0x442
  0BDC    158A    SETB	0xA,3
175:              	I2C_SendByte1(addr);			    	 	   
  0BDD    0849    LD	A,0x49
  0BDE    2427    CALL	0x427
  0BDF    158A    SETB	0xA,3
176:              	IIC_Wait_ACK1(); 
  0BE0    2442    CALL	0x442
  0BE1    158A    SETB	0xA,3
177:                  
178:              	IIC_START1(); 	 	   
  0BE2    245A    CALL	0x45A
  0BE3    158A    SETB	0xA,3
179:              	I2C_SendByte1(0XA1);           				   
  0BE4    30A1    LDIA	0xA1
  0BE5    2427    CALL	0x427
  0BE6    158A    SETB	0xA,3
180:              	IIC_Wait_ACK1();	 
  0BE7    2442    CALL	0x442
  0BE8    158A    SETB	0xA,3
181:              	temp = I2C_ReadByte1(1);		   
  0BE9    3001    LDIA	0x1
  0BEA    246D    CALL	0x46D
  0BEB    158A    SETB	0xA,3
  0BEC    0874    LD	A,0x74
  0BED    00CA    LD	0x4A,A
182:                 	IIC_STOP1();								   
  0BEE    2467    CALL	0x467
183:              	
184:              	return temp;
  0BEF    084A    LD	A,0x4A
  0BF0    0008    RET
185:              }
186:              
187:              
188:              //设置APP通信地址4字节到OutP
189:              void AT24C02_Write_Msg(unsigned char addr ,unsigned char *data,unsigned char len)
190:              {
  0BF1    00CC    LD	0x4C,A
191:              	unsigned char i=0;
  0BF2    01CD    CLR	0x4D
192:              	for(i=0;i<len;i++)
  0BF3    01CD    CLR	0x4D
  0BF4    084A    LD	A,0x4A
  0BF5    024D    SUBA	0x4D
  0BF6    1803    SZB	0x3,0
  0BF7    2C12    JP	0x412
193:              	{
194:              		WDT_clear();
  0BF8    118A    CLRB	0xA,3
  0BF9    259C    CALL	0x59C
  0BFA    158A    SETB	0xA,3
195:              		AT24C02_Write_Byte1(addr,data[i]);
  0BFB    1283    CLRB	0x3,5
  0BFC    1303    CLRB	0x3,6
  0BFD    084D    LD	A,0x4D
  0BFE    0749    ADDA	0x49
  0BFF    00CB    LD	0x4B,A
  0C00    0084    LD	0x4,A
  0C01    1383    CLRB	0x3,7
  0C02    0800    LD	A,0x0
  0C03    00F6    LD	0x76,A
  0C04    084C    LD	A,0x4C
  0C05    2414    CALL	0x414
196:              		addr++;
  0C06    0ACC    INCR	0x4C
197:              		WDT_clear();
  0C07    118A    CLRB	0xA,3
  0C08    259C    CALL	0x59C
  0C09    158A    SETB	0xA,3
198:              		soft_delay_ms(5);
  0C0A    3005    LDIA	0x5
  0C0B    00F3    LD	0x73,A
  0C0C    01F4    CLR	0x74
  0C0D    118A    CLRB	0xA,3
  0C0E    259E    CALL	0x59E
  0C0F    158A    SETB	0xA,3
  0C10    0ACD    INCR	0x4D
  0C11    2BF4    JP	0x3F4
199:              	}
200:              	WDT_clear();
  0C12    118A    CLRB	0xA,3
  0C13    2D9C    JP	0x59C
201:              }
202:              
203:              void AT24C02_Read_Msg(unsigned char addr,unsigned char *data,unsigned char len)
204:              {
  0BB3    00CD    LD	0x4D,A
205:              	unsigned char i=0;
  0BB4    01CE    CLR	0x4E
206:              	for(i=0;i<len;i++)
  0BB5    01CE    CLR	0x4E
  0BB6    084C    LD	A,0x4C
  0BB7    024E    SUBA	0x4E
  0BB8    1803    SZB	0x3,0
  0BB9    2BD3    JP	0x3D3
207:              	{
208:              		WDT_clear();
  0BBA    118A    CLRB	0xA,3
  0BBB    259C    CALL	0x59C
  0BBC    158A    SETB	0xA,3
209:              		data[i] = AT24C02_Read_Byte1(addr);
  0BBD    1283    CLRB	0x3,5
  0BBE    1303    CLRB	0x3,6
  0BBF    084E    LD	A,0x4E
  0BC0    074B    ADDA	0x4B
  0BC1    00F6    LD	0x76,A
  0BC2    0084    LD	0x4,A
  0BC3    084D    LD	A,0x4D
  0BC4    23D5    CALL	0x3D5
  0BC5    1383    CLRB	0x3,7
  0BC6    0080    LD	0x0,A
210:              		addr++;
  0BC7    0ACD    INCR	0x4D
211:              		WDT_clear();
  0BC8    118A    CLRB	0xA,3
  0BC9    259C    CALL	0x59C
  0BCA    158A    SETB	0xA,3
212:              		soft_delay_ms(1);
  0BCB    01F3    CLR	0x73
  0BCC    0AF3    INCR	0x73
  0BCD    01F4    CLR	0x74
  0BCE    118A    CLRB	0xA,3
  0BCF    259E    CALL	0x59E
  0BD0    158A    SETB	0xA,3
  0BD1    0ACE    INCR	0x4E
  0BD2    2BB6    JP	0x3B6
213:              	}
214:              	WDT_clear();
  0BD3    118A    CLRB	0xA,3
  0BD4    2D9C    JP	0x59C
215:              }
216:              
217:              
218:              
219:              
220:              
221:              
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\iic.c ----------------------------------------------------------------------
1:                #include "iic.h"
2:                #include "cms.h"
3:                
4:                
5:                void iic_delay_us(unsigned char delay)
6:                {
  0C53    00F3    LD	0x73,A
7:                	while(delay--);
  0C54    03F3    DECR	0x73
  0C55    0873    LD	A,0x73
  0C56    3AFF    XORIA	0xFF
  0C57    1903    SZB	0x3,2
  0C58    0008    RET
  0C59    2C54    JP	0x454
8:                }
9:                
10:               void IIC_Init1(void)
11:               {
12:               	OPTION_REG &= ~0x80;
  0883    1683    SETB	0x3,5
  0884    1303    CLRB	0x3,6
  0885    1381    CLRB	0x1,7
13:               //	TRISC&=~(3<<1);
14:               	SDA_H;
  0886    1283    CLRB	0x3,5
  0887    1706    SETB	0x6,6
15:               	SCL_H;
  0888    1786    SETB	0x6,7
  0889    0008    RET
16:               }
17:               
18:               
19:               void IIC_START1(void)
20:               {
21:                   SDA_OUT;
  0C5A    1683    SETB	0x3,5
  0C5B    1306    CLRB	0x6,6
22:                   SDA_H;
  0C5C    1283    CLRB	0x3,5
  0C5D    3001    LDIA	0x1
  0C5E    1706    SETB	0x6,6
23:                   SCL_H;
  0C5F    1786    SETB	0x6,7
24:                   iic_delay_us(1);
  0C60    2453    CALL	0x453
  0C61    158A    SETB	0xA,3
  0C62    3001    LDIA	0x1
25:                   SDA_L; //START:when CLK is high,SDA change from hig to low
  0C63    1306    CLRB	0x6,6
26:                   iic_delay_us(1);
  0C64    2453    CALL	0x453
27:                   SCL_L; //Ready Transmit or Receive
  0C65    1386    CLRB	0x6,7
  0C66    0008    RET
28:               }
29:               
30:               
31:               void IIC_STOP1(void)
32:               {
33:                   SDA_OUT;
34:                   SDA_L;
  0C67    24A6    CALL	0x4A6
  0C68    158A    SETB	0xA,3
35:                   SCL_H; 
  0C69    1786    SETB	0x6,7
36:                   iic_delay_us(1);
  0C6A    2453    CALL	0x453
37:                   SDA_H; //STOP:when CLK is low,SDA change from low to high
  0C6B    1706    SETB	0x6,6
  0C6C    0008    RET
38:               }
39:               
40:               
41:               unsigned char IIC_Wait_ACK1(void)
42:               {
43:                   unsigned char RE = 0;
44:               	SDA_OUT;
  0C42    1683    SETB	0x3,5
  0C43    1306    CLRB	0x6,6
45:               	SDA_H;
  0C44    1283    CLRB	0x3,5
  0C45    1706    SETB	0x6,6
46:               	SDA_IN;
  0C46    1683    SETB	0x3,5
  0C47    1706    SETB	0x6,6
  0C48    1715    SETB	0x15,6
47:               	
48:               	SCL_L;  
  0C49    1283    CLRB	0x3,5
  0C4A    3001    LDIA	0x1
  0C4B    1386    CLRB	0x6,7
49:                   iic_delay_us(1);
  0C4C    2453    CALL	0x453
  0C4D    158A    SETB	0xA,3
  0C4E    3001    LDIA	0x1
50:               	SCL_H;
  0C4F    1786    SETB	0x6,7
51:               	iic_delay_us(1);   
  0C50    2453    CALL	0x453
52:                   
53:                  if(IIC_SDA)
  0C51    1386    CLRB	0x6,7
  0C52    0008    RET
54:                  	{
55:                  		RE=1;
56:                  	}
57:                  else
58:                  	{
59:               		RE=0;
60:                  	}
61:                   SCL_L; //时钟输出0
62:                   return RE;
63:               
64:               }
65:               
66:               void IIC_ACK1(void)
67:               {
68:                   SDA_OUT;
69:                   SDA_L;
  0C9C    24A6    CALL	0x4A6
  0C9D    158A    SETB	0xA,3
70:                   iic_delay_us(1);
  0C9E    2453    CALL	0x453
  0C9F    158A    SETB	0xA,3
  0CA0    3001    LDIA	0x1
71:                   SCL_H;
  0CA1    1786    SETB	0x6,7
72:                   iic_delay_us(1);
  0CA2    2453    CALL	0x453
73:                   SCL_L;
  0CA3    1386    CLRB	0x6,7
74:                   SDA_H;
  0CA4    1706    SETB	0x6,6
  0CA5    0008    RET
75:               }
76:               
77:               void IIC_NACK1(void)
78:               {
  0C91    3001    LDIA	0x1
79:               	SDA_H;	/* CPU?y?ˉSDA = 1 */
  0C92    1706    SETB	0x6,6
80:               	iic_delay_us(1);
  0C93    2453    CALL	0x453
  0C94    158A    SETB	0xA,3
  0C95    3001    LDIA	0x1
81:               	SCL_H;	/* CPU2úéú1??ê±?ó */
  0C96    1786    SETB	0x6,7
82:               	iic_delay_us(1);
  0C97    2453    CALL	0x453
  0C98    158A    SETB	0xA,3
  0C99    3001    LDIA	0x1
83:               	SCL_L;
  0C9A    1386    CLRB	0x6,7
84:               	iic_delay_us(1);	
  0C9B    2C53    JP	0x453
85:               }
86:               
87:               
88:               
89:               
90:               void I2C_SendByte1(unsigned char Data)
91:               {
  0C27    00F4    LD	0x74,A
92:                 unsigned char cnt;
93:                 SDA_OUT;
  0C28    1683    SETB	0x3,5
  0C29    1306    CLRB	0x6,6
94:                 for(cnt=0; cnt<8; cnt++)
  0C2A    01F5    CLR	0x75
95:                 {
96:               
97:                
98:                   if(Data & 0x80)
  0C2B    1FF4    SNZB	0x74,7
  0C2C    2C30    JP	0x430
99:                   {
100:                    SDA_H;                         
  0C2D    1283    CLRB	0x3,5
  0C2E    1706    SETB	0x6,6
101:                  }
  0C2F    2C32    JP	0x432
102:                  else
103:                  {
104:                    SDA_L;                         
  0C30    1283    CLRB	0x3,5
  0C31    1306    CLRB	0x6,6
  0C32    3001    LDIA	0x1
105:                  }
106:                  Data <<= 1;
  0C33    1003    CLRB	0x3,0
  0C34    0DF4    RLCR	0x74
107:                  SCL_H;                              
  0C35    1786    SETB	0x6,7
108:                  iic_delay_us(1);
  0C36    2453    CALL	0x453
  0C37    158A    SETB	0xA,3
  0C38    3001    LDIA	0x1
109:                  SCL_L;                              
  0C39    1386    CLRB	0x6,7
110:                  iic_delay_us(1);
  0C3A    2453    CALL	0x453
  0C3B    158A    SETB	0xA,3
  0C3C    3008    LDIA	0x8
  0C3D    0AF5    INCR	0x75
  0C3E    0275    SUBA	0x75
  0C3F    1803    SZB	0x3,0
  0C40    0008    RET
  0C41    2C2B    JP	0x42B
111:              //    if(cnt==7)SDA_H; 
112:                }
113:              }
114:              
115:              
116:              unsigned int I2C_ReadByte1(unsigned char ack)
117:              {
  0C6D    00C5    LD	0x45,A
118:                unsigned char cnt;
119:                unsigned int data;
120:                SDA_IN;	
  0C6E    1683    SETB	0x3,5
  0C6F    1706    SETB	0x6,6
  0C70    1715    SETB	0x15,6
121:              	
122:                for(cnt=0; cnt<8; cnt++)
  0C71    1283    CLRB	0x3,5
  0C72    01C8    CLR	0x48
  0C73    3001    LDIA	0x1
123:                {
124:                  SCL_L;                                
  0C74    1386    CLRB	0x6,7
125:                  iic_delay_us(1);
  0C75    2453    CALL	0x453
  0C76    158A    SETB	0xA,3
126:              		
127:                  SCL_H;                             
  0C77    1786    SETB	0x6,7
128:                  data <<= 1;
  0C78    1003    CLRB	0x3,0
  0C79    0DC6    RLCR	0x46
  0C7A    0DC7    RLCR	0x47
129:                  if(IIC_SDA)
  0C7B    1B06    SZB	0x6,6
130:                  {
131:                    data |= 0x01;                              
  0C7C    1446    SETB	0x46,0
132:                  }
133:                   iic_delay_us(1);
  0C7D    3001    LDIA	0x1
  0C7E    2453    CALL	0x453
  0C7F    158A    SETB	0xA,3
  0C80    3008    LDIA	0x8
  0C81    0AC8    INCR	0x48
  0C82    0248    SUBA	0x48
  0C83    1C03    SNZB	0x3,0
  0C84    2C73    JP	0x473
134:                }
135:                if(ack == 0)
  0C85    08C5    TESTZ	0x45
  0C86    1D03    SNZB	0x3,2
  0C87    2C8B    JP	0x48B
136:                {
137:                   IIC_NACK1();
  0C88    2491    CALL	0x491
  0C89    158A    SETB	0xA,3
138:                }
  0C8A    2C8C    JP	0x48C
139:                else
140:                {
141:                   IIC_ACK1();
  0C8B    249C    CALL	0x49C
142:                }
143:                return data;                                  
  0C8C    0847    LD	A,0x47
  0C8D    00F5    LD	0x75,A
  0C8E    0846    LD	A,0x46
  0C8F    00F4    LD	0x74,A
  0C90    0008    RET
144:              }
145:              
146:              
147:              
148:              
149:              
150:              
151:              
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\Key.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "system.h"
3:                #include "WDT.h"
4:                #include "rf297L.h"
5:                #include "PORTB_interrupt.h"
6:                #include "cUART.h"
7:                #include "24lc02.h"
8:                #include "timer1.h"
9:                #include "Key.h"
10:               #include "Buffer.H"
11:               #include "PWM.h"
12:               #include "userClock.h"
13:               
14:               #define _LEDSetp 50 
15:               #define _LEDSetp_Keep 20  
16:               
17:               #define  _LEDSetp_LR  85 
18:               
19:               static uchar colour_En=0; 
20:               
21:               static uchar Chg_En=0; 
22:               static uchar Chg_Type=0; 
23:               static uchar Chg_Time=0; 
24:               
25:               static uchar S7_En=0;  
26:               static uchar S7_Cnt=0;
27:               
28:               static uchar Chg_R=0;
29:               static uchar Chg_G=0;
30:               static uchar Chg_B=0;
31:               static uchar Stp=0;
32:               
33:               
34:               
35:               
36:               uchar LED_ON_Sat=1; 
37:               uchar LED_Chg_Cnt=0; 
38:               
39:               extern unsigned int Time1s_cot;
40:               extern uchar LEDR1_Vol;
41:               extern uchar LEDR2_Vol;
42:               
43:               extern usint SysRunTimeCnt;
44:               extern uchar SysDingShiEn;
45:               
46:               
47:               
48:               extern void PWM_LED1(uchar PWM);
49:               extern void PWM_LED2(uchar PWM);
50:               
51:               void Pair_LED(void)
52:               {
53:               	uchar k;
54:               	for(uchar i=0;i<4;i++)
  0050    1283    CLRB	0x3,5
  0051    1303    CLRB	0x3,6
  0052    01C9    CLR	0x49
55:               	{
56:               		CCP1_set_duty_cycle(LED_R_Max); CCP2_set_duty_cycle(LED_R_Max);//PWM2_H; PWM3_H; PWM4_H;
  0053    30FA    LDIA	0xFA
  0054    00F3    LD	0x73,A
  0055    01F4    CLR	0x74
  0056    2702    CALL	0x702
  0057    118A    CLRB	0xA,3
  0058    30FA    LDIA	0xFA
  0059    00F3    LD	0x73,A
  005A    01F4    CLR	0x74
  005B    271B    CALL	0x71B
  005C    118A    CLRB	0xA,3
57:               		for(k=0;k<120;k++){ soft_delay_ms(1); WDT_clear();};
  005D    01CA    CLR	0x4A
  005E    01F3    CLR	0x73
  005F    0AF3    INCR	0x73
  0060    01F4    CLR	0x74
  0061    259E    CALL	0x59E
  0062    118A    CLRB	0xA,3
  0063    259C    CALL	0x59C
  0064    118A    CLRB	0xA,3
  0065    27EC    CALL	0x7EC
  0066    118A    CLRB	0xA,3
  0067    1C03    SNZB	0x3,0
  0068    285E    JP	0x5E
58:               		CCP1_set_duty_cycle(0); CCP2_set_duty_cycle(0);//PWM2_L; PWM3_L; PWM4_L;
  0069    01F3    CLR	0x73
  006A    01F4    CLR	0x74
  006B    2702    CALL	0x702
  006C    118A    CLRB	0xA,3
  006D    01F3    CLR	0x73
  006E    01F4    CLR	0x74
  006F    271B    CALL	0x71B
  0070    118A    CLRB	0xA,3
59:               		for(k=0;k<120;k++){ soft_delay_ms(1); WDT_clear();};
  0071    01CA    CLR	0x4A
  0072    01F3    CLR	0x73
  0073    0AF3    INCR	0x73
  0074    01F4    CLR	0x74
  0075    259E    CALL	0x59E
  0076    118A    CLRB	0xA,3
  0077    259C    CALL	0x59C
  0078    118A    CLRB	0xA,3
  0079    27EC    CALL	0x7EC
  007A    118A    CLRB	0xA,3
  007B    1C03    SNZB	0x3,0
  007C    2872    JP	0x72
  007D    3004    LDIA	0x4
  007E    0AC9    INCR	0x49
  007F    0249    SUBA	0x49
  0080    1803    SZB	0x3,0
  0081    0008    RET
  0082    2853    JP	0x53
60:               	}
61:               }
62:               
63:               
64:               void LEDCon_Chg(void)
65:               {
66:               	switch(LED_Chg_Cnt)
  0170    2982    JP	0x182
  0171    30FA    LDIA	0xFA
  0172    00B3    LD	0x33,A
  0173    01B4    CLR	0x34
  0174    298E    JP	0x18E
  0175    30FA    LDIA	0xFA
  0176    297F    JP	0x17F
  0177    30FA    LDIA	0xFA
  0178    297A    JP	0x17A
  0179    3002    LDIA	0x2
  017A    00B3    LD	0x33,A
  017B    2980    JP	0x180
  017C    3002    LDIA	0x2
  017D    2972    JP	0x172
  017E    3002    LDIA	0x2
  017F    01B3    CLR	0x33
  0180    00B4    LD	0x34,A
  0181    298E    JP	0x18E
  0182    0878    LD	A,0x78
  0183    0084    LD	0x4,A
  0184    3006    LDIA	0x6
  0185    0204    SUBA	0x4
  0186    1803    SZB	0x3,0
  0187    298E    JP	0x18E
  0188    3007    LDIA	0x7
  0189    008A    LD	0xA,A
  018A    1003    CLRB	0x3,0
  018B    0D04    RLCA	0x4
  018C    3EF2    ADDIA	0xF2
  018D    0082    LD	0x2,A
67:               	{
68:               		case 0: LEDR1_Vol=LED_R_Max; 	LEDR2_Vol=0; 			break;
69:               		case 1: LEDR1_Vol=0;  			LEDR2_Vol=LED_R_Max; 	break;
70:               		case 2: LEDR1_Vol=LED_R_Max;  	LEDR2_Vol=LED_R_Max; 	break;	
71:               		case 3: LEDR1_Vol=LED_R_Min;  	LEDR2_Vol=LED_R_Min; 	break;
72:               		
73:               		case 4: LEDR1_Vol=LED_R_Min;    LEDR2_Vol=0; 	break;	
74:               		case 5: LEDR1_Vol=0;  			LEDR2_Vol=LED_R_Min; 			break;
75:               		
76:               	}
77:               	PWM_LED1(LEDR1_Vol); PWM_LED2(LEDR2_Vol);
  018E    0833    LD	A,0x33
  018F    2596    CALL	0x596
  0190    118A    CLRB	0xA,3
  0191    0834    LD	A,0x34
  0192    2599    CALL	0x599
  0193    118A    CLRB	0xA,3
78:               	SetRunEn(0,1,LEDR1_Vol);
  0194    277B    CALL	0x77B
  0195    118A    CLRB	0xA,3
  0196    255D    CALL	0x55D
  0197    118A    CLRB	0xA,3
79:               	SetRunEn(1,1,LEDR2_Vol);
  0198    2782    CALL	0x782
  0199    118A    CLRB	0xA,3
  019A    2D5D    JP	0x55D
80:               }
81:               
82:               static uchar CLRRF_AddCnt=0;
83:               static uchar CLRRF_AddTimEn=0;
84:               static usint CLRRF_AddTimeSV=0;
85:               
86:               
87:               
88:               static uchar SysDingShiOne=0;
89:               static uchar SysDingShiCnt=0;
90:               static uchar SysDingShiSTEP=0;
91:               
92:               
93:               void Key_HandRunning(void)
94:               {
95:               	static uchar  Cnt=0;
96:               	static uchar  Cnt2=0;
97:               	
98:               
99:               	/*
100:              	S7_Running();		//静彩模式
101:              	if(Cnt++>25)
102:              	{
103:              		Cnt=0;
104:              		Chg_Running();	//动彩模式
105:              		
106:              	}
107:              	*/
108:              	if(Cnt2++>4)
  0949    3006    LDIA	0x6
  094A    0AAC    INCR	0x2C
  094B    022C    SUBA	0x2C
  094C    1C03    SNZB	0x3,0
  094D    0008    RET
109:              	{
110:              		Cnt2=0;
  094E    01AC    CLR	0x2C
111:              		BufRuning();
  094F    218B    CALL	0x18B
  0950    158A    SETB	0xA,3
112:              		
113:              		
114:              		if(SysDingShiEn)  
  0951    0839    LD	A,0x39
  0952    1903    SZB	0x3,2
  0953    0008    RET
115:              		{
116:              			if(SysDingShiOne==0)
  0954    08BA    TESTZ	0x3A
  0955    1D03    SNZB	0x3,2
  0956    0008    RET
117:              			{
118:              				
119:              				if(SysDingShiEn==2)
  0957    3A02    XORIA	0x2
  0958    1D03    SNZB	0x3,2
  0959    0008    RET
120:              				{
121:              					if(++SysDingShiCnt>16)
  095A    3011    LDIA	0x11
  095B    0AB8    INCR	0x38
  095C    0238    SUBA	0x38
  095D    1C03    SNZB	0x3,0
  095E    0008    RET
122:              					{
123:              						SysDingShiCnt=0;
  095F    01B8    CLR	0x38
124:              						
125:              						switch(SysDingShiSTEP)
  0960    297C    JP	0x17C
  0961    3000    LDIA	0x0
  0962    118A    CLRB	0xA,3
  0963    2596    CALL	0x596
  0964    158A    SETB	0xA,3
  0965    3000    LDIA	0x0
  0966    118A    CLRB	0xA,3
  0967    2599    CALL	0x599
  0968    0ABB    INCR	0x3B
  0969    0008    RET
  096A    0833    LD	A,0x33
  096B    118A    CLRB	0xA,3
  096C    2596    CALL	0x596
  096D    158A    SETB	0xA,3
  096E    0834    LD	A,0x34
  096F    2966    JP	0x166
  0970    2961    JP	0x161
  0971    0833    LD	A,0x33
  0972    118A    CLRB	0xA,3
  0973    2596    CALL	0x596
  0974    158A    SETB	0xA,3
  0975    0834    LD	A,0x34
  0976    118A    CLRB	0xA,3
  0977    2599    CALL	0x599
126:              						{
127:              							case 0:PWM_LED1(0); PWM_LED2(0); SysDingShiSTEP++; break;
128:              							case 1:PWM_LED1(LEDR1_Vol); PWM_LED2(LEDR2_Vol); SysDingShiSTEP++;break;
129:              							case 2:PWM_LED1(0); PWM_LED2(0); SysDingShiSTEP++; break;
130:              							case 3:PWM_LED1(LEDR1_Vol); PWM_LED2(LEDR2_Vol); 
131:              							SysDingShiOne=1;
  0978    01BA    CLR	0x3A
  0979    0ABA    INCR	0x3A
132:              							SysDingShiSTEP=0;
  097A    01BB    CLR	0x3B
133:              							break;
  097B    0008    RET
  097C    083B    LD	A,0x3B
  097D    3A00    XORIA	0x0
  097E    1903    SZB	0x3,2
  097F    2961    JP	0x161
  0980    3A01    XORIA	0x1
  0981    1903    SZB	0x3,2
  0982    296A    JP	0x16A
  0983    3A03    XORIA	0x3
  0984    1903    SZB	0x3,2
  0985    2970    JP	0x170
  0986    3A01    XORIA	0x1
  0987    1903    SZB	0x3,2
  0988    2971    JP	0x171
  0989    298A    JP	0x18A
  098A    0008    RET
134:              							
135:              						}	
136:              					}
137:              				}
138:              			}
139:              		}
140:              		
141:              		
142:              	}
143:              	
144:              	if(CLRRF_AddTimEn)
145:              	{
146:              		CLRRF_AddTimeSV++;
147:              		if(CLRRF_AddTimeSV>0xfff0)  CLRRF_AddTimeSV=0xfff0;
148:              		
149:              	}
150:              	
151:              }
152:              
153:              
154:              const uchar ChgLV_ZX[6]={    250,    100,    50,     16,     7,   2  }; 
155:              const uchar ChgLV_FW[7]={254,   175,      75,     34,    13,     5,  0}; 
156:              
157:              uchar GetChgLV(uchar vol)
158:              {
  05BC    00F4    LD	0x74,A
159:              	uchar i=0;
  05BD    01F5    CLR	0x75
160:              	for(i=0;i<5;i++)
  05BE    01F5    CLR	0x75
161:              	{
162:              		if(vol>ChgLV_FW[1+i]) return i;
  05BF    0875    LD	A,0x75
  05C0    3E51    ADDIA	0x51
  05C1    0084    LD	0x4,A
  05C2    158A    SETB	0xA,3
  05C3    200A    CALL	0xA
  05C4    118A    CLRB	0xA,3
  05C5    00F3    LD	0x73,A
  05C6    0874    LD	A,0x74
  05C7    0273    SUBA	0x73
  05C8    1803    SZB	0x3,0
  05C9    2DCC    JP	0x5CC
  05CA    0875    LD	A,0x75
  05CB    0008    RET
  05CC    3005    LDIA	0x5
  05CD    0AF5    INCR	0x75
  05CE    0275    SUBA	0x75
  05CF    1803    SZB	0x3,0
163:              	}
164:              	
165:              	return 5;
  05D0    3405    RET	0x5
  05D1    2DBF    JP	0x5BF
166:              }
167:              
168:              
169:              
170:              
171:              extern uchar RF_ADDRESS[5];
172:              extern uchar SysRunTime_3S;
173:              extern unsigned char TX_ADDRESS_DEF[5];
174:              
175:              static uint KeyVol=0;
176:              static uint KeyVolSV=0xffff;
177:              
178:              
179:              
180:              
181:              static uchar KEYKeepAddMark_1=0;
182:              static uchar KEYKeepAddMark_2=0;
183:              
184:              static uchar KEYKeepSunMark_1=0;
185:              static uchar KEYKeepSunMark_2=0;
186:              
187:              
188:              
189:              void LED_ALLOFF(void)
190:              {
191:              		LED_ON_Sat=0;
192:              		colour_En=0;
193:              		S7_En=0; 
194:              		Chg_En=0; 
195:              		S7_Cnt=0;
196:              		Chg_Type=0;
  015D    1283    CLRB	0x3,5
  015E    3000    LDIA	0x0
  015F    01ED    CLR	0x6D
  0160    01F3    CLR	0x73
  0161    01F4    CLR	0x74
  0162    01F5    CLR	0x75
  0163    255D    CALL	0x55D
  0164    118A    CLRB	0xA,3
  0165    3001    LDIA	0x1
197:              		SetRunEn(0,0,0);
198:              		SetRunEn(1,0,0);
  0166    01F3    CLR	0x73
  0167    01F4    CLR	0x74
  0168    01F5    CLR	0x75
  0169    255D    CALL	0x55D
  016A    118A    CLRB	0xA,3
199:              			
200:              		PWM_LED1(0);
  016B    3000    LDIA	0x0
  016C    2596    CALL	0x596
  016D    118A    CLRB	0xA,3
201:              		PWM_LED2(0);
  016E    3000    LDIA	0x0
  016F    2D99    JP	0x599
202:              		//PWM_CHSet(_b,0);
203:              		//PWM_CHSet(_r,0);
204:              		//PWM_CHSet(_g,0);
205:              		//PWM_CHSet(_b,0);
206:              }
207:              
208:              
209:              
210:              void Key_Handle(uchar *buf)
211:              {
  0257    00D7    LD	0x57,A
212:              	uchar i=0;
213:              	usint k=0;
  0258    01E2    CLR	0x62
  0259    01E3    CLR	0x63
214:              	uchar n=0;
  025A    01E4    CLR	0x64
215:              	
216:              	if(buf[0]!=0x8C) return;
  025B    0856    LD	A,0x56
  025C    0084    LD	0x4,A
  025D    1383    CLRB	0x3,7
  025E    0800    LD	A,0x0
  025F    3A8C    XORIA	0x8C
  0260    1D03    SNZB	0x3,2
  0261    2D59    JP	0x559
217:              	
218:              	Time1s_cot = 1000;
  0262    30E8    LDIA	0xE8
  0263    00A6    LD	0x26,A
  0264    3003    LDIA	0x3
  0265    00A7    LD	0x27,A
219:              	
220:              	KeyVol=((usint)buf[1]<<8);
  0266    0856    LD	A,0x56
  0267    3E01    ADDIA	0x1
  0268    0084    LD	0x4,A
  0269    0800    LD	A,0x0
  026A    00A5    LD	0x25,A
  026B    01A4    CLR	0x24
221:              	KeyVol+=buf[2];
  026C    0856    LD	A,0x56
  026D    3E02    ADDIA	0x2
  026E    0084    LD	0x4,A
  026F    0800    LD	A,0x0
  0270    07A4    ADDR	0x24
  0271    1803    SZB	0x3,0
  0272    0AA5    INCR	0x25
222:              
223:              	if(KeyVolSV!=KeyVol)
  0273    0825    LD	A,0x25
  0274    0669    XORA	0x69
  0275    1D03    SNZB	0x3,2
  0276    2A79    JP	0x279
  0277    0824    LD	A,0x24
  0278    0668    XORA	0x68
  0279    1903    SZB	0x3,2
  027A    2D4C    JP	0x54C
224:              	{
225:              		KeyVolSV=KeyVol;
  027B    0825    LD	A,0x25
  027C    00E9    LD	0x69,A
  027D    0824    LD	A,0x24
  027E    00E8    LD	0x68,A
226:              		
227:              		if(SysRunTime_3S==0) 
  027F    08BC    TESTZ	0x3C
  0280    1D03    SNZB	0x3,2
  0281    2C89    JP	0x489
228:              		{
229:              
230:              			//对码--------------------------------------------------------
231:              			if((KeyVol==Key_ON)||(KeyVol==Key_ON2)) 
  0282    0324    DECA	0x24
  0283    0425    ORA	0x25
  0284    1903    SZB	0x3,2
  0285    2A8B    JP	0x28B
  0286    0825    LD	A,0x25
  0287    3A40    XORIA	0x40
  0288    0424    ORA	0x24
  0289    1D03    SNZB	0x3,2
  028A    2AD3    JP	0x2D3
232:              			{
233:              				
234:              				 EP_SetRFAdd(&buf[3]);
  028B    0856    LD	A,0x56
  028C    3E03    ADDIA	0x3
  028D    158A    SETB	0xA,3
  028E    2626    CALL	0x626
  028F    118A    CLRB	0xA,3
235:              				 soft_delay_ms(10);
  0290    300A    LDIA	0xA
  0291    00F3    LD	0x73,A
  0292    01F4    CLR	0x74
  0293    259E    CALL	0x59E
  0294    118A    CLRB	0xA,3
236:              				 EP_GetRFAdd(RF_ADDRESS);
  0295    303F    LDIA	0x3F
  0296    2745    CALL	0x745
  0297    118A    CLRB	0xA,3
237:              				 
238:              				 for(i=0;i<5;i++)
  0298    1283    CLRB	0x3,5
  0299    1303    CLRB	0x3,6
  029A    01E5    CLR	0x65
239:              				 {
240:              					 if(RF_ADDRESS[i]!=buf[i+3]) break;
  029B    0865    LD	A,0x65
  029C    0756    ADDA	0x56
  029D    00D8    LD	0x58,A
  029E    3E03    ADDIA	0x3
  029F    0084    LD	0x4,A
  02A0    1383    CLRB	0x3,7
  02A1    0800    LD	A,0x0
  02A2    00D9    LD	0x59,A
  02A3    0865    LD	A,0x65
  02A4    3E3F    ADDIA	0x3F
  02A5    0084    LD	0x4,A
  02A6    0800    LD	A,0x0
  02A7    0659    XORA	0x59
  02A8    1D03    SNZB	0x3,2
  02A9    2AAF    JP	0x2AF
  02AA    3005    LDIA	0x5
  02AB    0AE5    INCR	0x65
  02AC    0265    SUBA	0x65
  02AD    1C03    SNZB	0x3,0
  02AE    2A9B    JP	0x29B
241:              				 }
242:              				if(i==5) 
  02AF    0865    LD	A,0x65
  02B0    3A05    XORIA	0x5
  02B1    1D03    SNZB	0x3,2
  02B2    2D59    JP	0x559
243:              				{
244:              					soft_delay_ms(5);
  02B3    3005    LDIA	0x5
  02B4    00F3    LD	0x73,A
  02B5    01F4    CLR	0x74
  02B6    259E    CALL	0x59E
  02B7    118A    CLRB	0xA,3
245:              					RF_ADDSSet(RF_ADDRESS);  
  02B8    303F    LDIA	0x3F
  02B9    25D2    CALL	0x5D2
  02BA    118A    CLRB	0xA,3
246:              					soft_delay_ms(5);
  02BB    3005    LDIA	0x5
  02BC    00F3    LD	0x73,A
  02BD    01F4    CLR	0x74
  02BE    259E    CALL	0x59E
  02BF    118A    CLRB	0xA,3
247:              					EP_SetADDCfg(1);
  02C0    3001    LDIA	0x1
  02C1    26F2    CALL	0x6F2
  02C2    118A    CLRB	0xA,3
248:              					
249:              					Pair_LED();
  02C3    2050    CALL	0x50
  02C4    118A    CLRB	0xA,3
250:              					
251:              					LED_ALLOFF();
  02C5    215D    CALL	0x15D
  02C6    118A    CLRB	0xA,3
  02C7    30FA    LDIA	0xFA
252:              					LEDR1_Vol=0; LEDR2_Vol=LED_R_Max;
  02C8    01B3    CLR	0x33
  02C9    00B4    LD	0x34,A
253:              					PWM_LED1(LEDR1_Vol); 
  02CA    0833    LD	A,0x33
  02CB    2596    CALL	0x596
  02CC    118A    CLRB	0xA,3
254:              					PWM_LED2(LEDR2_Vol); 
  02CD    0834    LD	A,0x34
  02CE    2599    CALL	0x599
  02CF    118A    CLRB	0xA,3
255:              					SysRunTime_3S=1;  
  02D0    01BC    CLR	0x3C
  02D1    0ABC    INCR	0x3C
  02D2    2D59    JP	0x559
256:              					
257:              					//PWM_Init();
258:              				}
259:              				
260:              				return;
261:              			}
262:              			
263:              			
264:              
265:              			if((KeyVol==Key_OFF)||(KeyVol==Key_OFF2))
  02D3    0824    LD	A,0x24
  02D4    3A10    XORIA	0x10
  02D5    0425    ORA	0x25
  02D6    1903    SZB	0x3,2
  02D7    2ADD    JP	0x2DD
  02D8    0824    LD	A,0x24
  02D9    3A40    XORIA	0x40
  02DA    0425    ORA	0x25
  02DB    1D03    SNZB	0x3,2
  02DC    2C89    JP	0x489
266:              			{
267:              				EP_SetADDCfg(0);
  02DD    3000    LDIA	0x0
  02DE    26F2    CALL	0x6F2
  02DF    118A    CLRB	0xA,3
268:              				soft_delay_ms(5);
  02E0    3005    LDIA	0x5
  02E1    00F3    LD	0x73,A
  02E2    01F4    CLR	0x74
  02E3    259E    CALL	0x59E
  02E4    118A    CLRB	0xA,3
269:              				RF_ADDSSet(TX_ADDRESS_DEF); 
  02E5    30E3    LDIA	0xE3
  02E6    25D2    CALL	0x5D2
  02E7    118A    CLRB	0xA,3
270:              				soft_delay_ms(5);
  02E8    3005    LDIA	0x5
  02E9    00F3    LD	0x73,A
  02EA    01F4    CLR	0x74
  02EB    259E    CALL	0x59E
  02EC    118A    CLRB	0xA,3
  02ED    2AC5    JP	0x2C5
271:              					
272:              				LED_ALLOFF();
273:              				LEDR1_Vol=0; LEDR2_Vol=LED_R_Max;
274:              				PWM_LED1(LEDR1_Vol); 
275:              				PWM_LED2(LEDR2_Vol); 
276:              				SysRunTime_3S=1; 
277:              				return;
278:              			}
279:              		}
280:              
281:              		
282:              		
283:              		switch(KeyVol)
284:              		{
285:              			case Key_Dingshi30: 
286:              			if(LED_ON_Sat)
  02EE    086D    LD	A,0x6D
  02EF    1903    SZB	0x3,2
  02F0    2D59    JP	0x559
  02F1    3050    LDIA	0x50
287:              			{
288:              			SysDingShiEn=1;
  02F2    01B9    CLR	0x39
  02F3    0AB9    INCR	0x39
289:              			SysRunTimeCnt=18000;//10227;
  02F4    00EA    LD	0x6A,A
  02F5    3046    LDIA	0x46
  02F6    00EB    LD	0x6B,A
290:              			
291:              			
292:              			CCP1_set_duty_cycle(0);
  02F7    01F3    CLR	0x73
  02F8    01F4    CLR	0x74
  02F9    2702    CALL	0x702
  02FA    118A    CLRB	0xA,3
293:              			CCP2_set_duty_cycle(0);
  02FB    01F3    CLR	0x73
  02FC    01F4    CLR	0x74
  02FD    271B    CALL	0x71B
  02FE    118A    CLRB	0xA,3
294:              			for(k=0;k<120;k++){ soft_delay_ms(1); WDT_clear();};
  02FF    01E2    CLR	0x62
  0300    01E3    CLR	0x63
  0301    01F3    CLR	0x73
  0302    0AF3    INCR	0x73
  0303    01F4    CLR	0x74
  0304    259E    CALL	0x59E
  0305    118A    CLRB	0xA,3
  0306    259C    CALL	0x59C
  0307    118A    CLRB	0xA,3
  0308    1283    CLRB	0x3,5
  0309    1303    CLRB	0x3,6
  030A    0AE2    INCR	0x62
  030B    1903    SZB	0x3,2
  030C    0AE3    INCR	0x63
  030D    3000    LDIA	0x0
  030E    0263    SUBA	0x63
  030F    3078    LDIA	0x78
  0310    1903    SZB	0x3,2
  0311    0262    SUBA	0x62
  0312    1C03    SNZB	0x3,0
  0313    2B01    JP	0x301
295:              			PWM_LED1(LEDR1_Vol); PWM_LED2(LEDR2_Vol); 
  0314    0833    LD	A,0x33
  0315    2596    CALL	0x596
  0316    118A    CLRB	0xA,3
  0317    0834    LD	A,0x34
  0318    2599    CALL	0x599
  0319    118A    CLRB	0xA,3
  031A    2D59    JP	0x559
296:              			
297:              			}
298:              			
299:              			break;
300:              			
301:              			
302:              			case Key_Dingshi60:
303:              			
304:              			if(LED_ON_Sat)
  031B    086D    LD	A,0x6D
  031C    1903    SZB	0x3,2
  031D    2D59    JP	0x559
305:              			{
306:              			SysDingShiEn=2;
  031E    3002    LDIA	0x2
  031F    00B9    LD	0x39,A
307:              			SysRunTimeCnt=36000;//20454;
  0320    30A0    LDIA	0xA0
  0321    00EA    LD	0x6A,A
  0322    308C    LDIA	0x8C
  0323    00EB    LD	0x6B,A
  0324    3064    LDIA	0x64
308:              			
309:              			SysDingShiOne=0;
  0325    01BA    CLR	0x3A
310:              			SysDingShiCnt=100;
  0326    00B8    LD	0x38,A
311:              			SysDingShiSTEP=0;
  0327    01BB    CLR	0x3B
  0328    2D59    JP	0x559
312:              				
313:              			}
314:              			
315:              			break;
316:              			
317:              
318:              			case Key_U:
319:              			if(LED_ON_Sat)
  0329    086D    LD	A,0x6D
  032A    1903    SZB	0x3,2
  032B    2B94    JP	0x394
320:              			{
321:              				if(LEDR1_Vol!=0)
  032C    0833    LD	A,0x33
  032D    1903    SZB	0x3,2
  032E    2B60    JP	0x360
322:              				{
323:              					KEYKeepAddMark_1=0;
  032F    01AF    CLR	0x2F
324:              					SetRunEn(0,1,LEDR1_Vol);
  0330    277B    CALL	0x77B
  0331    118A    CLRB	0xA,3
  0332    255D    CALL	0x55D
  0333    118A    CLRB	0xA,3
325:              					
326:              			
327:              					
328:              					i=GetChgLV(LEDR1_Vol);
  0334    0833    LD	A,0x33
  0335    25BC    CALL	0x5BC
  0336    118A    CLRB	0xA,3
  0337    00E5    LD	0x65,A
329:              					
330:              					n=1;  if(i==0||i==1) n=4;  if(i==2) n=3;  if(i==3) n=2;
  0338    01E4    CLR	0x64
  0339    0AE4    INCR	0x64
  033A    0865    LD	A,0x65
  033B    1903    SZB	0x3,2
  033C    2B3F    JP	0x33F
  033D    0B65    SZDECA	0x65
  033E    2B41    JP	0x341
  033F    3004    LDIA	0x4
  0340    00E4    LD	0x64,A
  0341    0865    LD	A,0x65
  0342    3A02    XORIA	0x2
  0343    1D03    SNZB	0x3,2
  0344    2B47    JP	0x347
  0345    3003    LDIA	0x3
  0346    00E4    LD	0x64,A
  0347    0865    LD	A,0x65
  0348    3A03    XORIA	0x3
  0349    1D03    SNZB	0x3,2
  034A    2B4D    JP	0x34D
  034B    3002    LDIA	0x2
  034C    00E4    LD	0x64,A
331:              					
332:              					i = (i==0)?(ChgLV_ZX[i]):(ChgLV_ZX[i-1]);
  034D    0865    LD	A,0x65
  034E    1903    SZB	0x3,2
  034F    2B53    JP	0x353
  0350    0865    LD	A,0x65
  0351    3E56    ADDIA	0x56
  0352    2B55    JP	0x355
  0353    0865    LD	A,0x65
  0354    3E57    ADDIA	0x57
  0355    0084    LD	0x4,A
  0356    158A    SETB	0xA,3
  0357    200A    CALL	0xA
  0358    118A    CLRB	0xA,3
  0359    00DA    LD	0x5A,A
  035A    01DB    CLR	0x5B
333:              					BufSetRun(0,i,1,n);
  035B    27B7    CALL	0x7B7
  035C    118A    CLRB	0xA,3
  035D    3000    LDIA	0x0
  035E    2572    CALL	0x572
  035F    118A    CLRB	0xA,3
334:              				}
335:              				
336:              				if(LEDR2_Vol!=0)
  0360    0834    LD	A,0x34
  0361    1903    SZB	0x3,2
  0362    2B94    JP	0x394
337:              				{
338:              					KEYKeepAddMark_2=0;
  0363    01B0    CLR	0x30
339:              					SetRunEn(1,1,LEDR2_Vol);
  0364    27E6    CALL	0x7E6
  0365    118A    CLRB	0xA,3
  0366    255D    CALL	0x55D
  0367    118A    CLRB	0xA,3
340:              					
341:              					i=GetChgLV(LEDR2_Vol);
  0368    0834    LD	A,0x34
  0369    25BC    CALL	0x5BC
  036A    118A    CLRB	0xA,3
  036B    00E5    LD	0x65,A
342:              					n=1;  if(i==0||i==1) n=4;  if(i==2) n=3;  if(i==3) n=2;
  036C    01E4    CLR	0x64
  036D    0AE4    INCR	0x64
  036E    0865    LD	A,0x65
  036F    1903    SZB	0x3,2
  0370    2B73    JP	0x373
  0371    0B65    SZDECA	0x65
  0372    2B75    JP	0x375
  0373    3004    LDIA	0x4
  0374    00E4    LD	0x64,A
  0375    0865    LD	A,0x65
  0376    3A02    XORIA	0x2
  0377    1D03    SNZB	0x3,2
  0378    2B7B    JP	0x37B
  0379    3003    LDIA	0x3
  037A    00E4    LD	0x64,A
  037B    0865    LD	A,0x65
  037C    3A03    XORIA	0x3
  037D    1D03    SNZB	0x3,2
  037E    2B81    JP	0x381
  037F    3002    LDIA	0x2
  0380    00E4    LD	0x64,A
343:              					
344:              					i = (i==0)?(ChgLV_ZX[i]):(ChgLV_ZX[i-1]);
  0381    0865    LD	A,0x65
  0382    1903    SZB	0x3,2
  0383    2B87    JP	0x387
  0384    0865    LD	A,0x65
  0385    3E56    ADDIA	0x56
  0386    2B89    JP	0x389
  0387    0865    LD	A,0x65
  0388    3E57    ADDIA	0x57
  0389    0084    LD	0x4,A
  038A    158A    SETB	0xA,3
  038B    200A    CALL	0xA
  038C    118A    CLRB	0xA,3
  038D    00DC    LD	0x5C,A
  038E    01DD    CLR	0x5D
345:              					BufSetRun(1,i,1,n);
  038F    27B7    CALL	0x7B7
  0390    118A    CLRB	0xA,3
  0391    3001    LDIA	0x1
  0392    2572    CALL	0x572
  0393    118A    CLRB	0xA,3
346:              				}
347:              
348:              			}
349:              			SysDingShiEn=0;
  0394    01B9    CLR	0x39
350:              			break;
  0395    2D59    JP	0x559
351:              			
352:              			case Key_D:
353:              			if(LED_ON_Sat)
  0396    086D    LD	A,0x6D
  0397    1903    SZB	0x3,2
  0398    2B94    JP	0x394
354:              			{
355:              
356:              				if(LEDR1_Vol!=0)
  0399    0833    LD	A,0x33
  039A    1903    SZB	0x3,2
  039B    2BCE    JP	0x3CE
357:              				{
358:              					KEYKeepSunMark_1=0;
  039C    01B1    CLR	0x31
359:              					SetRunEn(0,1,LEDR1_Vol);
  039D    277B    CALL	0x77B
  039E    118A    CLRB	0xA,3
  039F    255D    CALL	0x55D
  03A0    118A    CLRB	0xA,3
360:              					
361:              					i=GetChgLV(LEDR1_Vol);
  03A1    0833    LD	A,0x33
  03A2    25BC    CALL	0x5BC
  03A3    118A    CLRB	0xA,3
  03A4    00E5    LD	0x65,A
362:              					n=1;  if(i==0||i==1) n=4;  if(i==2) n=3;  if(i==3) n=2;
  03A5    01E4    CLR	0x64
  03A6    0AE4    INCR	0x64
  03A7    0865    LD	A,0x65
  03A8    1903    SZB	0x3,2
  03A9    2BAC    JP	0x3AC
  03AA    0B65    SZDECA	0x65
  03AB    2BAE    JP	0x3AE
  03AC    3004    LDIA	0x4
  03AD    00E4    LD	0x64,A
  03AE    0865    LD	A,0x65
  03AF    3A02    XORIA	0x2
  03B0    1D03    SNZB	0x3,2
  03B1    2BB4    JP	0x3B4
  03B2    3003    LDIA	0x3
  03B3    00E4    LD	0x64,A
  03B4    0865    LD	A,0x65
  03B5    3A03    XORIA	0x3
  03B6    1D03    SNZB	0x3,2
  03B7    2BBA    JP	0x3BA
  03B8    3002    LDIA	0x2
  03B9    00E4    LD	0x64,A
363:              					i = (i==5)?(ChgLV_ZX[i]):(ChgLV_ZX[i+1]);
  03BA    0865    LD	A,0x65
  03BB    3A05    XORIA	0x5
  03BC    1903    SZB	0x3,2
  03BD    2BC1    JP	0x3C1
  03BE    0865    LD	A,0x65
  03BF    3E58    ADDIA	0x58
  03C0    2BC3    JP	0x3C3
  03C1    0865    LD	A,0x65
  03C2    3E57    ADDIA	0x57
  03C3    0084    LD	0x4,A
  03C4    158A    SETB	0xA,3
  03C5    200A    CALL	0xA
  03C6    118A    CLRB	0xA,3
  03C7    00DE    LD	0x5E,A
  03C8    01DF    CLR	0x5F
364:              					
365:              					BufSetRun(0,i,1,n);
  03C9    27B7    CALL	0x7B7
  03CA    118A    CLRB	0xA,3
  03CB    3000    LDIA	0x0
  03CC    2572    CALL	0x572
  03CD    118A    CLRB	0xA,3
366:              				}
367:              				
368:              				if(LEDR2_Vol!=0)
  03CE    0834    LD	A,0x34
  03CF    1903    SZB	0x3,2
  03D0    2B94    JP	0x394
369:              				{
370:              					KEYKeepSunMark_2=0;
  03D1    01B2    CLR	0x32
371:              					SetRunEn(1,1,LEDR2_Vol);
  03D2    27E6    CALL	0x7E6
  03D3    118A    CLRB	0xA,3
  03D4    255D    CALL	0x55D
  03D5    118A    CLRB	0xA,3
372:              					i=GetChgLV(LEDR2_Vol);
  03D6    0834    LD	A,0x34
  03D7    25BC    CALL	0x5BC
  03D8    118A    CLRB	0xA,3
  03D9    00E5    LD	0x65,A
373:              					n=1;  if(i==0||i==1) n=4;  if(i==2) n=3;  if(i==3) n=2;
  03DA    01E4    CLR	0x64
  03DB    0AE4    INCR	0x64
  03DC    0865    LD	A,0x65
  03DD    1903    SZB	0x3,2
  03DE    2BE1    JP	0x3E1
  03DF    0B65    SZDECA	0x65
  03E0    2BE3    JP	0x3E3
  03E1    3004    LDIA	0x4
  03E2    00E4    LD	0x64,A
  03E3    0865    LD	A,0x65
  03E4    3A02    XORIA	0x2
  03E5    1D03    SNZB	0x3,2
  03E6    2BE9    JP	0x3E9
  03E7    3003    LDIA	0x3
  03E8    00E4    LD	0x64,A
  03E9    0865    LD	A,0x65
  03EA    3A03    XORIA	0x3
  03EB    1D03    SNZB	0x3,2
  03EC    2BEF    JP	0x3EF
  03ED    3002    LDIA	0x2
  03EE    00E4    LD	0x64,A
374:              					i = (i==5)?(ChgLV_ZX[i]):(ChgLV_ZX[i+1]);
  03EF    0865    LD	A,0x65
  03F0    3A05    XORIA	0x5
  03F1    1903    SZB	0x3,2
  03F2    2BF6    JP	0x3F6
  03F3    0865    LD	A,0x65
  03F4    3E58    ADDIA	0x58
  03F5    2BF8    JP	0x3F8
  03F6    0865    LD	A,0x65
  03F7    3E57    ADDIA	0x57
  03F8    0084    LD	0x4,A
  03F9    158A    SETB	0xA,3
  03FA    200A    CALL	0xA
  03FB    118A    CLRB	0xA,3
  03FC    00E0    LD	0x60,A
  03FD    01E1    CLR	0x61
  03FE    2B8F    JP	0x38F
375:              					BufSetRun(1,i,1,n);
376:              				}
377:              
378:              			}
379:              			SysDingShiEn=0;
380:              			break;
381:              			
382:              		
383:              			case Key_L:
384:              			if(LED_ON_Sat)
  03FF    086D    LD	A,0x6D
  0400    1903    SZB	0x3,2
  0401    2D59    JP	0x559
385:              			{
386:              	
387:              				if((LEDR1_Vol)&&(LEDR2_Vol)) 
  0402    0833    LD	A,0x33
  0403    1903    SZB	0x3,2
  0404    2C1C    JP	0x41C
  0405    0834    LD	A,0x34
  0406    1903    SZB	0x3,2
  0407    2C1C    JP	0x41C
388:              				{
389:              					k=(usint)LEDR1_Vol+(usint)LEDR2_Vol;
  0408    0833    LD	A,0x33
390:              					if(k>(usint)LED_R_Max) k=LED_R_Max;
391:              					
392:              					SetRunEn(0,1,LEDR1_Vol); BufSetRun(0,k,1,3);
  0409    2764    CALL	0x764
  040A    118A    CLRB	0xA,3
  040B    255D    CALL	0x55D
  040C    118A    CLRB	0xA,3
  040D    0862    LD	A,0x62
  040E    27A8    CALL	0x7A8
  040F    118A    CLRB	0xA,3
  0410    3000    LDIA	0x0
  0411    2572    CALL	0x572
  0412    118A    CLRB	0xA,3
393:              					SetRunEn(1,1,LEDR2_Vol); BufSetRun(1,0,1,3);
  0413    2782    CALL	0x782
  0414    118A    CLRB	0xA,3
  0415    255D    CALL	0x55D
  0416    118A    CLRB	0xA,3
  0417    27E0    CALL	0x7E0
  0418    118A    CLRB	0xA,3
  0419    3001    LDIA	0x1
  041A    2572    CALL	0x572
  041B    118A    CLRB	0xA,3
394:              				}
395:              				
396:              				if((LEDR1_Vol==0)&&(LEDR2_Vol))
  041C    08B3    TESTZ	0x33
  041D    1D03    SNZB	0x3,2
  041E    2D59    JP	0x559
  041F    0834    LD	A,0x34
  0420    1903    SZB	0x3,2
  0421    2D59    JP	0x559
397:              				{
398:              					i=LEDR2_Vol/2;
  0422    1003    CLRB	0x3,0
  0423    0C34    RRCA	0x34
  0424    00E5    LD	0x65,A
399:              					
400:              					SetRunEn(0,1,LEDR1_Vol); BufSetRun(0,i,1,3);
  0425    277B    CALL	0x77B
  0426    118A    CLRB	0xA,3
  0427    255D    CALL	0x55D
  0428    118A    CLRB	0xA,3
  0429    27A1    CALL	0x7A1
  042A    118A    CLRB	0xA,3
  042B    3000    LDIA	0x0
  042C    2572    CALL	0x572
  042D    118A    CLRB	0xA,3
401:              					SetRunEn(1,1,LEDR2_Vol); BufSetRun(1,i,1,3);
  042E    2782    CALL	0x782
  042F    118A    CLRB	0xA,3
  0430    255D    CALL	0x55D
  0431    118A    CLRB	0xA,3
  0432    27A1    CALL	0x7A1
  0433    118A    CLRB	0xA,3
  0434    3001    LDIA	0x1
  0435    2572    CALL	0x572
  0436    118A    CLRB	0xA,3
  0437    2D59    JP	0x559
402:              				}
403:              			}
404:              			break;
405:              			
406:              			
407:              			case Key_R:
408:              			if(LED_ON_Sat)
  0438    086D    LD	A,0x6D
  0439    1903    SZB	0x3,2
  043A    2D59    JP	0x559
409:              			{
410:              				if((LEDR1_Vol)&&(LEDR2_Vol)) 
  043B    0833    LD	A,0x33
  043C    1903    SZB	0x3,2
  043D    2C55    JP	0x455
  043E    0834    LD	A,0x34
  043F    1903    SZB	0x3,2
  0440    2C55    JP	0x455
411:              				{
412:              					k=(usint)LEDR1_Vol+(usint)LEDR2_Vol;
  0441    0833    LD	A,0x33
413:              					if(k>(usint)LED_R_Max) k=LED_R_Max;
414:              					
415:              					SetRunEn(0,1,LEDR1_Vol); BufSetRun(0,0,1,3);
  0442    2764    CALL	0x764
  0443    118A    CLRB	0xA,3
  0444    255D    CALL	0x55D
  0445    118A    CLRB	0xA,3
  0446    27E0    CALL	0x7E0
  0447    118A    CLRB	0xA,3
  0448    3000    LDIA	0x0
  0449    2572    CALL	0x572
  044A    118A    CLRB	0xA,3
416:              					SetRunEn(1,1,LEDR2_Vol); BufSetRun(1,k,1,3);
  044B    2782    CALL	0x782
  044C    118A    CLRB	0xA,3
  044D    255D    CALL	0x55D
  044E    118A    CLRB	0xA,3
  044F    0862    LD	A,0x62
  0450    27A8    CALL	0x7A8
  0451    118A    CLRB	0xA,3
  0452    3001    LDIA	0x1
  0453    2572    CALL	0x572
  0454    118A    CLRB	0xA,3
417:              				}
418:              				
419:              				if((LEDR1_Vol)&&(LEDR2_Vol==0))
  0455    0833    LD	A,0x33
  0456    1903    SZB	0x3,2
  0457    2D59    JP	0x559
  0458    08B4    TESTZ	0x34
  0459    1D03    SNZB	0x3,2
  045A    2D59    JP	0x559
420:              				{
421:              
422:              					i=LEDR1_Vol/2;
  045B    1003    CLRB	0x3,0
  045C    0C33    RRCA	0x33
  045D    00E5    LD	0x65,A
423:              					SetRunEn(0,1,LEDR1_Vol); BufSetRun(0,i,1,3);
  045E    277B    CALL	0x77B
  045F    118A    CLRB	0xA,3
  0460    255D    CALL	0x55D
  0461    118A    CLRB	0xA,3
  0462    27A1    CALL	0x7A1
  0463    118A    CLRB	0xA,3
  0464    3000    LDIA	0x0
  0465    2572    CALL	0x572
  0466    118A    CLRB	0xA,3
424:              					SetRunEn(1,1,LEDR2_Vol); BufSetRun(1,i,1,3);
  0467    2782    CALL	0x782
  0468    118A    CLRB	0xA,3
  0469    255D    CALL	0x55D
  046A    118A    CLRB	0xA,3
  046B    27A1    CALL	0x7A1
  046C    118A    CLRB	0xA,3
  046D    3001    LDIA	0x1
  046E    2572    CALL	0x572
  046F    118A    CLRB	0xA,3
  0470    2D59    JP	0x559
425:              					
426:              		
427:              					
428:              				}
429:              			}
430:              			break;
431:              			
432:              			
433:              			
434:              			case Key_ON:
435:              			case Key_ON2:
436:              			
437:              			if(LED_ON_Sat==0)  
  0471    08ED    TESTZ	0x6D
  0472    1D03    SNZB	0x3,2
  0473    2C7D    JP	0x47D
438:              			{
439:              				LED_ON_Sat=1;
  0474    01ED    CLR	0x6D
  0475    0AED    INCR	0x6D
440:              
441:              				PWM_LED1(LEDR1_Vol); PWM_LED2(LEDR2_Vol); 
  0476    0833    LD	A,0x33
  0477    2596    CALL	0x596
  0478    118A    CLRB	0xA,3
  0479    0834    LD	A,0x34
  047A    2599    CALL	0x599
  047B    118A    CLRB	0xA,3
442:              			}
  047C    2B94    JP	0x394
443:              			else 
444:              			{
445:              				LEDCon_Chg();
  047D    2170    CALL	0x170
  047E    118A    CLRB	0xA,3
446:              				if(++LED_Chg_Cnt>=6) LED_Chg_Cnt=0;
  047F    3006    LDIA	0x6
  0480    0AF8    INCR	0x78
  0481    0278    SUBA	0x78
  0482    1C03    SNZB	0x3,0
  0483    2B94    JP	0x394
  0484    01F8    CLR	0x78
  0485    2B94    JP	0x394
447:              			}
448:              			SysDingShiEn=0;
449:              			break;
450:              			
451:              			
452:              			case Key_OFF:
453:              			case Key_OFF2:
454:              		
455:              			LED_ALLOFF();
  0486    215D    CALL	0x15D
  0487    118A    CLRB	0xA,3
  0488    2B94    JP	0x394
  0489    0825    LD	A,0x25
  048A    3A00    XORIA	0x0
  048B    1903    SZB	0x3,2
  048C    2C9A    JP	0x49A
  048D    3A02    XORIA	0x2
  048E    1903    SZB	0x3,2
  048F    2CAE    JP	0x4AE
  0490    3A22    XORIA	0x22
  0491    1903    SZB	0x3,2
  0492    2CB3    JP	0x4B3
  0493    3A60    XORIA	0x60
  0494    1903    SZB	0x3,2
  0495    2CB8    JP	0x4B8
  0496    3AC0    XORIA	0xC0
  0497    1903    SZB	0x3,2
  0498    2CBD    JP	0x4BD
  0499    2D59    JP	0x559
  049A    0824    LD	A,0x24
  049B    3A01    XORIA	0x1
  049C    1903    SZB	0x3,2
  049D    2C71    JP	0x471
  049E    3A03    XORIA	0x3
  049F    1903    SZB	0x3,2
  04A0    2B29    JP	0x329
  04A1    3A12    XORIA	0x12
  04A2    1903    SZB	0x3,2
  04A3    2C86    JP	0x486
  04A4    3A30    XORIA	0x30
  04A5    1903    SZB	0x3,2
  04A6    2B96    JP	0x396
  04A7    3A60    XORIA	0x60
  04A8    1903    SZB	0x3,2
  04A9    2C86    JP	0x486
  04AA    3AC0    XORIA	0xC0
  04AB    1903    SZB	0x3,2
  04AC    2B1B    JP	0x31B
  04AD    2D59    JP	0x559
  04AE    0824    LD	A,0x24
  04AF    3A00    XORIA	0x0
  04B0    1903    SZB	0x3,2
  04B1    2C38    JP	0x438
  04B2    2D59    JP	0x559
  04B3    0824    LD	A,0x24
  04B4    3A00    XORIA	0x0
  04B5    1903    SZB	0x3,2
  04B6    2BFF    JP	0x3FF
  04B7    2D59    JP	0x559
  04B8    0824    LD	A,0x24
  04B9    3A00    XORIA	0x0
  04BA    1903    SZB	0x3,2
  04BB    2C71    JP	0x471
  04BC    2D59    JP	0x559
  04BD    0824    LD	A,0x24
  04BE    3A00    XORIA	0x0
  04BF    1903    SZB	0x3,2
  04C0    2AEE    JP	0x2EE
  04C1    2D59    JP	0x559
456:              			SysDingShiEn=0;
457:              			break;
458:              		}
459:              	}
460:              	else
461:              	{
462:              		switch(KeyVol)
463:              		{
464:              			case Key_U: 
465:              			if(LED_ON_Sat)
  04C2    086D    LD	A,0x6D
  04C3    1903    SZB	0x3,2
  04C4    2D59    JP	0x559
466:              			{
467:              				if(LEDR1_Vol!=0)
  04C5    0833    LD	A,0x33
  04C6    1903    SZB	0x3,2
  04C7    2CE7    JP	0x4E7
468:              				{
469:              					if(KEYKeepAddMark_1==0) i=!GerBuff_RunSAT(0); else i=1;
  04C8    08AF    TESTZ	0x2F
  04C9    1D03    SNZB	0x3,2
  04CA    2CD1    JP	0x4D1
  04CB    3000    LDIA	0x0
  04CC    2590    CALL	0x590
  04CD    118A    CLRB	0xA,3
  04CE    27BE    CALL	0x7BE
  04CF    118A    CLRB	0xA,3
  04D0    2CD3    JP	0x4D3
  04D1    01E5    CLR	0x65
  04D2    0AE5    INCR	0x65
470:              					if(i)
  04D3    0865    LD	A,0x65
  04D4    1903    SZB	0x3,2
  04D5    2CE7    JP	0x4E7
471:              					{
472:              						KEYKeepAddMark_1=1;
  04D6    01AF    CLR	0x2F
  04D7    0AAF    INCR	0x2F
473:              						//SetRunEn(0,1,LEDR1_Vol);
474:              						if((usint)LEDR1_Vol+(usint)_LEDSetp_Keep>=(usint)LED_R_Max) i=LED_R_Max; else  i=LEDR1_Vol+_LEDSetp_Keep;
  04D8    0833    LD	A,0x33
  04D9    27AE    CALL	0x7AE
  04DA    118A    CLRB	0xA,3
  04DB    1903    SZB	0x3,2
  04DC    0258    SUBA	0x58
  04DD    1C03    SNZB	0x3,0
  04DE    2CE1    JP	0x4E1
  04DF    30FA    LDIA	0xFA
  04E0    2CE3    JP	0x4E3
  04E1    0833    LD	A,0x33
  04E2    3E14    ADDIA	0x14
475:              						BufSetRun(0,i,1,1);
  04E3    27CC    CALL	0x7CC
  04E4    118A    CLRB	0xA,3
  04E5    2572    CALL	0x572
  04E6    118A    CLRB	0xA,3
476:              					}
477:              				}
478:              
479:              				if(LEDR2_Vol!=0)
  04E7    0834    LD	A,0x34
  04E8    1903    SZB	0x3,2
  04E9    2D59    JP	0x559
480:              				{
481:              					if(KEYKeepAddMark_2==0) i=!GerBuff_RunSAT(1); else i=1;
  04EA    08B0    TESTZ	0x30
  04EB    1D03    SNZB	0x3,2
  04EC    2CF3    JP	0x4F3
  04ED    3001    LDIA	0x1
  04EE    2590    CALL	0x590
  04EF    118A    CLRB	0xA,3
  04F0    27BE    CALL	0x7BE
  04F1    118A    CLRB	0xA,3
  04F2    2CF5    JP	0x4F5
  04F3    01E5    CLR	0x65
  04F4    0AE5    INCR	0x65
482:              					if(i)
  04F5    0865    LD	A,0x65
  04F6    1903    SZB	0x3,2
  04F7    2D59    JP	0x559
483:              					{
484:              						KEYKeepAddMark_2=1;
  04F8    01B0    CLR	0x30
  04F9    0AB0    INCR	0x30
485:              						//SetRunEn(1,1,LEDR2_Vol);
486:              						if((usint)LEDR2_Vol+(usint)_LEDSetp_Keep>=(usint)LED_R_Max) i=LED_R_Max; else  i=LEDR2_Vol+_LEDSetp_Keep;
  04FA    0834    LD	A,0x34
  04FB    27AE    CALL	0x7AE
  04FC    118A    CLRB	0xA,3
  04FD    1903    SZB	0x3,2
  04FE    0258    SUBA	0x58
  04FF    1C03    SNZB	0x3,0
  0500    2D03    JP	0x503
  0501    30FA    LDIA	0xFA
  0502    2D05    JP	0x505
  0503    0834    LD	A,0x34
  0504    3E14    ADDIA	0x14
487:              						BufSetRun(1,i,1,1);
  0505    27C4    CALL	0x7C4
  0506    118A    CLRB	0xA,3
  0507    2572    CALL	0x572
  0508    118A    CLRB	0xA,3
  0509    2D59    JP	0x559
488:              					}
489:              				}
490:              			}
491:              			break;
492:              			
493:              			
494:              	
495:              			case Key_D: 
496:              			if(LED_ON_Sat)
  050A    086D    LD	A,0x6D
  050B    1903    SZB	0x3,2
  050C    2D59    JP	0x559
497:              			{
498:              
499:              				if(LEDR1_Vol!=0)
  050D    0833    LD	A,0x33
  050E    1903    SZB	0x3,2
  050F    2D2C    JP	0x52C
500:              				{
501:              					if(KEYKeepSunMark_1==0) i=!GerBuff_RunSAT(0); else i=1;
  0510    08B1    TESTZ	0x31
  0511    1D03    SNZB	0x3,2
  0512    2D19    JP	0x519
  0513    3000    LDIA	0x0
  0514    2590    CALL	0x590
  0515    118A    CLRB	0xA,3
  0516    27BE    CALL	0x7BE
  0517    118A    CLRB	0xA,3
  0518    2D1B    JP	0x51B
  0519    01E5    CLR	0x65
  051A    0AE5    INCR	0x65
502:              					if(i)
  051B    0865    LD	A,0x65
  051C    1903    SZB	0x3,2
  051D    2D2C    JP	0x52C
  051E    3016    LDIA	0x16
503:              					{
504:              						KEYKeepSunMark_1=1;
  051F    01B1    CLR	0x31
  0520    0AB1    INCR	0x31
505:              						//SetRunEn(0,1,LEDR1_Vol);
506:              						if((usint)LEDR1_Vol>=((usint)LED_R_Min+(usint)_LEDSetp_Keep)) i=LEDR1_Vol-_LEDSetp_Keep; else  i=LED_R_Min;
  0521    0233    SUBA	0x33
  0522    1C03    SNZB	0x3,0
  0523    2D27    JP	0x527
  0524    0833    LD	A,0x33
  0525    3EEC    ADDIA	0xEC
  0526    2D28    JP	0x528
  0527    3002    LDIA	0x2
507:              						BufSetRun(0,i,1,1);
  0528    27CC    CALL	0x7CC
  0529    118A    CLRB	0xA,3
  052A    2572    CALL	0x572
  052B    118A    CLRB	0xA,3
508:              					}
509:              				}
510:              				
511:              				if(LEDR2_Vol!=0)
  052C    0834    LD	A,0x34
  052D    1903    SZB	0x3,2
  052E    2D59    JP	0x559
512:              				{	
513:              					if(KEYKeepSunMark_2==0) i=!GerBuff_RunSAT(1); else i=1;
  052F    08B2    TESTZ	0x32
  0530    1D03    SNZB	0x3,2
  0531    2D38    JP	0x538
  0532    3001    LDIA	0x1
  0533    2590    CALL	0x590
  0534    118A    CLRB	0xA,3
  0535    27BE    CALL	0x7BE
  0536    118A    CLRB	0xA,3
  0537    2D3A    JP	0x53A
  0538    01E5    CLR	0x65
  0539    0AE5    INCR	0x65
514:              					if(i)
  053A    0865    LD	A,0x65
  053B    1903    SZB	0x3,2
  053C    2D59    JP	0x559
  053D    3016    LDIA	0x16
515:              					{
516:              						KEYKeepSunMark_2=1;
  053E    01B2    CLR	0x32
  053F    0AB2    INCR	0x32
517:              						//SetRunEn(1,1,LEDR2_Vol);
518:              						if((usint)LEDR2_Vol>=(usint)LED_R_Min+(usint)_LEDSetp_Keep)  i=LEDR2_Vol-_LEDSetp_Keep; else  i=LED_R_Min;
  0540    0234    SUBA	0x34
  0541    1C03    SNZB	0x3,0
  0542    2D46    JP	0x546
  0543    0834    LD	A,0x34
  0544    3EEC    ADDIA	0xEC
  0545    2D47    JP	0x547
  0546    3002    LDIA	0x2
519:              						BufSetRun(1,i,1,1);
  0547    27C4    CALL	0x7C4
  0548    118A    CLRB	0xA,3
  0549    2572    CALL	0x572
  054A    118A    CLRB	0xA,3
  054B    2D59    JP	0x559
  054C    0825    LD	A,0x25
  054D    3A00    XORIA	0x0
  054E    1903    SZB	0x3,2
  054F    2D51    JP	0x551
  0550    2D59    JP	0x559
  0551    0824    LD	A,0x24
  0552    3A02    XORIA	0x2
  0553    1903    SZB	0x3,2
  0554    2CC2    JP	0x4C2
  0555    3A22    XORIA	0x22
  0556    1903    SZB	0x3,2
  0557    2D0A    JP	0x50A
  0558    2D59    JP	0x559
  0559    3000    LDIA	0x0
  055A    008A    LD	0xA,A
  055B    0857    LD	A,0x57
  055C    0082    LD	0x2,A
520:              					}
521:              				}
522:              
523:              			}
524:              			break;
525:              			
526:              		}
527:              	}
528:              }
529:              
530:              	
531:              
532:              
533:              
534:              
535:              
536:              
537:               
538:               
539:              
540:              
541:              
542:              	
543:              
544:              
545:              
546:              
547:              void Buffer_VaryFun(uchar n,int dat)
548:              {
  0A22    00F6    LD	0x76,A
549:              	if(n==0)
  0A23    08F6    TESTZ	0x76
  0A24    1D03    SNZB	0x3,2
  0A25    2A2A    JP	0x22A
550:              	{
551:              		LEDR1_Vol=dat;
  0A26    0874    LD	A,0x74
  0A27    00B3    LD	0x33,A
552:              		PWM_LED1(LEDR1_Vol); 
  0A28    118A    CLRB	0xA,3
  0A29    2D96    JP	0x596
553:              	}
554:              	else
555:              	{	
556:              		LEDR2_Vol=dat;
  0A2A    0874    LD	A,0x74
  0A2B    00B4    LD	0x34,A
557:              		PWM_LED2(LEDR2_Vol); 
  0A2C    118A    CLRB	0xA,3
  0A2D    2D99    JP	0x599
558:              	}
559:              }	
560:              
561:              
562:              
563:              
564:              
565:              
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\Buffer.C ----------------------------------------------------------------------
1:                #include   "Buffer.H"
2:                #include "Key.h"
3:                #include "recive.h"
4:                
5:                static struct RunParam RunParam_Reg;
6:                
7:                extern void Buffer_VaryFun(uchar ,int);
8:                
9:                
10:               
11:               uchar BufferRun(uchar BufNo)
12:               {
  09C9    00C5    LD	0x45,A
13:               	/*
14:               AT_Send_ToAscii_BCD(RunParam_Reg.GoalValing [0] ); AT_Send_End();
15:               AT_Send_ToAscii_BCD(RunParam_Reg.GoalVal [0] ); AT_Send_End();
16:               */
17:               
18:               if( RunParam_Reg.GoalValing [BufNo]  >  RunParam_Reg.GoalVal[BufNo] )
  09CA    3EA2    ADDIA	0xA2
  09CB    0084    LD	0x4,A
  09CC    0800    LD	A,0x0
  09CD    00F3    LD	0x73,A
  09CE    0845    LD	A,0x45
  09CF    3EA0    ADDIA	0xA0
  09D0    0084    LD	0x4,A
  09D1    0800    LD	A,0x0
  09D2    00F4    LD	0x74,A
  09D3    0873    LD	A,0x73
  09D4    0274    SUBA	0x74
19:               {
20:               	if( RunParam_Reg.GoalValing [BufNo]-RunParam_Reg.pixel[BufNo]  <=  RunParam_Reg.GoalVal[BufNo])
  09D5    0845    LD	A,0x45
  09D6    1803    SZB	0x3,0
  09D7    2A01    JP	0x201
  09D8    3EA2    ADDIA	0xA2
  09D9    0084    LD	0x4,A
  09DA    0800    LD	A,0x0
  09DB    00F3    LD	0x73,A
  09DC    01F4    CLR	0x74
  09DD    0845    LD	A,0x45
  09DE    3EA8    ADDIA	0xA8
  09DF    0084    LD	0x4,A
  09E0    0874    LD	A,0x74
  09E1    00F6    LD	0x76,A
  09E2    0800    LD	A,0x0
  09E3    0273    SUBA	0x73
  09E4    00F5    LD	0x75,A
  09E5    1C03    SNZB	0x3,0
  09E6    03F6    DECR	0x76
  09E7    0845    LD	A,0x45
  09E8    3EA0    ADDIA	0xA0
  09E9    0084    LD	0x4,A
  09EA    0876    LD	A,0x76
  09EB    3A80    XORIA	0x80
  09EC    3C80    SUBIA	0x80
  09ED    1D03    SNZB	0x3,2
  09EE    29F1    JP	0x1F1
  09EF    0875    LD	A,0x75
  09F0    0200    SUBA	0x0
  09F1    1C03    SNZB	0x3,0
  09F2    29FA    JP	0x1FA
21:               	{RunParam_Reg.GoalValing [BufNo]  =  RunParam_Reg.GoalVal[BufNo];  return 0;}
  09F3    1283    CLRB	0x3,5
  09F4    1303    CLRB	0x3,6
  09F5    0845    LD	A,0x45
  09F6    3EA0    ADDIA	0xA0
  09F7    222E    CALL	0x22E
  09F8    0080    LD	0x0,A
  09F9    3400    RET	0x0
22:               	else
23:               	{RunParam_Reg.GoalValing [BufNo] -= RunParam_Reg.pixel[BufNo];return 1;}
  09FA    1283    CLRB	0x3,5
  09FB    1303    CLRB	0x3,6
  09FC    0845    LD	A,0x45
  09FD    3EA8    ADDIA	0xA8
  09FE    222E    CALL	0x22E
  09FF    0280    SUBR	0x0
  0A00    3401    RET	0x1
24:               
25:               }
26:               else
27:               {
28:               	if(RunParam_Reg.GoalValing [BufNo]+RunParam_Reg.pixel[BufNo]  >=  RunParam_Reg.GoalVal[BufNo])
  0A01    3EA8    ADDIA	0xA8
  0A02    0084    LD	0x4,A
  0A03    0800    LD	A,0x0
  0A04    00F3    LD	0x73,A
  0A05    0845    LD	A,0x45
  0A06    3EA2    ADDIA	0xA2
  0A07    0084    LD	0x4,A
  0A08    0800    LD	A,0x0
  0A09    0773    ADDA	0x73
  0A0A    00F4    LD	0x74,A
  0A0B    01F5    CLR	0x75
  0A0C    0DF5    RLCR	0x75
  0A0D    0845    LD	A,0x45
  0A0E    3EA0    ADDIA	0xA0
  0A0F    0084    LD	0x4,A
  0A10    0875    LD	A,0x75
  0A11    3A80    XORIA	0x80
  0A12    00F6    LD	0x76,A
  0A13    3080    LDIA	0x80
  0A14    0276    SUBA	0x76
  0A15    1D03    SNZB	0x3,2
  0A16    2A19    JP	0x219
  0A17    0800    LD	A,0x0
  0A18    0274    SUBA	0x74
  0A19    1803    SZB	0x3,0
  0A1A    29F3    JP	0x1F3
29:               	{RunParam_Reg.GoalValing [BufNo]  =  RunParam_Reg.GoalVal[BufNo];  return 0;}
30:               	else
31:               	 {RunParam_Reg.GoalValing [BufNo] +=  RunParam_Reg.pixel[BufNo]; return 1;}
  0A1B    1283    CLRB	0x3,5
  0A1C    1303    CLRB	0x3,6
  0A1D    0845    LD	A,0x45
  0A1E    3EA8    ADDIA	0xA8
  0A1F    222E    CALL	0x22E
  0A20    0780    ADDR	0x0
  0A21    3401    RET	0x1
32:               }
33:               }
34:               
35:               
36:               void BufRuning(void)
37:               {
38:               uchar i,k;
39:               
40:               for(i=0;i<Buf_Number;i++)  
  098B    01C9    CLR	0x49
41:               {
42:               	
43:               	if(RunParam_Reg.RunEN[i])  
  098C    0849    LD	A,0x49
  098D    3EAC    ADDIA	0xAC
  098E    0084    LD	0x4,A
  098F    1383    CLRB	0x3,7
  0990    0880    TESTZ	0x0
  0991    1903    SZB	0x3,2
  0992    29C3    JP	0x1C3
44:               	{
45:               		
46:               
47:               		
48:               		if(RunParam_Reg.RunSAT[i])  
  0993    0849    LD	A,0x49
  0994    3EAA    ADDIA	0xAA
  0995    0084    LD	0x4,A
  0996    0880    TESTZ	0x0
  0997    1903    SZB	0x3,2
  0998    29C3    JP	0x1C3
49:               		{
50:               			
51:               			if((++RunParam_Reg.TallyTimeing[i]) >= RunParam_Reg.GapTime[i] )  //更新时间到了？ =GapTime*单元时间（0.01S）
  0999    0849    LD	A,0x49
  099A    3EA4    ADDIA	0xA4
  099B    0084    LD	0x4,A
  099C    0800    LD	A,0x0
  099D    00C6    LD	0x46,A
  099E    0849    LD	A,0x49
  099F    3EA6    ADDIA	0xA6
  09A0    0084    LD	0x4,A
  09A1    0A80    INCR	0x0
  09A2    0800    LD	A,0x0
  09A3    00C7    LD	0x47,A
  09A4    0846    LD	A,0x46
  09A5    0247    SUBA	0x47
  09A6    1C03    SNZB	0x3,0
  09A7    29C3    JP	0x1C3
52:               			{
53:               			RunParam_Reg.TallyTimeing[i]=0;
  09A8    0849    LD	A,0x49
  09A9    3EA6    ADDIA	0xA6
  09AA    0084    LD	0x4,A
  09AB    0180    CLR	0x0
54:               			k=BufferRun(i);            //改变SerRunParam_Reg.SerDegree[i]
  09AC    0849    LD	A,0x49
  09AD    21C9    CALL	0x1C9
  09AE    158A    SETB	0xA,3
  09AF    00C8    LD	0x48,A
55:               			RunParam_Reg.RunFinish[i]=k;
  09B0    0849    LD	A,0x49
  09B1    3EAE    ADDIA	0xAE
  09B2    0084    LD	0x4,A
  09B3    0848    LD	A,0x48
  09B4    0080    LD	0x0,A
56:               			RunParam_Reg.RunSAT[i]=k;  ////运行到位置后关闭使能！也可不用
  09B5    0849    LD	A,0x49
  09B6    3EAA    ADDIA	0xAA
  09B7    0084    LD	0x4,A
  09B8    0848    LD	A,0x48
  09B9    0080    LD	0x0,A
57:               			Buffer_VaryFun(i,RunParam_Reg.GoalValing [i]);  //实际舵机的运转函数！挂钩函数！
  09BA    0849    LD	A,0x49
  09BB    3EA2    ADDIA	0xA2
  09BC    0084    LD	0x4,A
  09BD    0800    LD	A,0x0
  09BE    00F4    LD	0x74,A
  09BF    01F5    CLR	0x75
  09C0    0849    LD	A,0x49
  09C1    2222    CALL	0x222
  09C2    158A    SETB	0xA,3
  09C3    3002    LDIA	0x2
  09C4    0AC9    INCR	0x49
  09C5    0249    SUBA	0x49
  09C6    1803    SZB	0x3,0
  09C7    0008    RET
  09C8    298C    JP	0x18C
58:               			}
59:               		}
60:               	}
61:               }
62:               }
63:               
64:               
65:               
66:               
67:               void BufSetRun(uchar BufNo,uchar Deg ,uchar SPD,uchar PIX)
68:               {
  0572    00F6    LD	0x76,A
69:               	if(BufNo>=Buf_Number) return;
  0573    3002    LDIA	0x2
  0574    0276    SUBA	0x76
  0575    1803    SZB	0x3,0
  0576    0008    RET
70:               	
71:               	if(SPD)
  0577    0874    LD	A,0x74
  0578    1903    SZB	0x3,2
  0579    0008    RET
72:               	{
73:               		RunParam_Reg.GoalVal      [BufNo]=Deg;
  057A    0876    LD	A,0x76
  057B    3EA0    ADDIA	0xA0
  057C    0084    LD	0x4,A
  057D    0873    LD	A,0x73
  057E    1383    CLRB	0x3,7
  057F    0080    LD	0x0,A
74:               		RunParam_Reg.GapTime      [BufNo]=SPD;
  0580    0876    LD	A,0x76
  0581    3EA4    ADDIA	0xA4
  0582    0084    LD	0x4,A
  0583    0874    LD	A,0x74
  0584    0080    LD	0x0,A
75:               		RunParam_Reg.pixel        [BufNo]=PIX;
  0585    0876    LD	A,0x76
  0586    3EA8    ADDIA	0xA8
  0587    0084    LD	0x4,A
  0588    0875    LD	A,0x75
  0589    0080    LD	0x0,A
76:               		RunParam_Reg.RunSAT       [BufNo]=1;//开启舵机控制允许，到点后自动清0
  058A    0876    LD	A,0x76
  058B    3EAA    ADDIA	0xAA
  058C    0084    LD	0x4,A
  058D    0180    CLR	0x0
  058E    0A80    INCR	0x0
  058F    0008    RET
77:               		
78:               		//AT_Send_ToAscii_BCD(66); AT_Send_End();
79:               		//AT_Send_ToAscii_BCD(RunParam_Reg.RunSAT[0]); AT_Send_End();
80:               	}
81:               
82:               }
83:               
84:               
85:               
86:               
87:               
88:               void SetRunEn(uchar BufNo,uchar RunEn,int MID)
89:               {
  055D    00F6    LD	0x76,A
90:               	RunParam_Reg.GoalVal[BufNo]=MID;
  055E    3EA0    ADDIA	0xA0
  055F    0084    LD	0x4,A
  0560    0874    LD	A,0x74
  0561    1383    CLRB	0x3,7
  0562    0080    LD	0x0,A
91:               	RunParam_Reg.GoalValing [BufNo]=MID;
  0563    0876    LD	A,0x76
  0564    3EA2    ADDIA	0xA2
  0565    0084    LD	0x4,A
  0566    0874    LD	A,0x74
  0567    0080    LD	0x0,A
92:               	RunParam_Reg.RunEN [BufNo]=RunEn;
  0568    0876    LD	A,0x76
  0569    3EAC    ADDIA	0xAC
  056A    0084    LD	0x4,A
  056B    0873    LD	A,0x73
  056C    0080    LD	0x0,A
93:               	RunParam_Reg.TallyTimeing [BufNo]=0;
  056D    0876    LD	A,0x76
  056E    3EA6    ADDIA	0xA6
  056F    0084    LD	0x4,A
  0570    0180    CLR	0x0
  0571    0008    RET
94:               }
95:               
96:               
97:               void SetRunONOFF(uchar BufNo,uchar RunEn)
98:               {
99:               	RunParam_Reg.RunEN [BufNo]=RunEn;
100:              	RunParam_Reg.TallyTimeing [BufNo]=0;
101:              }
102:              
103:              
104:              
105:              
106:              uchar GerBuff_RunSAT (uchar BufNo)
107:              {
  0590    00F3    LD	0x73,A
108:              	return RunParam_Reg.RunSAT[BufNo];
  0591    3EAA    ADDIA	0xAA
  0592    0084    LD	0x4,A
  0593    1383    CLRB	0x3,7
  0594    0800    LD	A,0x0
  0595    0008    RET
109:              	
110:              }
111:              
112:              
113:              
114:              
115:              
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\rf297L.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "delay.h"
3:                #include "rf297l.h"
4:                #include "cUART.h"
5:                #include "WDT.h"
6:                
7:                #define delay_ms(ms) soft_delay_ms(ms)
8:                unsigned char TX_ADDRESS_DEF[5] = {0xA5,0x8D,0x1E,0xC9,0x6B};  //复位3秒内的默认地址，之后用EEPROM的
9:                const unsigned char TX2_ADDRESS_DEF[3] = {0xCC,0xCC,0xCC};
10:               const unsigned char RX2_ADDRESS_DEF[3] = {0x2D,0xD7,0XB9};
11:               
12:               static unsigned char ACK_Payload_length;
13:               
14:               unsigned char RF_ReadReg(unsigned char reg_addr);
15:               void RF_WriteReg(unsigned char reg_addr, unsigned char write_data);
16:               void RF_Write_Buff(unsigned char reg_addr,unsigned char *pBuff,unsigned char length);
17:               void RF_Read_Buff(unsigned char reg_addr, unsigned char *pBuff, unsigned char length);
18:               void RF_Set_RxMode(void);
19:               unsigned char RF_GetStatus(void);
20:               void RF_ClearStatus(void);
21:               void RF_ClearFIFO(void);
22:               void RF_SetChannel(unsigned char Channel);
23:               void RF_TxData(unsigned char *payload_buff,unsigned char length);
24:               unsigned char RF_Read_RxData(unsigned char *payload_buff,unsigned char length);
25:               void RF_Init(void);
26:               TX_RESULT_e RF_get_TX_result(void);
27:               
28:               static unsigned char SPI_RW(unsigned char read_reg_addr);
29:               static void SPI_init(void);
30:               
31:               
32:               TX_RESULT_e RF_get_TX_result(void)
33:               {
34:               	unsigned char status = 0;
35:               	status = RF_GetStatus();
36:               	if(status == TX_DS_FLAG){
37:               		return SENT_SUCCESS;
38:               	}else if(status == RX_TX_FLAG){
39:               		return ACK_PAYLOAD_SENT_SUCCESS;
40:               	}else if(MAX_RT_FLAG){
41:               		return SENT_FAILURE;
42:               	}else{
43:               		return UNKNOW_STATUS;
44:               	}
45:               }
46:               
47:               
48:               void RF_ADDSSet(unsigned char *Buf)
49:               {
  05D2    00C8    LD	0x48,A
50:               	RF_WriteReg(W_REGISTER + RF_CH, Buf[4]&0x7f); // 2478M HZ
  05D3    3E04    ADDIA	0x4
  05D4    0084    LD	0x4,A
  05D5    1383    CLRB	0x3,7
  05D6    0800    LD	A,0x0
  05D7    00F5    LD	0x75,A
  05D8    3025    LDIA	0x25
  05D9    13F5    CLRB	0x75,7
  05DA    26B9    CALL	0x6B9
  05DB    118A    CLRB	0xA,3
51:                   RF_Write_Buff(W_REGISTER + TX_ADDR, Buf,   5);	// Writes TX_Address to PN006
  05DC    27D4    CALL	0x7D4
  05DD    118A    CLRB	0xA,3
  05DE    3030    LDIA	0x30
  05DF    26C4    CALL	0x6C4
  05E0    118A    CLRB	0xA,3
52:                   RF_Write_Buff(W_REGISTER + RX_ADDR_P0,Buf, 5);	// RX_Addr0 same as TX_Adr for Auto.Ack  
  05E1    27D4    CALL	0x7D4
  05E2    118A    CLRB	0xA,3
  05E3    302A    LDIA	0x2A
  05E4    2EC4    JP	0x6C4
53:               }
54:               
55:               	
56:               
57:               void RF_Init(void)
58:               {	
59:               #ifdef	IC_TYPE_MX5325          	  //MX5325配置
60:               	#if(DATA_RATE == DR_1M) 
61:               		unsigned char  BB_cal_data[]    = {0x0A,0x6D,0x67,0x9C,0x46}; 
62:               		unsigned char  RF_cal_data[]    = {0xF6,0x37,0x5D};                                      
63:               		unsigned char  RF_cal2_data[]   = {0x45,0x21,0xeF,0x2c,0x5a,0x40};
64:               		unsigned char  Dem_cal_data[]   = {0x01};  
65:               		unsigned char  Dem_cal2_data[]  = {0x0B,0xDF,0x02};   
66:               	#elif(DATA_RATE == DR_250K) 
67:               		unsigned char   BB_cal_data[]    = {0x12,0xec,0x6f,0xa1,0x46}; 
68:               		unsigned char   RF_cal_data[]    = {0xf6,0x37,0x5d};
69:               		unsigned char   RF_cal2_data[]   = {0xd5,0x21,0xeb,0x2c,0x5a,0x40};
70:               		unsigned char   Dem_cal_data[]   = {0x1F};  
71:               		unsigned char   Dem_cal2_data[]   = {0x0B,0xDF,0x02};
72:               	#endif
73:               #else			//PAN2416配置			//对应POWER值不一样
74:               	#if(DATA_RATE == DR_1M) 
75:               		unsigned char  BB_cal_data[]    = {0x0A,0x6D,0x67,0x9C,0x46}; 
  0607    304F    LDIA	0x4F
  0608    0084    LD	0x4,A
  0609    1683    SETB	0x3,5
  060A    1303    CLRB	0x3,6
  060B    0858    LD	A,0x58
  060C    1383    CLRB	0x3,7
  060D    0080    LD	0x0,A
  060E    0A84    INCR	0x4
  060F    0859    LD	A,0x59
  0610    0080    LD	0x0,A
  0611    0A84    INCR	0x4
  0612    085A    LD	A,0x5A
  0613    0080    LD	0x0,A
  0614    0A84    INCR	0x4
  0615    085B    LD	A,0x5B
  0616    0080    LD	0x0,A
  0617    0A84    INCR	0x4
  0618    085C    LD	A,0x5C
  0619    0080    LD	0x0,A
76:               		unsigned char  RF_cal_data[]    = {0x16,0x33,0x27};                      
  061A    085D    LD	A,0x5D
  061B    1283    CLRB	0x3,5
  061C    00D4    LD	0x54,A
  061D    1683    SETB	0x3,5
  061E    085E    LD	A,0x5E
  061F    1283    CLRB	0x3,5
  0620    00D5    LD	0x55,A
  0621    1683    SETB	0x3,5
  0622    085F    LD	A,0x5F
  0623    1283    CLRB	0x3,5
  0624    00D6    LD	0x56,A
77:               		unsigned char  RF_cal2_data[]   = {0x45,0x21,0x3F,0x2D,0x5C,0x40};
  0625    3049    LDIA	0x49
  0626    0084    LD	0x4,A
  0627    1683    SETB	0x3,5
  0628    0852    LD	A,0x52
  0629    0080    LD	0x0,A
  062A    0A84    INCR	0x4
  062B    0853    LD	A,0x53
  062C    0080    LD	0x0,A
  062D    0A84    INCR	0x4
  062E    0854    LD	A,0x54
  062F    0080    LD	0x0,A
  0630    0A84    INCR	0x4
  0631    0855    LD	A,0x55
  0632    0080    LD	0x0,A
  0633    0A84    INCR	0x4
  0634    0856    LD	A,0x56
  0635    0080    LD	0x0,A
  0636    0A84    INCR	0x4
  0637    0857    LD	A,0x57
  0638    0080    LD	0x0,A
78:               		unsigned char  Dem_cal_data[]   = {0x01};  
  0639    1283    CLRB	0x3,5
  063A    086C    LD	A,0x6C
  063B    00DA    LD	0x5A,A
79:               		unsigned char  Dem_cal2_data[]  = {0x0B,0xDF,0x02};   
  063C    1683    SETB	0x3,5
  063D    0860    LD	A,0x60
  063E    1283    CLRB	0x3,5
  063F    00D7    LD	0x57,A
  0640    1683    SETB	0x3,5
  0641    0861    LD	A,0x61
  0642    1283    CLRB	0x3,5
  0643    00D8    LD	0x58,A
  0644    1683    SETB	0x3,5
  0645    0862    LD	A,0x62
  0646    1283    CLRB	0x3,5
  0647    00D9    LD	0x59,A
80:               	#elif(DATA_RATE == DR_250K) 
81:               		unsigned char   BB_cal_data[]    = {0x12,0xEC,0x6f,0xA9,0x46}; 
82:               		unsigned char   RF_cal_data[]    = {0x06,0x33,0x00};
83:               		unsigned char   RF_cal2_data[]   = {0xD5,0x21,0x3B,0x2D,0x5C,0x40};
84:               		unsigned char   Dem_cal_data[]   = {0x03};  
85:               		unsigned char  Dem_cal2_data[]   = {0x0B,0xDF,0x02};
86:               	#endif
87:               #endif
88:                   unsigned char feature = 0x00;
  0648    01DB    CLR	0x5B
89:                   SPI_init();
  0649    2732    CALL	0x732
  064A    118A    CLRB	0xA,3
90:                   RF_WriteReg(RST_FSPI, 0x5A);	//Software Reset    			
  064B    305A    LDIA	0x5A
  064C    00F5    LD	0x75,A
  064D    3053    LDIA	0x53
  064E    26B9    CALL	0x6B9
  064F    118A    CLRB	0xA,3
91:                   RF_WriteReg(RST_FSPI, 0XA5);
  0650    30A5    LDIA	0xA5
  0651    00F5    LD	0x75,A
  0652    3053    LDIA	0x53
  0653    26B9    CALL	0x6B9
  0654    118A    CLRB	0xA,3
  0655    30E1    LDIA	0xE1
92:                   RF_WriteReg(FLUSH_TX, 0);			// CLEAR TXFIFO		    			 
  0656    01F5    CLR	0x75
  0657    26B9    CALL	0x6B9
  0658    118A    CLRB	0xA,3
  0659    30E2    LDIA	0xE2
93:                   RF_WriteReg(FLUSH_RX, 0);			// CLEAR  RXFIFO
  065A    01F5    CLR	0x75
  065B    26B9    CALL	0x6B9
  065C    118A    CLRB	0xA,3
94:                   RF_WriteReg(W_REGISTER + STATUS, 0x70);	// CLEAR  STATUS	
  065D    3070    LDIA	0x70
  065E    00F5    LD	0x75,A
  065F    3027    LDIA	0x27
  0660    26B9    CALL	0x6B9
  0661    118A    CLRB	0xA,3
  0662    3022    LDIA	0x22
95:                   RF_WriteReg(W_REGISTER + EN_RXADDR, 0x01);	// Enable Pipe0
  0663    01F5    CLR	0x75
  0664    0AF5    INCR	0x75
  0665    26B9    CALL	0x6B9
  0666    118A    CLRB	0xA,3
96:                   RF_WriteReg(W_REGISTER + SETUP_AW,  0x03);	// address witdth is 5 bytes
  0667    3003    LDIA	0x3
  0668    00F5    LD	0x75,A
  0669    3023    LDIA	0x23
  066A    26B9    CALL	0x6B9
  066B    118A    CLRB	0xA,3
97:                   
98:                   RF_WriteReg(W_REGISTER + RX_PW_P0, PAYLOAD_WIDTH);// PAYLOAD_WIDTH bytes
  066C    3008    LDIA	0x8
  066D    00F5    LD	0x75,A
  066E    3031    LDIA	0x31
  066F    26B9    CALL	0x6B9
  0670    118A    CLRB	0xA,3
99:               
100:              	RF_ADDSSet(TX_ADDRESS_DEF); //地址设置
  0671    30E3    LDIA	0xE3
  0672    25D2    CALL	0x5D2
  0673    118A    CLRB	0xA,3
101:               
102:                  RF_Write_Buff(W_REGISTER + BB_CAL,    BB_cal_data,  sizeof(BB_cal_data));
  0674    304F    LDIA	0x4F
  0675    00C5    LD	0x45,A
  0676    3005    LDIA	0x5
  0677    01C6    CLR	0x46
  0678    00C7    LD	0x47,A
  0679    303F    LDIA	0x3F
  067A    26C4    CALL	0x6C4
  067B    118A    CLRB	0xA,3
103:                  RF_Write_Buff(W_REGISTER + RF_CAL2,   RF_cal2_data, sizeof(RF_cal2_data));
  067C    3049    LDIA	0x49
  067D    00C5    LD	0x45,A
  067E    3006    LDIA	0x6
  067F    01C6    CLR	0x46
  0680    00C7    LD	0x47,A
  0681    303A    LDIA	0x3A
  0682    26C4    CALL	0x6C4
  0683    118A    CLRB	0xA,3
104:                  RF_Write_Buff(W_REGISTER + DEM_CAL,   Dem_cal_data, sizeof(Dem_cal_data));
  0684    305A    LDIA	0x5A
  0685    00C5    LD	0x45,A
  0686    3039    LDIA	0x39
  0687    01C6    CLR	0x46
  0688    01C7    CLR	0x47
  0689    0AC7    INCR	0x47
  068A    26C4    CALL	0x6C4
  068B    118A    CLRB	0xA,3
105:                  RF_Write_Buff(W_REGISTER + RF_CAL,    RF_cal_data,  sizeof(RF_cal_data));
  068C    3054    LDIA	0x54
  068D    00C5    LD	0x45,A
  068E    3003    LDIA	0x3
  068F    01C6    CLR	0x46
  0690    00C7    LD	0x47,A
  0691    303E    LDIA	0x3E
  0692    26C4    CALL	0x6C4
  0693    118A    CLRB	0xA,3
106:                  RF_Write_Buff(W_REGISTER + DEM_CAL2,  Dem_cal2_data,sizeof(Dem_cal2_data));
  0694    3057    LDIA	0x57
  0695    00C5    LD	0x45,A
  0696    3003    LDIA	0x3
  0697    01C6    CLR	0x46
  0698    00C7    LD	0x47,A
  0699    303B    LDIA	0x3B
  069A    26C4    CALL	0x6C4
  069B    118A    CLRB	0xA,3
  069C    303C    LDIA	0x3C
107:                  RF_WriteReg(W_REGISTER + DYNPD, 0x00);					                            
  069D    01F5    CLR	0x75
  069E    26B9    CALL	0x6B9
  069F    118A    CLRB	0xA,3
108:                  RF_WriteReg(W_REGISTER + RF_SETUP, RF_POWER);						// 		
  06A0    300E    LDIA	0xE
  06A1    00F5    LD	0x75,A
  06A2    3026    LDIA	0x26
  06A3    26B9    CALL	0x6B9
  06A4    118A    CLRB	0xA,3
109:                  RF_WriteReg(ACTIVATE, 0x73);
  06A5    3073    LDIA	0x73
  06A6    00F5    LD	0x75,A
  06A7    3050    LDIA	0x50
  06A8    26B9    CALL	0x6B9
  06A9    118A    CLRB	0xA,3
  06AA    3024    LDIA	0x24
110:                  
111:              	#if(TRANSMIT_TYPE == TRANS_ENHANCE_MODE)      	//双向
112:              		RF_WriteReg(W_REGISTER + SETUP_RETR,0x01);							//  1 retrans... 	
  06AB    01F5    CLR	0x75
  06AC    0AF5    INCR	0x75
  06AD    26B9    CALL	0x6B9
  06AE    118A    CLRB	0xA,3
  06AF    3021    LDIA	0x21
113:              		RF_WriteReg(W_REGISTER + EN_AA,     0x01);							// Enable Auto.Ack:Pipe0  	
  06B0    01F5    CLR	0x75
  06B1    0AF5    INCR	0x75
  06B2    26B9    CALL	0x6B9
  06B3    118A    CLRB	0xA,3
114:              	#elif(TRANSMIT_TYPE == TRANS_BURST_MODE)        //单向                                                      
115:              		RF_WriteReg(W_REGISTER + SETUP_RETR,0x00);							// Disable retrans... 	
116:              		RF_WriteReg(W_REGISTER + EN_AA,     0x00);							// Disable AutoAck 
117:              	#endif
118:              
119:              	#if(EN_DYNPLOAD == 1)		//使能动态PAYLOAD长度
120:              		feature |= 0x04;
121:              		RF_WriteReg(W_REGISTER + DYNPD, 0x01);
122:              	#endif
123:              
124:              	#if(EN_ACK_PAYLOAD == 1)	//使能ACK_PAYLOAD
125:              		feature |= 0x02;
  06B4    14DB    SETB	0x5B,1
126:              	#endif
127:              	if(PAYLOAD_WIDTH >32){
  06B5    085B    LD	A,0x5B
  06B6    00F5    LD	0x75,A
  06B7    303D    LDIA	0x3D
  06B8    2EB9    JP	0x6B9
128:              		feature |= 0x18;
129:              	}
130:              	//feature |= 0x20 ; //ce order by mcu not pin
131:              	RF_WriteReg(W_REGISTER + FEATURE, feature);
132:              }
133:              
134:              void RF_Init3(void)
135:              {	
136:                  RF_WriteReg(W_REGISTER + SETUP_AW,  0x03);	// address witdth is 5 bytes
  003A    3003    LDIA	0x3
  003B    00F5    LD	0x75,A
  003C    3023    LDIA	0x23
  003D    26B9    CALL	0x6B9
  003E    118A    CLRB	0xA,3
137:                  RF_WriteReg(W_REGISTER + RX_PW_P0, 8);// PAYLOAD_WIDTH bytes
  003F    3008    LDIA	0x8
  0040    00F5    LD	0x75,A
  0041    3031    LDIA	0x31
  0042    26B9    CALL	0x6B9
  0043    118A    CLRB	0xA,3
138:              	RF_ADDSSet(TX_ADDRESS_DEF); //地址设置
  0044    30E3    LDIA	0xE3
  0045    25D2    CALL	0x5D2
  0046    118A    CLRB	0xA,3
  0047    3024    LDIA	0x24
139:              	RF_WriteReg(W_REGISTER + SETUP_RETR,0x01);							//  1 retrans... 	
  0048    01F5    CLR	0x75
  0049    0AF5    INCR	0x75
  004A    26B9    CALL	0x6B9
  004B    118A    CLRB	0xA,3
  004C    3021    LDIA	0x21
140:              	RF_WriteReg(W_REGISTER + EN_AA,     0x01);	
  004D    01F5    CLR	0x75
  004E    0AF5    INCR	0x75
  004F    2EB9    JP	0x6B9
141:              }
142:              void RF_Init4(void)
143:              {	
  05E5    3023    LDIA	0x23
144:              	RF_WriteReg(W_REGISTER + SETUP_AW,  0x01);	// address witdth is 5 bytes
  05E6    01F5    CLR	0x75
  05E7    0AF5    INCR	0x75
  05E8    26B9    CALL	0x6B9
  05E9    118A    CLRB	0xA,3
145:                  RF_WriteReg(W_REGISTER + RF_CH, 26); // 2478M HZ
  05EA    301A    LDIA	0x1A
  05EB    00F5    LD	0x75,A
  05EC    3025    LDIA	0x25
  05ED    26B9    CALL	0x6B9
  05EE    118A    CLRB	0xA,3
146:                  RF_WriteReg(W_REGISTER + RX_PW_P0, 18);// PAYLOAD_WIDTH bytes
  05EF    3012    LDIA	0x12
  05F0    00F5    LD	0x75,A
  05F1    3031    LDIA	0x31
  05F2    26B9    CALL	0x6B9
  05F3    118A    CLRB	0xA,3
147:                  RF_Write_Buff(W_REGISTER + TX_ADDR, TX2_ADDRESS_DEF, sizeof(TX2_ADDRESS_DEF));	// Writes TX_Address to PN006
  05F4    3068    LDIA	0x68
  05F5    27DA    CALL	0x7DA
  05F6    118A    CLRB	0xA,3
  05F7    3030    LDIA	0x30
  05F8    26C4    CALL	0x6C4
  05F9    118A    CLRB	0xA,3
148:                  RF_Write_Buff(W_REGISTER + RX_ADDR_P0,RX2_ADDRESS_DEF, sizeof(RX2_ADDRESS_DEF));	// RX_Addr0 same as TX_Adr for Auto.Ack   
  05FA    3065    LDIA	0x65
  05FB    27DA    CALL	0x7DA
  05FC    118A    CLRB	0xA,3
  05FD    302A    LDIA	0x2A
  05FE    26C4    CALL	0x6C4
  05FF    118A    CLRB	0xA,3
  0600    3024    LDIA	0x24
149:              	RF_WriteReg(W_REGISTER + SETUP_RETR,0x00);							// Disable retrans... 	
  0601    01F5    CLR	0x75
  0602    26B9    CALL	0x6B9
  0603    118A    CLRB	0xA,3
  0604    3021    LDIA	0x21
150:              	RF_WriteReg(W_REGISTER + EN_AA,     0x00);
  0605    01F5    CLR	0x75
  0606    2EB9    JP	0x6B9
151:              }
152:              
153:              /******************************************************************************/
154:              //            RF_RxData普通模式下
155:              //            读出接收到的数据：
156:              //            参数：
157:              //              1. payload_buff：存储读取到的数据的Buffer
158:              //              2. length:    读取的数据长度
159:              //              Return:
160:              //              1. 0: 没有接收到数据
161:              //              2. 1: 读取接收到的数据成功
162:              //              note: Only use in Rx Mode
163:              //              length 通常等于 PAYLOAD_WIDTH
164:              /******************************************************************************/
165:              unsigned char RF_RxData(unsigned char *payload_buff,unsigned char length)
166:              { 
  0B18    00CA    LD	0x4A,A
167:                  if(!(RF_GetStatus() & RX_DR_FLAG))
  0B19    2342    CALL	0x342
  0B1A    158A    SETB	0xA,3
  0B1B    00C9    LD	0x49,A
  0B1C    1F49    SNZB	0x49,6
168:                  {
169:                    return 0;                                                                 		
  0B1D    3400    RET	0x0
170:                  }
171:              	RF_Read_Buff(R_RX_PAYLOAD, payload_buff, length);
  0B1E    084A    LD	A,0x4A
  0B1F    00F5    LD	0x75,A
  0B20    0848    LD	A,0x48
  0B21    00F6    LD	0x76,A
  0B22    3061    LDIA	0x61
  0B23    232A    CALL	0x32A
172:              	
173:              	RF_ClearFIFO();
  0B24    118A    CLRB	0xA,3
  0B25    273A    CALL	0x73A
  0B26    158A    SETB	0xA,3
174:              	RF_ClearStatus();
  0B27    118A    CLRB	0xA,3
  0B28    2741    CALL	0x741
175:                  return 1;
  0B29    3401    RET	0x1
176:              }
177:              
178:              /******************************************************************************/
179:              //            RF_ENHANCE_RxData增强模式下
180:              //            读出接收到的数据：
181:              //            参数：
182:              //              1. payload_buff：存储读取到的数据的Buffer
183:              //              2. length:    读取的数据长度
184:              //              3. postback_buff :发送回传数据给发送端
185:              //              Return:
186:              //              1. 0: 没有接收到数据
187:              //              2. 1: 读取接收到的数据成功
188:              //              note: Only use in Rx Mode
189:              //              length 通常等于 PAYLOAD_WIDTH
190:              /******************************************************************************/
191:              unsigned char RF_ENHANCE_RxData(unsigned char *payload_buff,unsigned char length,unsigned char *postback_buff)
192:              { 
  0A37    00CB    LD	0x4B,A
193:              
194:                  if(!(RF_GetStatus() & RX_DR_FLAG))
  0A38    2342    CALL	0x342
  0A39    158A    SETB	0xA,3
  0A3A    00CA    LD	0x4A,A
  0A3B    1F4A    SNZB	0x4A,6
195:                  {
196:                    return 0;                                                                 		
  0A3C    3400    RET	0x0
197:                  }
198:              	RF_Read_Buff(R_RX_PAYLOAD, payload_buff, length);
  0A3D    084B    LD	A,0x4B
  0A3E    00F5    LD	0x75,A
  0A3F    0848    LD	A,0x48
  0A40    00F6    LD	0x76,A
  0A41    3061    LDIA	0x61
  0A42    232A    CALL	0x32A
199:              	RF_ClearFIFO();
  0A43    118A    CLRB	0xA,3
  0A44    273A    CALL	0x73A
  0A45    158A    SETB	0xA,3
200:              	RF_ClearStatus();
  0A46    118A    CLRB	0xA,3
  0A47    2741    CALL	0x741
201:              
202:                  return 1;
  0A48    3401    RET	0x1
203:              }
204:              /******************************************************************************/
205:              //           普通模式下 发送数据：
206:              //            参数：
207:              //              1. payload_buff：需要发送的数据首地址
208:              //              2. length:  需要发送的数据长度
209:              //              Return:
210:              //              1. MAX_RT: TX Failure  (Enhance mode)
211:              //              2. TX_DS:  TX Successful (Enhance mode)
212:              //              note: Only use in Tx Mode
213:              //              length 通常等于 PAYLOAD_WIDTH
214:              //            发送结果
215:              //            参数：只在增强模式下，使能ack带Payload有效
216:              //                  1、ucAckPayload: AckPayload的首地址
217:              //                  2、length：AckPayload的长度
218:              /******************************************************************************/
219:              void RF_TxData(unsigned char *payload_buff,unsigned char length)
220:              {
221:              	unsigned char ret;
222:              	
223:                  RF_Write_Buff(W_TX_PAYLOAD, payload_buff, length);  //write data to txfifo   //rf entery tx mode start send data //rf entery stb3
224:                  delay_ms(2);
225:              
226:              	RF_ClearFIFO();
227:              	RF_ClearStatus();
228:              
229:              }
230:              
231:              /******************************************************************************/
232:              //            增强模式下发送数据：
233:              //            参数：
234:              //              1. payload_buff：需要发送的数据首地址
235:              //              2. length:  需要发送的数据长度
236:              //              3. postback_buff：接收由接收端回传的数据
237:              //              Return:
238:              //              1. MAX_RT: TX Failure  (Enhance mode)
239:              //              2. TX_DS:  TX Successful (Enhance mode)
240:              //              note: Only use in Tx Mode
241:              //              length 通常等于 PAYLOAD_WIDTH
242:              //            发送结果
243:              //            参数：只在增强模式下，使能ack带Payload有效
244:              //                  1、ucAckPayload: AckPayload的首地址
245:              //                  2、length：AckPayload的长度
246:              /******************************************************************************/
247:              
248:              
249:              unsigned char RF_ENHANCE_TxData(unsigned char *payload_buff,unsigned char length,unsigned char *postback_buff)
250:              {
251:              	unsigned char ret;
252:                  RF_Write_Buff(W_TX_PAYLOAD, payload_buff, length);  //write data to txfifo //rf entery tx mode start send data//rf entery stb3
253:                  delay_ms(2);
254:              	
255:              	#if	(TRANSMIT_TYPE == TRANS_ENHANCE_MODE)			//ACK_PAYLOAD模式
256:              	ret = RF_GetStatus();
257:              	/*
258:              	if(ret == RX_TX_FLAG)
259:              	{
260:              		RF_Read_Buff(R_RX_PAYLOAD,postback_buff,ACK_PAYLOAD_WIDTH);//payload_buff把接收到数据再发送过去 feedback_buff 
261:              	}
262:              	*/
263:              	#endif       //将接收到的数据读出到ucPayload，且清除rxfifo
264:              	
265:              	RF_ClearFIFO();
266:              	RF_ClearStatus();
267:              	
268:              	return ((ret&TX_DS_FLAG)==TX_DS_FLAG)?(1):(0);
269:              }
270:              
271:              
272:              void RF_SetChannel(unsigned char Channel)
273:              {    
274:                  RF_WriteReg(W_REGISTER + RF_CH, Channel);
275:              }
276:              
277:              void RF_ClearFIFO(void)
278:              {
  073A    30E1    LDIA	0xE1
279:                  RF_WriteReg(FLUSH_TX, 0);			                                		//清除RF 的 TX FIFO		
  073B    01F5    CLR	0x75
  073C    26B9    CALL	0x6B9
  073D    118A    CLRB	0xA,3
  073E    30E2    LDIA	0xE2
280:                  RF_WriteReg(FLUSH_RX, 0);                                                   		//清除RF 的 RX FIFO	
  073F    01F5    CLR	0x75
  0740    2EB9    JP	0x6B9
281:              }
282:              
283:              void RF_ClearStatus(void)
284:              {
285:                  RF_WriteReg(W_REGISTER + STATUS,0x70);							//清除RF的IRQ标志 
  0741    3070    LDIA	0x70
  0742    00F5    LD	0x75,A
  0743    3027    LDIA	0x27
  0744    2EB9    JP	0x6B9
286:              }
287:              
288:              unsigned char RF_GetStatus(void)
289:              {
290:                  return RF_ReadReg(STATUS)&0x70;		//读取RF的状态 
  0B42    3007    LDIA	0x7
  0B43    2346    CALL	0x346
  0B44    3970    ANDIA	0x70
  0B45    0008    RET
291:              }
292:              
293:              
294:              void RF_Set_RxMode(void)
295:              {
296:              	unsigned char k;
297:                  RF_WriteReg(W_REGISTER + CONFIG,  0X8F);							// 将RF设置成TX模式
  0013    308F    LDIA	0x8F
  0014    00F5    LD	0x75,A
  0015    3020    LDIA	0x20
  0016    26B9    CALL	0x6B9
298:              	//for(k=0;k<1;k++){ soft_delay_ms(1); WDT_clear();};   
299:                  CE_HIGH;	
  0017    1785    SETB	0x5,7
  0018    0008    RET
300:                  //for(k=0;k<1;k++){ soft_delay_ms(1); WDT_clear();};
301:              }
302:              void RF_Set_RxMode1(void)
303:              {
304:              	unsigned char k;
305:              	
306:                  RF_WriteReg(W_REGISTER + CONFIG,  0X87);							// 将RF设置成TX模式
  000D    3087    LDIA	0x87
  000E    00F5    LD	0x75,A
  000F    3020    LDIA	0x20
  0010    26B9    CALL	0x6B9
307:                  //for(k=0;k<1;k++){ soft_delay_ms(1); WDT_clear();};   
308:                  CE_HIGH;	
  0011    1785    SETB	0x5,7
  0012    0008    RET
309:                  //for(k=0;k<1;k++){ soft_delay_ms(1); WDT_clear();};
310:              }
311:              
312:              void RF_Read_Buff(unsigned char reg_addr, unsigned char *pBuff, unsigned char length)
313:              {
  0B2A    00C6    LD	0x46,A
314:                  unsigned char byte_ctr;
315:                  CSN_LOW;                    		                               			
  0B2B    1109    CLRB	0x9,2
316:                  SPI_RW(reg_addr);       		                                                		
  0B2C    118A    CLRB	0xA,3
  0B2D    26DD    CALL	0x6DD
  0B2E    158A    SETB	0xA,3
317:                  for(byte_ctr=0;byte_ctr<length;byte_ctr++){
  0B2F    01C7    CLR	0x47
  0B30    0876    LD	A,0x76
  0B31    0247    SUBA	0x47
  0B32    1803    SZB	0x3,0
  0B33    2B40    JP	0x340
318:                  	pBuff[byte_ctr] = SPI_RW(0);         
  0B34    0847    LD	A,0x47
  0B35    0775    ADDA	0x75
  0B36    00C5    LD	0x45,A
  0B37    0084    LD	0x4,A
  0B38    3000    LDIA	0x0
  0B39    118A    CLRB	0xA,3
  0B3A    26DD    CALL	0x6DD
  0B3B    158A    SETB	0xA,3
  0B3C    1383    CLRB	0x3,7
  0B3D    0080    LD	0x0,A
  0B3E    0AC7    INCR	0x47
  0B3F    2B30    JP	0x330
319:              	}                                        		
320:                  CSN_HIGH;                                                                   		
  0B40    1509    SETB	0x9,2
  0B41    0008    RET
321:              }
322:              
323:              void RF_Write_Buff(unsigned char reg_addr,unsigned char *pBuff,unsigned char length)
324:              {
  06C4    00F5    LD	0x75,A
325:                  unsigned char i;
326:                  CSN_LOW;
  06C5    1109    CLRB	0x9,2
327:                  SPI_RW(reg_addr);
  06C6    26DD    CALL	0x6DD
  06C7    118A    CLRB	0xA,3
328:                  for(i=0;i<length;i++)
  06C8    01F6    CLR	0x76
  06C9    0847    LD	A,0x47
  06CA    0276    SUBA	0x76
  06CB    1803    SZB	0x3,0
  06CC    2EDB    JP	0x6DB
329:                  {
330:                      SPI_RW(pBuff[i]);
  06CD    0876    LD	A,0x76
  06CE    0745    ADDA	0x45
  06CF    0084    LD	0x4,A
  06D0    0846    LD	A,0x46
  06D1    1803    SZB	0x3,0
  06D2    0A46    INCA	0x46
  06D3    00FF    LD	0x7F,A
  06D4    158A    SETB	0xA,3
  06D5    2000    CALL	0x0
  06D6    118A    CLRB	0xA,3
  06D7    26DD    CALL	0x6DD
  06D8    118A    CLRB	0xA,3
  06D9    0AF6    INCR	0x76
  06DA    2EC9    JP	0x6C9
331:                  }
332:                  CSN_HIGH;
  06DB    1509    SETB	0x9,2
  06DC    0008    RET
333:              }
334:              
335:              void RF_WriteReg(unsigned char reg_addr, unsigned char write_data)
336:              {
  06B9    00F6    LD	0x76,A
337:                  CSN_LOW;
  06BA    1283    CLRB	0x3,5
  06BB    1303    CLRB	0x3,6
  06BC    1109    CLRB	0x9,2
338:                  SPI_RW(reg_addr);
  06BD    0876    LD	A,0x76
  06BE    26DD    CALL	0x6DD
  06BF    118A    CLRB	0xA,3
339:                  SPI_RW(write_data);
  06C0    0875    LD	A,0x75
  06C1    26DD    CALL	0x6DD
340:                  CSN_HIGH;
  06C2    1509    SETB	0x9,2
  06C3    0008    RET
341:              }
342:              
343:              unsigned char RF_ReadReg(unsigned char reg_addr)
344:              {
  0B46    00F5    LD	0x75,A
345:              	unsigned char tmp;
346:                  CSN_LOW;
  0B47    1109    CLRB	0x9,2
347:                  SPI_RW(reg_addr);
  0B48    118A    CLRB	0xA,3
  0B49    26DD    CALL	0x6DD
  0B4A    158A    SETB	0xA,3
348:                  tmp = SPI_RW(0);
  0B4B    3000    LDIA	0x0
  0B4C    118A    CLRB	0xA,3
  0B4D    26DD    CALL	0x6DD
  0B4E    00F6    LD	0x76,A
349:                  CSN_HIGH;
  0B4F    1509    SETB	0x9,2
350:                  return tmp;
  0B50    0008    RET
351:              }
352:              
353:              static void SPI_init(void)
354:              {
355:              	
356:              	SPI_CSN_IO =0;	
  0732    1683    SETB	0x3,5
  0733    1109    CLRB	0x9,2
357:              	SPI_SCK_IO=0;	
  0734    1089    CLRB	0x9,1
358:              	SPI_MOSI_IO=0;	
  0735    1285    CLRB	0x5,5
359:              	SPI_CE_IO = 0;
  0736    1385    CLRB	0x5,7
360:              
361:              	SPI_IRQ_IO = 1;
  0737    1585    SETB	0x5,3
362:              	SPI_MISO_IO=1;
  0738    1605    SETB	0x5,4
  0739    0008    RET
363:              }
364:              
365:              /******************************************************************************
366:              * SPI写入一个BYTE的同时，读出一个BYTE返回
367:              ******************************************************************************/
368:              static unsigned char SPI_RW(unsigned char read_reg_addr)
369:              {
  06DD    00F3    LD	0x73,A
370:                  unsigned char i;
371:                  for(i = 0; i < 8; i++)
  06DE    01F4    CLR	0x74
372:                  {
373:                      SCK_LOW;
  06DF    1089    CLRB	0x9,1
374:                      if(read_reg_addr & 0x80)
  06E0    1FF3    SNZB	0x73,7
  06E1    2EE4    JP	0x6E4
375:                      {
376:                          MOSI_HIGH;
  06E2    1685    SETB	0x5,5
377:                      }
  06E3    2EE5    JP	0x6E5
378:                      else
379:                      {
380:                          MOSI_LOW;
  06E4    1285    CLRB	0x5,5
381:                      }
382:                      read_reg_addr = read_reg_addr << 1;
  06E5    1003    CLRB	0x3,0
  06E6    0DF3    RLCR	0x73
383:                      SCK_HIGH;
  06E7    1489    SETB	0x9,1
384:                      if( MISO )
  06E8    1A05    SZB	0x5,4
385:                      {
386:                        read_reg_addr = read_reg_addr | 0x01;
  06E9    1473    SETB	0x73,0
  06EA    3008    LDIA	0x8
  06EB    0AF4    INCR	0x74
  06EC    0274    SUBA	0x74
387:                      }
388:                  }
389:                  SCK_LOW;
  06ED    1089    CLRB	0x9,1
  06EE    1C03    SNZB	0x3,0
  06EF    2EE0    JP	0x6E0
390:                  return read_reg_addr;
  06F0    0873    LD	A,0x73
  06F1    0008    RET
391:              }
392:              
393:              
394:              
395:              
396:              
397:              
398:              
399:              
400:              
401:              
402:              
403:              
404:              
405:              
406:              
407:              
---- D:\Work\file\PAN\PAN2416\编译器\CMS_IDE_V1.41.03_CRC_PANCHIP\data\sources\wmul.c ----------------------------------------------------------------------
1:                unsigned int
2:                __wmul(unsigned int multiplier, unsigned int multiplicand)
3:                {
  01D5    01C5    CLR	0x45
  01D6    01C6    CLR	0x46
  01D7    1C73    SNZB	0x73,0
  01D8    29DF    JP	0x1DF
  01D9    0875    LD	A,0x75
  01DA    07C5    ADDR	0x45
  01DB    1803    SZB	0x3,0
  01DC    0AC6    INCR	0x46
  01DD    0876    LD	A,0x76
  01DE    07C6    ADDR	0x46
  01DF    1003    CLRB	0x3,0
  01E0    0DF5    RLCR	0x75
  01E1    0DF6    RLCR	0x76
  01E2    1003    CLRB	0x3,0
  01E3    0CF4    RRCR	0x74
  01E4    0CF3    RRCR	0x73
  01E5    0874    LD	A,0x74
  01E6    0473    ORA	0x73
  01E7    1D03    SNZB	0x3,2
  01E8    29D7    JP	0x1D7
  01E9    0846    LD	A,0x46
  01EA    00F4    LD	0x74,A
  01EB    0845    LD	A,0x45
  01EC    00F3    LD	0x73,A
  01ED    0008    RET
4:                	unsigned int	product = 0;
5:                
6:                	do {
7:                		if(multiplier & 1)
8:                			product += multiplicand;
9:                		multiplicand <<= 1;
10:               		multiplier >>= 1;
11:               	} while(multiplier != 0);
12:               	return product;
13:               }
---- D:\Work\file\PAN\PAN2416\编译器\CMS_IDE_V1.41.03_CRC_PANCHIP\data\sources\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                __lwdiv(unsigned int divisor, unsigned int dividend)
5:                {
  01EE    01C5    CLR	0x45
  01EF    01C6    CLR	0x46
  01F0    0874    LD	A,0x74
  01F1    0473    ORA	0x73
  01F2    1903    SZB	0x3,2
  01F3    2A13    JP	0x213
  01F4    01C7    CLR	0x47
  01F5    0AC7    INCR	0x47
  01F6    1BF4    SZB	0x74,7
  01F7    29FC    JP	0x1FC
  01F8    1003    CLRB	0x3,0
  01F9    0DF3    RLCR	0x73
  01FA    0DF4    RLCR	0x74
  01FB    29F5    JP	0x1F5
  01FC    1003    CLRB	0x3,0
  01FD    0DC5    RLCR	0x45
  01FE    0DC6    RLCR	0x46
  01FF    0874    LD	A,0x74
  0200    0276    SUBA	0x76
  0201    1D03    SNZB	0x3,2
  0202    2A05    JP	0x205
  0203    0873    LD	A,0x73
  0204    0275    SUBA	0x75
  0205    1C03    SNZB	0x3,0
  0206    2A0F    JP	0x20F
  0207    0873    LD	A,0x73
  0208    02F5    SUBR	0x75
  0209    0874    LD	A,0x74
  020A    1C03    SNZB	0x3,0
  020B    03F6    DECR	0x76
  020C    02F6    SUBR	0x76
  020D    1445    SETB	0x45,0
  020E    1003    CLRB	0x3,0
  020F    0CF4    RRCR	0x74
  0210    0CF3    RRCR	0x73
  0211    0BC7    SZDECR	0x47
  0212    29FC    JP	0x1FC
  0213    0846    LD	A,0x46
  0214    00F4    LD	0x74,A
  0215    0845    LD	A,0x45
  0216    00F3    LD	0x73,A
  0217    0008    RET
6:                	unsigned int	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x8000) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\WDT.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "WDT.h"
3:                
4:                void WDT_enable(WDT_DIVIDE_RATIO_e WDT_DIVIDE_RATIO);
5:                void WDT_clear(void);
6:                void WDT_disable(void);
7:                
8:                
9:                
10:               void WDT_enable(WDT_DIVIDE_RATIO_e WDT_DIVIDE_RATIO)
11:               {
  08A1    00F3    LD	0x73,A
12:               	OPTION_REG &= 0xf0;
  08A2    30F0    LDIA	0xF0
  08A3    1683    SETB	0x3,5
  08A4    0581    ANDR	0x1
13:               	OPTION_REG |= WDT_DIVIDE_RATIO;
  08A5    0873    LD	A,0x73
  08A6    0481    ORR	0x1
14:               	WDTCON |= 0x01;			//使能WDT
  08A7    1283    CLRB	0x3,5
  08A8    1703    SETB	0x3,6
  08A9    1405    SETB	0x5,0
  08AA    0064    CLRWDT
  08AB    0008    RET
15:               	asm("CLRWDT");
16:               }
17:               
18:               void WDT_clear(void)
19:               {
  059C    0064    CLRWDT
  059D    0008    RET
20:               	asm("CLRWDT");
21:               }
22:               
23:               void WDT_disable()
24:               {
25:               	WDTCON &= ~0x01;			//关闭WDT
26:               }
27:               
28:               
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\delay.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "delay.h"
3:                
4:                void soft_delay_ms(unsigned int ms);
5:                
6:                
7:                
8:                
9:                void soft_delay_ms(unsigned int ms)
10:               {
11:               //	8M主频
12:               	volatile unsigned int i;
13:               	volatile unsigned char j,k;
14:               	for(i=0;i<ms;i++){
  059E    1283    CLRB	0x3,5
  059F    1303    CLRB	0x3,6
  05A0    01C5    CLR	0x45
  05A1    01C6    CLR	0x46
  05A2    0874    LD	A,0x74
  05A3    0246    SUBA	0x46
  05A4    1D03    SNZB	0x3,2
  05A5    2DA8    JP	0x5A8
  05A6    0873    LD	A,0x73
  05A7    0245    SUBA	0x45
  05A8    1803    SZB	0x3,0
  05A9    0008    RET
15:               		for(j=0;j<10;j++){
  05AA    01C7    CLR	0x47
  05AB    300A    LDIA	0xA
  05AC    0247    SUBA	0x47
  05AD    1803    SZB	0x3,0
  05AE    2DB8    JP	0x5B8
16:               			for(k=0;k<32;k++);
  05AF    01C8    CLR	0x48
  05B0    3020    LDIA	0x20
  05B1    0248    SUBA	0x48
  05B2    1803    SZB	0x3,0
  05B3    2DB6    JP	0x5B6
  05B4    0AC8    INCR	0x48
  05B5    2DB0    JP	0x5B0
  05B6    0AC7    INCR	0x47
  05B7    2DAB    JP	0x5AB
  05B8    0AC5    INCR	0x45
  05B9    1903    SZB	0x3,2
  05BA    0AC6    INCR	0x46
  05BB    2DA2    JP	0x5A2
17:               		}
18:               	}
19:               }
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\PWM.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "PWM.h"
3:                
4:                void CCPX_Init(PWM_DIV_e PWM_DIV,unsigned char T_nums);
5:                void CCP1_set_duty_cycle(unsigned int duty_cycle);	//RC2 pin
6:                void CCP2_set_duty_cycle(unsigned int duty_cycle);	//RC1 pin
7:                
8:                /**********************************************************
9:                *与定时器2功能冲突
10:               *时钟源F = Fosc/4
11:               *采用脉宽调制，T = (1/F)*PWM_DIV*T_nums
12:               *分辨率 == T_nums*4
13:               ***********************************************************/
14:               void CCPX_Init(PWM_DIV_e PWM_DIV,unsigned char T_nums)
15:               {
  08DB    00F4    LD	0x74,A
16:               	T2CON = 0x00;
  08DC    0192    CLR	0x12
17:               	
18:               	//Set CCP1 
19:               	TRISC |= 0x04;		//TRISC2 = 1(PWM1引脚输入);
  08DD    1683    SETB	0x3,5
  08DE    1507    SETB	0x7,2
20:               	CCP1CON &= ~0x3f;
  08DF    30C0    LDIA	0xC0
  08E0    1283    CLRB	0x3,5
  08E1    0597    ANDR	0x17
21:               	CCP1CON |= 0x0f;	//PWM模式
  08E2    300F    LDIA	0xF
  08E3    0497    ORR	0x17
22:               	CCP1CON &=~ 0x30;	
  08E4    30CF    LDIA	0xCF
  08E5    0597    ANDR	0x17
23:               	CCPR1L = 0x00;		//初始化占空比0
  08E6    0195    CLR	0x15
24:               	
25:               	//Set CCP2
26:               	TRISC |= 0x02;		//TRISC1 = 1(PWM2引脚输入);
  08E7    1683    SETB	0x3,5
  08E8    1487    SETB	0x7,1
27:               	CCP2CON &= ~0x3f;
  08E9    30C0    LDIA	0xC0
  08EA    1283    CLRB	0x3,5
  08EB    059D    ANDR	0x1D
28:               	CCP2CON |= 0x0f;	//PWM模式
  08EC    300F    LDIA	0xF
  08ED    049D    ORR	0x1D
29:               	CCP2CON &=~ 0x30;	
  08EE    30CF    LDIA	0xCF
  08EF    059D    ANDR	0x1D
30:               	CCPR2L = 0x00;		//初始化占空比0
  08F0    019B    CLR	0x1B
31:               	
32:               	//Set Timer2
33:               	PR2 = T_nums;		//T 
  08F1    0873    LD	A,0x73
  08F2    1683    SETB	0x3,5
  08F3    0092    LD	0x12,A
34:               	PIR1 &= ~0x02;		//TMR2IF = 0;
  08F4    1283    CLRB	0x3,5
  08F5    108C    CLRB	0xC,1
35:               	T2CON &= ~0x7f;
  08F6    3080    LDIA	0x80
  08F7    0592    ANDR	0x12
36:               	T2CON |= PWM_DIV;	//T2CKPS = B'00'  1分频，预分频  
  08F8    0874    LD	A,0x74
  08F9    0492    ORR	0x12
37:               	
38:               //	INTCON |= 0x40;		//PEIE = 1;开外设中断
39:               //	PIE1 |= 0x02;		//TMR2IE = 1; 开中断
40:               	T2CON |= 0x04;		//TMR2ON = 1; 开定时器2
  08FA    1512    SETB	0x12,2
41:               	
42:               	TRISC &= ~0x02;		//TRISC1 = 0(PWM2引脚输出);
  08FB    1683    SETB	0x3,5
  08FC    1087    CLRB	0x7,1
43:               	TRISC &= ~0x04;		//TRISC2 = 0(PWM2引脚输出);
  08FD    1107    CLRB	0x7,2
  08FE    0008    RET
44:               }
45:               
46:               /****************************************************
47:               *CCP1_set_duty_cycle
48:               *占空比 = duty_cycle/(T_nums * 4)
49:               *T_nums在初始化时设定
50:               ******************************************************/
51:               void CCP1_set_duty_cycle(unsigned int duty_cycle)
52:               {
53:               	unsigned char i=0;
54:               	i=CCP1CON;
  0702    1283    CLRB	0x3,5
  0703    1303    CLRB	0x3,6
  0704    0817    LD	A,0x17
  0705    00C5    LD	0x45,A
55:               	i&=0xCF;
  0706    30CF    LDIA	0xCF
  0707    05C5    ANDR	0x45
56:               	i|= (duty_cycle<<4)&0x70;	//占空比低2位
  0708    0E73    SWAPA	0x73
  0709    39F0    ANDIA	0xF0
  070A    3970    ANDIA	0x70
  070B    04C5    ORR	0x45
57:               	CCP1CON=i;
  070C    0845    LD	A,0x45
  070D    0097    LD	0x17,A
58:               	CCPR1L = duty_cycle>>2;				//占空比高8位
  070E    0874    LD	A,0x74
  070F    00F6    LD	0x76,A
  0710    0873    LD	A,0x73
  0711    00F5    LD	0x75,A
  0712    1003    CLRB	0x3,0
  0713    0CF6    RRCR	0x76
  0714    0CF5    RRCR	0x75
  0715    1003    CLRB	0x3,0
  0716    0CF6    RRCR	0x76
  0717    0CF5    RRCR	0x75
  0718    0875    LD	A,0x75
  0719    0095    LD	0x15,A
  071A    0008    RET
59:               }
60:               
61:               /****************************************************
62:               *CCP2_set_duty_cycle
63:               *占空比 = duty_cycle/(T_nums * 4)
64:               *T_nums在初始化时设定
65:               ******************************************************/
66:               void CCP2_set_duty_cycle(unsigned int duty_cycle)
67:               {
68:               	
69:               	unsigned char i=0;
70:               	i=CCP2CON;
  071B    081D    LD	A,0x1D
  071C    00C5    LD	0x45,A
71:               	i&=0xCF;
  071D    30CF    LDIA	0xCF
  071E    05C5    ANDR	0x45
72:               	i|= (duty_cycle<<4)&0x70;	//占空比低2位
  071F    0E73    SWAPA	0x73
  0720    39F0    ANDIA	0xF0
  0721    3970    ANDIA	0x70
  0722    04C5    ORR	0x45
73:               	CCP2CON=i;
  0723    0845    LD	A,0x45
  0724    009D    LD	0x1D,A
74:               	CCPR2L = duty_cycle>>2;				//占空比高8位
  0725    0874    LD	A,0x74
  0726    00F6    LD	0x76,A
  0727    0873    LD	A,0x73
  0728    00F5    LD	0x75,A
  0729    1003    CLRB	0x3,0
  072A    0CF6    RRCR	0x76
  072B    0CF5    RRCR	0x75
  072C    1003    CLRB	0x3,0
  072D    0CF6    RRCR	0x76
  072E    0CF5    RRCR	0x75
  072F    0875    LD	A,0x75
  0730    009B    LD	0x1B,A
  0731    0008    RET
75:               }
76:               
77:               
78:               
79:               
80:               
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\I2C_Base.c ----------------------------------------------------------------------
1:                #include "I2C_Base.h"
2:                #include "cms.h"
3:                #include "system.h"
4:                #include "cUART.h"
5:                
6:                
7:                
8:                uchar Dtime=0;
9:                
10:               /*
11:               功能：I2C专属延时。入口为IIC_Dtime
12:               */
13:               IIC_delay(uchar DLAtime)
14:               {
  0FA7    00F3    LD	0x73,A
15:               uchar j;
16:               for(j=0;j<DLAtime;j++);
  0FA8    01F4    CLR	0x74
  0FA9    0873    LD	A,0x73
  0FAA    0274    SUBA	0x74
  0FAB    1803    SZB	0x3,0
  0FAC    0008    RET
  0FAD    0AF4    INCR	0x74
  0FAE    2FA9    JP	0x7A9
17:               }
18:               
19:               
20:               /*
21:               IIC初始化函数
22:               入口：freq,频率，单位为KHZ
23:               出口：无
24:               */
25:               void IIC_Init(uchar freq)
26:               {
  0E15    00F5    LD	0x75,A
27:               //-------计算延时因子-------
28:               Dtime=freq;  //为半周期延时时间，单位0.125US
  0E16    00F7    LD	0x77,A
29:               IIC_SCL_outmode;
  0E17    1683    SETB	0x3,5
  0E18    1386    CLRB	0x6,7
30:               
31:               //IIC_SDA_outmode; 
32:               IIC_SDA_inmode;//pan
  0E19    1715    SETB	0x15,6
  0E1A    1706    SETB	0x6,6
33:               IIC_SCL_output=1;
  0E1B    1283    CLRB	0x3,5
  0E1C    300A    LDIA	0xA
  0E1D    1786    SETB	0x6,7
34:               IIC_delay(10);
  0E1E    27A7    CALL	0x7A7
  0E1F    158A    SETB	0xA,3
35:               IIC_SDA_outmode;
  0E20    1683    SETB	0x3,5
  0E21    1306    CLRB	0x6,6
36:               IIC_SDA_output=1;
  0E22    1283    CLRB	0x3,5
  0E23    300A    LDIA	0xA
  0E24    1706    SETB	0x6,6
37:               IIC_delay(10);
  0E25    2FA7    JP	0x7A7
38:               }
39:               
40:               
41:               /*
42:               功能：发出起始信号！
43:               返回：
44:               0：结束信号发送OK
45:               1：结束信号发送失败.一般是由从机拉低了SDA线造成
46:               */
47:               uchar IIC_start(void)
48:               {
49:               uchar k=0;
50:               //ulong j=0;
51:               
52:               
53:               IIC_SCL_output=0; 
  0E6B    1386    CLRB	0x6,7
54:               
55:               IIC_SDA_outmode; //pan新加，推挽
  0E6C    1683    SETB	0x3,5
  0E6D    1306    CLRB	0x6,6
56:               IIC_SDA_output=1; IIC_delay(Dtime/2);
  0E6E    1283    CLRB	0x3,5
  0E6F    1706    SETB	0x6,6
  0E70    1003    CLRB	0x3,0
  0E71    0C77    RRCA	0x77
  0E72    27A7    CALL	0x7A7
  0E73    158A    SETB	0xA,3
57:               
58:               IIC_SCL_output=1; IIC_delay(Dtime/2);
  0E74    1786    SETB	0x6,7
  0E75    1003    CLRB	0x3,0
  0E76    0C77    RRCA	0x77
  0E77    27A7    CALL	0x7A7
  0E78    158A    SETB	0xA,3
59:               //do{k=IIC_SCL_input;if(j++>200000) return(1);}while(k==0); //起始信号失败，超时！
60:               IIC_delay(Dtime/2);
  0E79    1003    CLRB	0x3,0
  0E7A    0C77    RRCA	0x77
  0E7B    27A7    CALL	0x7A7
  0E7C    158A    SETB	0xA,3
61:               IIC_SDA_output=0; IIC_delay(Dtime);
  0E7D    1306    CLRB	0x6,6
  0E7E    0877    LD	A,0x77
  0E7F    27A7    CALL	0x7A7
62:               return(0);
  0E80    3400    RET	0x0
63:               }
64:               	 
65:               /*
66:               功能：发出结束信号！
67:               返回：
68:               0：结束信号发送OK
69:               1：结束信号发送失败.一般是由从机拉低了SDA线造成
70:               */
71:               uchar IIC_stop(void)
72:               {
73:               uchar k=0;
74:               //ulong j=0;
75:               IIC_SCL_output=0; IIC_delay(Dtime/2);
  0F21    1283    CLRB	0x3,5
  0F22    1386    CLRB	0x6,7
  0F23    1003    CLRB	0x3,0
  0F24    0C77    RRCA	0x77
  0F25    27A7    CALL	0x7A7
  0F26    158A    SETB	0xA,3
76:               
77:               IIC_SDA_outmode; //pan新加，推挽
  0F27    1683    SETB	0x3,5
  0F28    1306    CLRB	0x6,6
78:               IIC_SDA_output=0; IIC_delay(Dtime/2);
  0F29    1283    CLRB	0x3,5
  0F2A    1306    CLRB	0x6,6
  0F2B    1003    CLRB	0x3,0
  0F2C    0C77    RRCA	0x77
  0F2D    27A7    CALL	0x7A7
  0F2E    158A    SETB	0xA,3
79:               IIC_SCL_output=1; IIC_delay(Dtime/2);
  0F2F    1786    SETB	0x6,7
  0F30    1003    CLRB	0x3,0
  0F31    0C77    RRCA	0x77
  0F32    27A7    CALL	0x7A7
  0F33    158A    SETB	0xA,3
80:               //do{k=IIC_SCL_input;if(j++>200000) return(1);}while(k==0); //停止信号失败，超时！
81:               IIC_delay(Dtime);
  0F34    0877    LD	A,0x77
  0F35    27A7    CALL	0x7A7
  0F36    158A    SETB	0xA,3
82:               IIC_SDA_output=1; IIC_delay(Dtime);
  0F37    1706    SETB	0x6,6
  0F38    0877    LD	A,0x77
  0F39    27A7    CALL	0x7A7
  0F3A    158A    SETB	0xA,3
83:               //do{k=IIC_SDA_input;if(j++>200000) return(1);}while(k==0); //停止信号失败，超时！
84:               
85:               IIC_SDA_inmode; //pan新加，释放，上拉
86:               return(0);
  0F3B    2FFB    JP	0x7FB
87:               }
88:               
89:               /*
90:               功能：读ACK信号，带滤波
91:               返回：
92:               0：ACK=0
93:               1：ACK=1
94:               0xff//读ACK信号失败，超时！
95:               */
96:               uchar IIC_RACK(void)
97:               {
  0F64    01CA    CLR	0x4A
98:               uchar buf[5];
99:               uchar i=0,k=0;
100:              //ulong j=0;
101:              
102:              
103:              
104:              IIC_SCL_output=0; IIC_delay(Dtime);
  0F65    1386    CLRB	0x6,7
  0F66    0877    LD	A,0x77
  0F67    27A7    CALL	0x7A7
  0F68    158A    SETB	0xA,3
105:              
106:              IIC_SDA_inmode; //pan新加，释放，上拉
  0F69    1683    SETB	0x3,5
  0F6A    1715    SETB	0x15,6
  0F6B    1706    SETB	0x6,6
107:              IIC_SDA_output=1; IIC_delay(Dtime/2); //释放总线
  0F6C    1283    CLRB	0x3,5
  0F6D    1706    SETB	0x6,6
  0F6E    1003    CLRB	0x3,0
  0F6F    0C77    RRCA	0x77
  0F70    27A7    CALL	0x7A7
  0F71    158A    SETB	0xA,3
  0F72    3003    LDIA	0x3
108:              
109:              IIC_SCL_output=1; IIC_delay(Dtime/3);
  0F73    1786    SETB	0x6,7
  0F74    00F3    LD	0x73,A
  0F75    0877    LD	A,0x77
  0F76    27DE    CALL	0x7DE
  0F77    158A    SETB	0xA,3
  0F78    27A7    CALL	0x7A7
  0F79    158A    SETB	0xA,3
110:              //do{k=IIC_SCL_input;if(j++>200000) return(0xff);}while(k==0); //读ACK信号失败，超时！
111:              IIC_delay(Dtime/3);
  0F7A    3003    LDIA	0x3
  0F7B    00F3    LD	0x73,A
  0F7C    0877    LD	A,0x77
  0F7D    27DE    CALL	0x7DE
  0F7E    158A    SETB	0xA,3
  0F7F    27A7    CALL	0x7A7
  0F80    158A    SETB	0xA,3
112:              
113:              for(i=0;i<5;i++) buf[i]=IIC_SDA_input; 
  0F81    01CB    CLR	0x4B
  0F82    084B    LD	A,0x4B
  0F83    3E45    ADDIA	0x45
  0F84    0084    LD	0x4,A
  0F85    3000    LDIA	0x0
  0F86    1B06    SZB	0x6,6
  0F87    3001    LDIA	0x1
  0F88    1383    CLRB	0x3,7
  0F89    0080    LD	0x0,A
  0F8A    3005    LDIA	0x5
  0F8B    0ACB    INCR	0x4B
  0F8C    024B    SUBA	0x4B
  0F8D    1C03    SNZB	0x3,0
  0F8E    2F82    JP	0x782
114:              k=0;
  0F8F    01CA    CLR	0x4A
115:              for(i=0;i<5;i++) {if(buf[i]!=0)k++; if(k>3) return(1);}
  0F90    01CB    CLR	0x4B
  0F91    084B    LD	A,0x4B
  0F92    3E45    ADDIA	0x45
  0F93    0084    LD	0x4,A
  0F94    0880    TESTZ	0x0
  0F95    1D03    SNZB	0x3,2
  0F96    0ACA    INCR	0x4A
  0F97    3004    LDIA	0x4
  0F98    024A    SUBA	0x4A
  0F99    1803    SZB	0x3,0
  0F9A    3401    RET	0x1
  0F9B    3005    LDIA	0x5
  0F9C    0ACB    INCR	0x4B
  0F9D    024B    SUBA	0x4B
  0F9E    1C03    SNZB	0x3,0
  0F9F    2F91    JP	0x791
116:              
117:              IIC_delay(Dtime/3);
  0FA0    3003    LDIA	0x3
  0FA1    00F3    LD	0x73,A
  0FA2    0877    LD	A,0x77
  0FA3    27DE    CALL	0x7DE
  0FA4    158A    SETB	0xA,3
  0FA5    27A7    CALL	0x7A7
118:              return(0);
  0FA6    3400    RET	0x0
119:              }
120:              
121:              /*
122:              功能：写ACK信号
123:              入口：
124:              0：ACK=0
125:              1：ACK=1
126:              */
127:              uchar IIC_WACK(uchar ACK)
128:              {
  0F3C    00F6    LD	0x76,A
129:              //uchar k=0;
130:              //ulong j=0;
131:              IIC_SCL_output=0;   IIC_delay(Dtime/2);
  0F3D    1386    CLRB	0x6,7
  0F3E    1003    CLRB	0x3,0
  0F3F    0C77    RRCA	0x77
  0F40    27A7    CALL	0x7A7
  0F41    158A    SETB	0xA,3
132:              
133:              IIC_SDA_outmode; //pan新加，推挽
  0F42    1683    SETB	0x3,5
  0F43    1306    CLRB	0x6,6
134:              if(ACK)
  0F44    0876    LD	A,0x76
  0F45    1903    SZB	0x3,2
  0F46    2F4A    JP	0x74A
135:              IIC_SDA_output=1;
  0F47    1283    CLRB	0x3,5
  0F48    1706    SETB	0x6,6
  0F49    2F4C    JP	0x74C
136:              else
137:              IIC_SDA_output=0;	
  0F4A    1283    CLRB	0x3,5
  0F4B    1306    CLRB	0x6,6
138:              	
139:              IIC_delay(Dtime/2);
  0F4C    1003    CLRB	0x3,0
  0F4D    0C77    RRCA	0x77
  0F4E    27A7    CALL	0x7A7
  0F4F    158A    SETB	0xA,3
140:              IIC_SCL_output=1;   IIC_delay(Dtime/2);
  0F50    1786    SETB	0x6,7
  0F51    1003    CLRB	0x3,0
  0F52    0C77    RRCA	0x77
  0F53    27A7    CALL	0x7A7
  0F54    158A    SETB	0xA,3
141:              //do{k=IIC_SCL_input;if(j++>1000000) return(1);}while(k==0);
142:              IIC_delay(Dtime);
  0F55    0877    LD	A,0x77
  0F56    27A7    CALL	0x7A7
  0F57    158A    SETB	0xA,3
143:              
144:              //-----------------  
145:              IIC_SCL_output=0;   IIC_delay(Dtime/4);
  0F58    1386    CLRB	0x6,7
  0F59    0877    LD	A,0x77
  0F5A    00F5    LD	0x75,A
  0F5B    1003    CLRB	0x3,0
  0F5C    0CF5    RRCR	0x75
  0F5D    1003    CLRB	0x3,0
  0F5E    0CF5    RRCR	0x75
  0F5F    0875    LD	A,0x75
  0F60    27A7    CALL	0x7A7
  0F61    158A    SETB	0xA,3
146:              
147:              IIC_SDA_output=1; 
  0F62    1706    SETB	0x6,6
148:              IIC_SDA_inmode; //pan新加，释放，上拉
149:              return(0);
  0F63    2FFB    JP	0x7FB
150:              }
151:              
152:              /*
153:              功能：向I2C总线写8位数据，高位先发，SCL低期间改变数据！ 
154:              入口：要写的字节
155:              出口
156:              0： 写OK，不包含应答！
157:              1： 从机拉低SCL信号线希望延时，但超时了！
158:              */
159:              uchar IIC_Wbyte(uchar Wdat)
160:              {
  0FAF    00C5    LD	0x45,A
161:              //ulong j=0;
162:              uchar k=0;
163:              uchar i=0;
164:              
165:              	IIC_SDA_outmode; //pan新加，推挽
  0FB0    1683    SETB	0x3,5
  0FB1    1306    CLRB	0x6,6
166:              
167:              	for(i=0;i<8;i++) 
  0FB2    1283    CLRB	0x3,5
  0FB3    01C6    CLR	0x46
168:              	{
169:              	IIC_SCL_output=0;
  0FB4    1386    CLRB	0x6,7
170:              	IIC_delay(Dtime/2);
  0FB5    1003    CLRB	0x3,0
  0FB6    0C77    RRCA	0x77
  0FB7    27A7    CALL	0x7A7
  0FB8    158A    SETB	0xA,3
171:              		
172:              	if((Wdat&(1<<(7-i)))?(1):(0))
  0FB9    3001    LDIA	0x1
  0FBA    00F5    LD	0x75,A
  0FBB    0846    LD	A,0x46
  0FBC    3C07    SUBIA	0x7
  0FBD    3E01    ADDIA	0x1
  0FBE    2FC1    JP	0x7C1
  0FBF    1003    CLRB	0x3,0
  0FC0    0DF5    RLCR	0x75
  0FC1    3EFF    ADDIA	0xFF
  0FC2    1D03    SNZB	0x3,2
  0FC3    2FBF    JP	0x7BF
  0FC4    0875    LD	A,0x75
  0FC5    0545    ANDA	0x45
  0FC6    1903    SZB	0x3,2
  0FC7    2FCA    JP	0x7CA
173:              	IIC_SDA_output=1;
  0FC8    1706    SETB	0x6,6
  0FC9    2FCB    JP	0x7CB
174:              	else
175:              	IIC_SDA_output=0;		
  0FCA    1306    CLRB	0x6,6
176:              
177:              	
178:              	IIC_delay(Dtime/2);
  0FCB    1003    CLRB	0x3,0
  0FCC    0C77    RRCA	0x77
  0FCD    27A7    CALL	0x7A7
  0FCE    158A    SETB	0xA,3
179:              	IIC_SCL_output=1;  IIC_delay(Dtime/2);
  0FCF    1786    SETB	0x6,7
  0FD0    1003    CLRB	0x3,0
  0FD1    0C77    RRCA	0x77
  0FD2    27A7    CALL	0x7A7
  0FD3    158A    SETB	0xA,3
180:              	//此时从机应释放时钟总线。若不释放则等待其释放
181:              	//do{k=IIC_SCL_input;if(j++>1000000) return(1);}while(k==0);
182:              	IIC_delay(Dtime/2);
  0FD4    1003    CLRB	0x3,0
  0FD5    0C77    RRCA	0x77
  0FD6    27A7    CALL	0x7A7
  0FD7    158A    SETB	0xA,3
  0FD8    3008    LDIA	0x8
  0FD9    0AC6    INCR	0x46
  0FDA    0246    SUBA	0x46
  0FDB    1803    SZB	0x3,0
183:              	}
184:              	return(0);
  0FDC    3400    RET	0x0
  0FDD    2FB4    JP	0x7B4
185:              }
186:              /*
187:              功能：从I2C总线读8位数据，高位先读，SCL高期间读数据！ 
188:              入口：无
189:              出口：所读到的数据！
190:              IIC_SDA_input
191:              */
192:              uchar IIC_Rbyte(void)
193:              {
194:              uchar i;
195:              uchar temp=0;
  0EAF    01C5    CLR	0x45
196:              uchar k=0;
197:              //ulong j=0;
198:              
199:              	IIC_SDA_output=1;  //释放总线
  0EB0    1706    SETB	0x6,6
200:              	IIC_SDA_inmode; //pan新加，释放，上拉
  0EB1    1683    SETB	0x3,5
  0EB2    1715    SETB	0x15,6
  0EB3    1706    SETB	0x6,6
201:              
202:              	for(i=0;i<8;i++)
  0EB4    1283    CLRB	0x3,5
  0EB5    01C7    CLR	0x47
203:              	{
204:              		IIC_SCL_output=0;  IIC_delay(Dtime);
  0EB6    1386    CLRB	0x6,7
  0EB7    0877    LD	A,0x77
  0EB8    27A7    CALL	0x7A7
  0EB9    158A    SETB	0xA,3
205:              		IIC_SCL_output=1;  IIC_delay(Dtime/2);
  0EBA    1786    SETB	0x6,7
  0EBB    1003    CLRB	0x3,0
  0EBC    0C77    RRCA	0x77
  0EBD    27A7    CALL	0x7A7
  0EBE    158A    SETB	0xA,3
206:              		//do{k=IIC_SCL_input;if(j++>1000000) return(0xee);}while(k==0);
207:              		IIC_delay(Dtime/2);
  0EBF    1003    CLRB	0x3,0
  0EC0    0C77    RRCA	0x77
  0EC1    27A7    CALL	0x7A7
  0EC2    158A    SETB	0xA,3
208:              		k=IIC_SDA_input;
  0EC3    3000    LDIA	0x0
  0EC4    1B06    SZB	0x6,6
  0EC5    3001    LDIA	0x1
  0EC6    00C6    LD	0x46,A
209:              		temp|=((k)?(1):(0))<<(7-i);
  0EC7    3000    LDIA	0x0
  0EC8    08C6    TESTZ	0x46
  0EC9    1D03    SNZB	0x3,2
  0ECA    3001    LDIA	0x1
  0ECB    00F5    LD	0x75,A
  0ECC    0847    LD	A,0x47
  0ECD    3C07    SUBIA	0x7
  0ECE    3E01    ADDIA	0x1
  0ECF    2ED2    JP	0x6D2
  0ED0    1003    CLRB	0x3,0
  0ED1    0DF5    RLCR	0x75
  0ED2    3EFF    ADDIA	0xFF
  0ED3    1D03    SNZB	0x3,2
  0ED4    2ED0    JP	0x6D0
  0ED5    0875    LD	A,0x75
  0ED6    04C5    ORR	0x45
210:              		IIC_delay(Dtime/2);
  0ED7    1003    CLRB	0x3,0
  0ED8    0C77    RRCA	0x77
  0ED9    27A7    CALL	0x7A7
  0EDA    158A    SETB	0xA,3
  0EDB    3008    LDIA	0x8
  0EDC    0AC7    INCR	0x47
  0EDD    0247    SUBA	0x47
  0EDE    1C03    SNZB	0x3,0
  0EDF    2EB6    JP	0x6B6
211:              	}
212:              return(temp);	
  0EE0    0845    LD	A,0x45
  0EE1    0008    RET
213:              }
214:              
215:              
216:              /*----------------------------------
217:              功能：
218:              读一个字节到*Rdat，注意：ACK有时应该为0！
219:              读流程为：
220:              0：START信号
221:              1：写Chip地址+写信号
222:              2：写要读寄存器的地址
223:              3：重复START信号
224:              4：写Chip地址+读信号
225:              5：读出数据
226:              6：STOP信号
227:              ----------------------------------
228:              入口：
229:              ACK：主机度数据后发送的应答，有时应该为0！
230:              Chip_Adds：片选地址
231:              Reg_Adds：要读寄存器的地址
232:              *Rdat： 数据存放的指针
233:              
234:              出口：
235:              0： OK
236:              1，6:           Start信号无效
237:              2，4，7：从机拉低SCL信号线以延时，但超时！
238:              3，5，8：从机发送的应答无效，即不是0！
239:              9:WACK;	失败
240:              10：             STOP发送无效！
241:              ----------------------------------*/
242:              uchar IIC_ReceByte(uchar ACK,uchar Chip_Adds,uchar Reg_Adds,uchar *Rdat)
243:              {
  0EE2    00CF    LD	0x4F,A
244:              if(IIC_start())  					 return(1);
  0EE3    266B    CALL	0x66B
  0EE4    158A    SETB	0xA,3
  0EE5    3A00    XORIA	0x0
  0EE6    1D03    SNZB	0x3,2
  0EE7    3401    RET	0x1
245:              if(IIC_Wbyte(Chip_Adds<<1))          return(2); //从机拉低SCL信号线以延时，但超时！
  0EE8    1003    CLRB	0x3,0
  0EE9    0D4C    RLCA	0x4C
  0EEA    27AF    CALL	0x7AF
  0EEB    158A    SETB	0xA,3
  0EEC    3A00    XORIA	0x0
  0EED    1D03    SNZB	0x3,2
  0EEE    3402    RET	0x2
246:              if(IIC_RACK())				         return(3); //应答无效
  0EEF    2764    CALL	0x764
  0EF0    158A    SETB	0xA,3
  0EF1    3A00    XORIA	0x0
  0EF2    1D03    SNZB	0x3,2
  0EF3    3403    RET	0x3
247:              if(IIC_Wbyte(Reg_Adds))	 		     return(4); //从机拉低SCL信号线以延时，但超时！
  0EF4    084D    LD	A,0x4D
  0EF5    27AF    CALL	0x7AF
  0EF6    158A    SETB	0xA,3
  0EF7    3A00    XORIA	0x0
  0EF8    1D03    SNZB	0x3,2
  0EF9    3404    RET	0x4
248:              if(IIC_RACK())		         	   	 return(5); //应答无效
  0EFA    2764    CALL	0x764
  0EFB    158A    SETB	0xA,3
  0EFC    3A00    XORIA	0x0
  0EFD    1D03    SNZB	0x3,2
  0EFE    3405    RET	0x5
249:              
250:              if(IIC_start())  					 return(6);							
  0EFF    266B    CALL	0x66B
  0F00    158A    SETB	0xA,3
  0F01    3A00    XORIA	0x0
  0F02    1D03    SNZB	0x3,2
  0F03    3406    RET	0x6
251:              if(IIC_Wbyte((Chip_Adds<<1)+1))      return(7); //从机拉低SCL信号线以延时，但超时！
  0F04    1403    SETB	0x3,0
  0F05    0D4C    RLCA	0x4C
  0F06    27AF    CALL	0x7AF
  0F07    158A    SETB	0xA,3
  0F08    3A00    XORIA	0x0
  0F09    1D03    SNZB	0x3,2
  0F0A    3407    RET	0x7
252:              if(IIC_RACK())				         return(8); //应答无效
  0F0B    2764    CALL	0x764
  0F0C    158A    SETB	0xA,3
  0F0D    3A00    XORIA	0x0
  0F0E    1D03    SNZB	0x3,2
  0F0F    3408    RET	0x8
253:              *Rdat=IIC_Rbyte();
  0F10    084E    LD	A,0x4E
  0F11    0084    LD	0x4,A
  0F12    26AF    CALL	0x6AF
  0F13    158A    SETB	0xA,3
  0F14    0080    LD	0x0,A
254:              if(IIC_WACK(ACK))					 return(9);
  0F15    084F    LD	A,0x4F
  0F16    273C    CALL	0x73C
  0F17    158A    SETB	0xA,3
  0F18    3A00    XORIA	0x0
  0F19    1D03    SNZB	0x3,2
  0F1A    3409    RET	0x9
255:              if(IIC_stop())				         return(10); //SOTP信号发送无效
  0F1B    2721    CALL	0x721
  0F1C    158A    SETB	0xA,3
  0F1D    3A00    XORIA	0x0
  0F1E    1D03    SNZB	0x3,2
  0F1F    340A    RET	0xA
256:              return(0);
  0F20    3400    RET	0x0
257:              }
258:              
259:              
260:              
261:              /*----------------------------------
262:              功能：
263:              连续读出数据到*BUF，地址范围，注意发出ACK的变化！最后一个字节的ACK发送是1!
264:              
265:              读流程为：
266:              0：START信号
267:              1：写Chip地址+写信号
268:              2：写要读寄存器的地址
269:              3：重复START信号
270:              4：写Chip地址+读信号
271:              5：读出数据+ADC=0;  循环R_LEN-1次
272:              6：读出数据+ADC=1; 最后一个字节响应"NO ACK"
273:              7：STOP信号
274:              ----------------------------------
275:              入口：
276:              Chip_Adds :片选地址
277:              Reg_Adds:  要读寄存器的地址
278:              R_LEN：     读长度
279:              *buf：        数据存放的指针
280:              
281:              出口：
282:              0： OK
283:              1，6:           Start信号无效
284:              2，4，7：从机拉低SCL信号线以延时，但超时！
285:              3，5，8：从机发送的应答无效，即不是0！
286:              9: WACK失败
287:              10：             STOP发送无效！
288:              ----------------------------------*/
289:              
290:              uchar IIC_ReceString(uchar Chip_Adds,uchar Reg_Adds,usint R_LEN,uchar *buf)
291:              {
292:              usint i=0;
293:              
294:              if(IIC_start())  					  return(1); //Start信号无
295:              if(IIC_Wbyte(Chip_Adds<<1))     return(2); //从机拉低SCL信号线以延时，但超时！
296:              if(IIC_RACK())				          return(3); //应答无效
297:              if(IIC_Wbyte(Reg_Adds)) 	      return(4); //从机拉低SCL信号线以延时，但超时！
298:              if(IIC_RACK()!=0) 				  return(5); //应答无效
299:              if(IIC_start())  					  return(6);	 //Start信号无					
300:              if(IIC_Wbyte((Chip_Adds<<1)+1))return(7); //从机拉低SCL信号线以延时，但超时！
301:              if(IIC_RACK())				          return(8); //应答无效
302:              R_LEN=R_LEN-1;
303:              for(i=0;i<R_LEN;i++)
304:              {*(buf+i)=IIC_Rbyte();if(IIC_WACK(0)) return(9);}
305:              
306:              *(buf+R_LEN)=IIC_Rbyte();
307:              if(IIC_WACK(1)) return(9);
308:              
309:              if(IIC_stop())	return(10); //SOTP信号发送无效
310:              return(0);
311:              }
312:              
313:              
314:              /*
315:              功能：发送Wdat到I2C
316:              写流程为：
317:              0：START信号
318:              1：写Chip地址+写信号
319:              2：写要写寄存器的地址
320:              3：写要写寄存器的内容
321:              4：STOP信号
322:              ----------------------------------
323:              入口：
324:              Chip_Adds :片选地址
325:              Reg_Adds:  要写寄存器的地址
326:              Wdat：      要写寄存器的内容
327:              
328:              出口：
329:              0： OK
330:              1:          Start信号无效
331:              2，4，6：从机拉低SCL信号线以延时，但超时！
332:              3，5，7：从机发送的应答无效，即不是0！
333:              8：         STOP发送无效！
334:              ----------------------------------*/
335:              uchar IIC_SendByte(uchar Chip_Adds,uchar Reg_Adds,uchar Wdat)
336:              {
  0E81    00CE    LD	0x4E,A
337:              if(IIC_start())				 return(1);  //Start信号无
  0E82    266B    CALL	0x66B
  0E83    158A    SETB	0xA,3
  0E84    3A00    XORIA	0x0
  0E85    1D03    SNZB	0x3,2
  0E86    3401    RET	0x1
338:              if(IIC_Wbyte(Chip_Adds<<1))  return(2); //从机拉低SCL信号线以延时，但超时！
  0E87    1003    CLRB	0x3,0
  0E88    0D4E    RLCA	0x4E
  0E89    27AF    CALL	0x7AF
  0E8A    158A    SETB	0xA,3
  0E8B    3A00    XORIA	0x0
  0E8C    1D03    SNZB	0x3,2
  0E8D    3402    RET	0x2
339:              if(IIC_RACK()!=0)		 	 return(3); //应答无效
  0E8E    2764    CALL	0x764
  0E8F    158A    SETB	0xA,3
  0E90    3A00    XORIA	0x0
  0E91    1D03    SNZB	0x3,2
  0E92    3403    RET	0x3
340:              if(IIC_Wbyte(Reg_Adds))	   	 return(4); //从机拉低SCL信号线以延时，但超时！
  0E93    084C    LD	A,0x4C
  0E94    27AF    CALL	0x7AF
  0E95    158A    SETB	0xA,3
  0E96    3A00    XORIA	0x0
  0E97    1D03    SNZB	0x3,2
  0E98    3404    RET	0x4
341:              if(IIC_RACK()!=0)		     return(5); //应答无效
  0E99    2764    CALL	0x764
  0E9A    158A    SETB	0xA,3
  0E9B    3A00    XORIA	0x0
  0E9C    1D03    SNZB	0x3,2
  0E9D    3405    RET	0x5
342:              if(IIC_Wbyte(Wdat))		  	 return(6); //从机拉低SCL信号线以延时，但超时！
  0E9E    084D    LD	A,0x4D
  0E9F    27AF    CALL	0x7AF
  0EA0    158A    SETB	0xA,3
  0EA1    3A00    XORIA	0x0
  0EA2    1D03    SNZB	0x3,2
  0EA3    3406    RET	0x6
343:              if(IIC_RACK()!=0) 		  	 return(7); //应答无效
  0EA4    2764    CALL	0x764
  0EA5    158A    SETB	0xA,3
  0EA6    3A00    XORIA	0x0
  0EA7    1D03    SNZB	0x3,2
  0EA8    3407    RET	0x7
344:              if(IIC_stop())				 return(8); //Stop信号无
  0EA9    2721    CALL	0x721
  0EAA    158A    SETB	0xA,3
  0EAB    3A00    XORIA	0x0
  0EAC    1D03    SNZB	0x3,2
  0EAD    3408    RET	0x8
345:              return(0);
  0EAE    3400    RET	0x0
346:              }
347:              
348:              
349:              /*--------------------------------
350:              功能：发送Wdat到I2C
351:              写流程为：
352:              0：START信号
353:              1：写Chip地址+写信号
354:              2：写要写寄存器的地址
355:              3：写要写寄存器的内容
356:              4：STOP信号
357:              ----------------------------------
358:              入口：
359:              Chip_Adds :片选地址
360:              Reg_Adds:  要写寄存器的地址
361:              Wdat：      要写寄存器的内容
362:              出口：
363:              0： OK
364:              1:        Start信号无效
365:              2，4，6：从机拉低SCL信号线以延时，但超时！
366:              3，5：   从机发送的应答无效，即不是0！
367:              7,8：    STOP发送无效！
368:              ----------------------------------*/
369:              
370:              uchar IIC_SendString(uchar Chip_Adds,uchar Reg_Adds,uchar R_LEN,uchar *buf)
371:              {
372:              uchar i=0;
373:              if(IIC_start())				 return(1);  //Start信号无
374:              if(IIC_Wbyte(Chip_Adds<<1))  return(2); //从机拉低SCL信号线以延时，但超时！
375:              if(IIC_RACK()!=0)		 	 return(3); //应答无效
376:              if(IIC_Wbyte(Reg_Adds))	   	 return(4); //从机拉低SCL信号线以延时，但超时！
377:              if(IIC_RACK()!=0)		     return(5); //应答无效
378:              
379:              for(i=0;i<R_LEN;i++)
380:              {
381:              	if(IIC_Wbyte(buf[i]))      return(6); //从机拉低SCL信号线以延时，但超时！
382:              	if(IIC_RACK()!=0)		
383:              	{if(IIC_stop()) return(7); return(0);}   //Stop信号无							
384:              }
385:              
386:              if(IIC_stop())				 return(8); //Stop信号无
387:              return(0);
388:              }
389:              
390:              /*
391:              
392:              uchar IIC_SendString_full(uchar Chip_Adds,uchar Reg_Adds,uchar R_LEN,uchar iD)
393:              {
394:              uchar i=0;
395:              if(IIC_start())				 return(1);  //Start信号无
396:              if(IIC_Wbyte(Chip_Adds<<1))  return(2); //从机拉低SCL信号线以延时，但超时！
397:              if(IIC_RACK()!=0)		 	 return(3); //应答无效
398:              if(IIC_Wbyte(Reg_Adds))	   	 return(4); //从机拉低SCL信号线以延时，但超时！
399:              if(IIC_RACK()!=0)		     return(5); //应答无效
400:              
401:              for(i=0;i<R_LEN;i++)
402:              {
403:              	if(IIC_Wbyte(iD))      return(6); //从机拉低SCL信号线以延时，但超时！
404:              	if(IIC_RACK()!=0)		
405:              	{if(IIC_stop()) return(7); return(0);}   //Stop信号无							
406:              }
407:              
408:              if(IIC_stop())				 return(8); //Stop信号无
409:              return(0);
410:              }
411:              */
412:              uchar IIC_CheckBusy(uchar Chip_Adds) //返回0则空闲，1正在写
413:              {
  0E58    00CC    LD	0x4C,A
414:              if(IIC_start())				 return(1);  //Start信号无
  0E59    266B    CALL	0x66B
  0E5A    158A    SETB	0xA,3
  0E5B    3A00    XORIA	0x0
  0E5C    1D03    SNZB	0x3,2
  0E5D    3401    RET	0x1
415:              if(IIC_Wbyte(Chip_Adds<<1))  return(2); //从机拉低SCL信号线以延时，但超时！
  0E5E    1003    CLRB	0x3,0
  0E5F    0D4C    RLCA	0x4C
  0E60    27AF    CALL	0x7AF
  0E61    158A    SETB	0xA,3
  0E62    3A00    XORIA	0x0
  0E63    1D03    SNZB	0x3,2
  0E64    3402    RET	0x2
416:              if(IIC_RACK()!=0)		 	 return(3); //应答无效
  0E65    2764    CALL	0x764
  0E66    158A    SETB	0xA,3
  0E67    3A00    XORIA	0x0
  0E68    1D03    SNZB	0x3,2
  0E69    3403    RET	0x3
417:              return(0);
  0E6A    3400    RET	0x0
418:              }
419:              
420:              
421:              
---- D:\Work\file\PAN\PAN2416\编译器\CMS_IDE_V1.41.03_CRC_PANCHIP\data\sources\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
5:                {
  0FDE    00F4    LD	0x74,A
  0FDF    01F6    CLR	0x76
  0FE0    0873    LD	A,0x73
  0FE1    1903    SZB	0x3,2
  0FE2    2FF7    JP	0x7F7
  0FE3    01F5    CLR	0x75
  0FE4    0AF5    INCR	0x75
  0FE5    1BF3    SZB	0x73,7
  0FE6    2FEA    JP	0x7EA
  0FE7    1003    CLRB	0x3,0
  0FE8    0DF3    RLCR	0x73
  0FE9    2FE4    JP	0x7E4
  0FEA    1003    CLRB	0x3,0
  0FEB    0DF6    RLCR	0x76
  0FEC    0873    LD	A,0x73
  0FED    0274    SUBA	0x74
  0FEE    1C03    SNZB	0x3,0
  0FEF    2FF4    JP	0x7F4
  0FF0    0873    LD	A,0x73
  0FF1    02F4    SUBR	0x74
  0FF2    1476    SETB	0x76,0
  0FF3    1003    CLRB	0x3,0
  0FF4    0CF3    RRCR	0x73
  0FF5    0BF5    SZDECR	0x75
  0FF6    2FEA    JP	0x7EA
  0FF7    0876    LD	A,0x76
  0FF8    0008    RET
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\userClock.c ----------------------------------------------------------------------
1:                
2:                #include "userClock.h"
3:                
4:                //-------------------------------------------------------------------------------------------------
5:                uint8_t  clk_flag;
6:                static uint8_t   dClkCnt0;
7:                extern volatile uint8_t clk_count;
8:                
9:                //-------------------------------------------------------------------------------------------------
10:               #define SYS_CNT_1MS  1     
11:               
12:               void getClock(void)
13:               {
14:                   uint8_t temp = 0;
15:                   clk_flag = 0;
  08AC    01BE    CLR	0x3E
16:                   
17:                   if(clk_count >= SYS_CNT_1MS)
  08AD    0879    LD	A,0x79
  08AE    1903    SZB	0x3,2
  08AF    0008    RET
18:                   {
19:                       clk_count -= SYS_CNT_1MS;
  08B0    03F9    DECR	0x79
20:                       temp = dClkCnt0;
  08B1    087A    LD	A,0x7A
  08B2    00F3    LD	0x73,A
21:                       clk_flag  = temp ^ (++dClkCnt0);
  08B3    0AFA    INCR	0x7A
  08B4    067A    XORA	0x7A
  08B5    00BE    LD	0x3E,A
  08B6    0008    RET
22:                   }
23:               }
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\timer1.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "virtual_timer.h"
3:                #include "timer1.h"
4:                #include "system.h"
5:                
6:                #define Timer1_set_time (64556)
7:                
8:                unsigned int Time1s_cot;
9:                
10:               
11:               volatile uint8_t clk_count = 0;
12:               
13:               void Timer1_Init(TIMER1_DIVIDER_e TIMER1_DIVIDER);
14:               void Timer1_start(unsigned int T_nums, unsigned char Timer1_ISR_execution_total_time);
15:               void Timer1_stop(void);
16:               void TIMER1_ISR(void);
17:               
18:               /**************************************************************************
19:               *时钟源为F = Fosc
20:               *最小定时时间 T = (1/F)*TIMER1_DIVIDER
21:               **************************************************************************/
22:               void Timer1_Init(TIMER1_DIVIDER_e TIMER1_DIVIDER)
23:               {
  088A    00F3    LD	0x73,A
24:               	T1CON = 0x00;	//TMR1GE = 0,Timer1由TMR1ON控制	TMR1CS = 0;选择内部时钟FOSC
  088B    0190    CLR	0x10
25:               	T1CON |= TIMER1_DIVIDER;	//分频设置	Bit5 Bit4 
  088C    0490    ORR	0x10
26:               	INTCON |= (0x40);	//PEIE = 1;		允许未被屏蔽的外部中断
  088D    170B    SETB	0xB,6
27:               	PIE1 |= 0x01;		//TMR1IE = 1;	开TMR1中断
  088E    1683    SETB	0x3,5
  088F    140C    SETB	0xC,0
  0890    0008    RET
28:               }
29:               
30:               /*************************************************************************************
31:               *实际时间与定时时间有偏差,可通过Timer1_ISR_execution_total_time修正，
32:               *Timer1_ISR_execution_total_time == （Timer1中断产生进入中断函数到退出中断函数执行时间）/TIMER1_DIVIDER,
33:               *定时时间 == T_nums * T
34:               *T = (1/F)*TIMER1_DIVIDER
35:               *************************************************************************************/
36:               void Timer1_start(unsigned int T_nums, unsigned char Timer1_ISR_execution_total_time)
37:               {
38:               	//Timer1_set_time = 0xffff - T_nums + Timer1_ISR_execution_total_time;
39:               	TMR1L = (unsigned char)(Timer1_set_time);
  0891    302C    LDIA	0x2C
  0892    1283    CLRB	0x3,5
  0893    008E    LD	0xE,A
40:               	TMR1H = (unsigned char)(Timer1_set_time>>8);
  0894    30FC    LDIA	0xFC
  0895    008F    LD	0xF,A
41:               	PIR1 &= ~(0x01);	// TMR1IF = 0;	
  0896    100C    CLRB	0xC,0
42:               	T1CON |= 0x01;		// TMR1ON = 1;	Start Timer0
  0897    1410    SETB	0x10,0
  0898    0008    RET
43:               }
44:               
45:               
46:               void Timer1_stop(void)
47:               {
48:               	PIE1 &= ~(0x01);		//TMR1IE = 0;	关TMR1中断
49:               	T1CON &= ~(0x01);	//TMR1ON = 0;	关定时器
50:               	PIR1 &= ~(0x01);	// TMR1IF = 0;	
51:               }
52:               
53:               
54:               
55:               
56:               //中断函数
57:               void TIMER1_ISR(void)
58:               {
59:               	T1CON &= ~(0x01);	//TMR1ON = 0;	关定时器
  08C8    1010    CLRB	0x10,0
60:               	TMR1L = (unsigned char)(Timer1_set_time);
  08C9    302C    LDIA	0x2C
  08CA    008E    LD	0xE,A
61:               	TMR1H = (unsigned char)(Timer1_set_time>>8);
  08CB    30FC    LDIA	0xFC
  08CC    008F    LD	0xF,A
62:               	
63:               	//------------------------------------------------
64:               
65:               	clk_count ++;
  08CD    0AF9    INCR	0x79
66:               	
67:               	if(Time1s_cot)
  08CE    0827    LD	A,0x27
  08CF    0426    ORA	0x26
  08D0    1903    SZB	0x3,2
  08D1    28D8    JP	0xD8
68:               	{
69:               		Time1s_cot--;
  08D2    3001    LDIA	0x1
  08D3    02A6    SUBR	0x26
  08D4    3000    LDIA	0x0
  08D5    1C03    SNZB	0x3,0
  08D6    03A7    DECR	0x27
  08D7    02A7    SUBR	0x27
70:               	}
71:               	//------------------------------------------------
72:               	PIR1 &= ~(0x01);	// TMR1IF = 0;	
  08D8    100C    CLRB	0xC,0
73:               	T1CON |= 0x01;		//TMR1ON = 1;		打开时器
  08D9    1410    SETB	0x10,0
  08DA    0008    RET
74:               }
75:               
76:               
77:               
78:               
79:               
80:               
---- D:\Work\project\遥控+接收主程序\双信道接收2\src\system.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "system.h"
3:                #include "INT0.h"
4:                #include "timer0.h"
5:                #include "timer1.h"
6:                #include "timer2.h"
7:                #include "PWM.h"
8:                #include "PORTB_interrupt.h"
9:                #include "ADC.h"
10:               
11:               void system_set_CPU_frequency(CPU_FREQUENCY_e CPU_Frequency);
12:               void clear_interrupt_flag(void);
13:               void system_to_sleep(void);
14:               void Enable_Interrupt(void);
15:               void Disable_Interrupt(void);
16:               
17:               void system_set_CPU_frequency(CPU_FREQUENCY_e CPU_Frequency)
18:               {
  087E    00F3    LD	0x73,A
19:               	OSCCON = CPU_Frequency;
  087F    1683    SETB	0x3,5
  0880    008F    LD	0xF,A
20:               	OSCTUNE = 0X00;
  0881    0190    CLR	0x10
  0882    0008    RET
21:               }
22:               
23:               void clear_interrupt_flag(void)
24:               {
25:               	PIR1&= ~0x4f;		//bit0==TMR1IF bit1==TMR2IF bit2==CCP1IF bit3==SSPIF bit6==ADIF
26:               	PIR2&= ~0x19;		//bit0==CCP2IF bit3==BCLIF bit4==EEIF
27:               	INTCON&= ~0x07;	//bit0==RBIF bit1==INTF bit2==T0IF
28:               }
29:               
30:               void system_to_sleep(void)
31:               {
32:               	asm("sleep");
33:               	asm("nop");
34:               }
35:               
36:               void Enable_Interrupt(void)
37:               {
38:               	INTCON |= 0x80;
  087C    178B    SETB	0xB,7
  087D    0008    RET
39:               }
40:               
41:               void Disable_Interrupt(void)
42:               {
43:               	INTCON &= ~(0x80);
44:               }
45:               
46:               void interrupt ISR(void)
47:               {
48:               	unsigned char inside_intterrupt_enable,peripheral_intterrupt_enable;
49:               	unsigned char inside_intterrupt_touch,peripheral_intterrupt_touch;
50:               	
51:               	//读取中断标志	
52:               	inside_intterrupt_enable = INTCON & 0x38;
  08B7    1683    SETB	0x3,5
  08B8    1303    CLRB	0x3,6
53:               	peripheral_intterrupt_enable = PIE1 & 0x43;
54:               	inside_intterrupt_touch = INTCON & 0x07;
  08B9    1283    CLRB	0x3,5
  08BA    080C    LD	A,0xC
  08BB    00F2    LD	0x72,A
  08BC    3043    LDIA	0x43
  08BD    05F2    ANDR	0x72
55:               	peripheral_intterrupt_touch = PIR1 & 0x43;
56:               	
57:               	//跳转到中断函数	
58:               //	if(inside_intterrupt_touch & PORTB_CHANGE_ISR_TOUCH) 	{		//RBIF
59:               //			PORTB_CHANGE_ISR();
60:               //	} 
61:               		
62:               //	if(inside_intterrupt_touch & INT0_ISR_TOUCH){							//INTF
63:               //			INT0_ISR();
64:               //	}
65:               		
66:               //	if(inside_intterrupt_touch & TIMER0_ISR_TOUCH) {						//T0IF	
67:               //			TIMER0_ISR();			
68:               //	}
69:               	
70:               	if(peripheral_intterrupt_touch & TIMER1_ISR_TOUCH) {				//TMR1IF
  08BE    1C72    SNZB	0x72,0
  08BF    28C1    JP	0xC1
71:               			TIMER1_ISR();
  08C0    20C8    CALL	0xC8
  08C1    0871    LD	A,0x71
  08C2    008A    LD	0xA,A
  08C3    0E70    SWAPA	0x70
  08C4    0083    LD	0x3,A
  08C5    0EFE    SWAPR	0x7E
  08C6    0E7E    SWAPA	0x7E
  08C7    0009    RETI
72:               	}
73:               		 
74:               	//if(peripheral_intterrupt_touch & TIMER2_ISR_TOUCH) {				//TMR2IF
75:               	//		TIMER2_ISR();
76:               	//}
77:               	
78:               //	if(peripheral_intterrupt_touch & ADC_ISR_TOUCH) {					//ADIF	
79:               			//ADC_ISR();
80:               //	}
81:               }
82:               
83:               
84:               
85:               
---- stringtab ------------------------------------------------------------------
  0800    1BFF    SZB	0x7F,7
  0801    280A    JP	0xA
  0802    1383    CLRB	0x3,7
  0803    187F    SZB	0x7F,0
  0804    1783    SETB	0x3,7
  0805    0800    LD	A,0x0
  0806    0A84    INCR	0x4
  0807    1903    SZB	0x3,2
  0808    0AFF    INCR	0x7F
  0809    0008    RET
  080A    3008    LDIA	0x8
  080B    008A    LD	0xA,A
  080C    0804    LD	A,0x4
  080D    0A84    INCR	0x4
  080E    0782    ADDR	0x2
  080F    3400    RET	0x0
  0810    34D6    RET	0xD6
  0811    34C5    RET	0xC5
  0812    3444    RET	0x44
  0813    3420    RET	0x20
  0814    3459    RET	0x59
  0815    34DE    RET	0xDE
  0816    34E1    RET	0xE1
  0817    348F    RET	0x8F
  0818    341B    RET	0x1B
  0819    34A5    RET	0xA5
  081A    34AF    RET	0xAF
  081B    3442    RET	0x42
  081C    347B    RET	0x7B
  081D    344E    RET	0x4E
  081E    34CD    RET	0xCD
  081F    3460    RET	0x60
  0820    34EB    RET	0xEB
  0821    3462    RET	0x62
  0822    3422    RET	0x22
  0823    3490    RET	0x90
  0824    342C    RET	0x2C
  0825    34EF    RET	0xEF
  0826    34F0    RET	0xF0
  0827    34C7    RET	0xC7
  0828    348D    RET	0x8D
  0829    34D2    RET	0xD2
  082A    3457    RET	0x57
  082B    34A1    RET	0xA1
  082C    343D    RET	0x3D
  082D    34A7    RET	0xA7
  082E    3466    RET	0x66
  082F    34B0    RET	0xB0
  0830    3475    RET	0x75
  0831    3431    RET	0x31
  0832    3411    RET	0x11
  0833    3448    RET	0x48
  0834    3496    RET	0x96
  0835    3477    RET	0x77
  0836    34F8    RET	0xF8
  0837    34E3    RET	0xE3
  0838    3446    RET	0x46
  0839    34E9    RET	0xE9
  083A    34C7    RET	0xC7
  083B    348D    RET	0x8D
  083C    34D2    RET	0xD2
  083D    3457    RET	0x57
  083E    34A1    RET	0xA1
  083F    343D    RET	0x3D
  0840    34A7    RET	0xA7
  0841    3466    RET	0x66
  0842    34B0    RET	0xB0
  0843    3475    RET	0x75
  0844    3431    RET	0x31
  0845    3411    RET	0x11
  0846    3448    RET	0x48
  0847    3496    RET	0x96
  0848    3477    RET	0x77
  0849    34F8    RET	0xF8
  084A    34E3    RET	0xE3
  084B    3446    RET	0x46
  084C    34E9    RET	0xE9
  084D    34AB    RET	0xAB
  084E    34D0    RET	0xD0
  084F    3441    RET	0x41
  0850    3492    RET	0x92
  0851    3453    RET	0x53
  0852    342A    RET	0x2A
  0853    34FC    RET	0xFC
  0854    34AB    RET	0xAB
  0855    34CE    RET	0xCE
  0856    3426    RET	0x26
  0857    340D    RET	0xD
  0858    341E    RET	0x1E
  0859    3499    RET	0x99
  085A    3478    RET	0x78
  085B    3400    RET	0x0
  085C    3422    RET	0x22
  085D    3499    RET	0x99
  085E    34DE    RET	0xDE
  085F    34FE    RET	0xFE
  0860    34AF    RET	0xAF
  0861    344B    RET	0x4B
  0862    3422    RET	0x22
  0863    340D    RET	0xD
  0864    3405    RET	0x5
  0865    3400    RET	0x0
  0866    34FA    RET	0xFA
  0867    3464    RET	0x64
  0868    3432    RET	0x32
  0869    3410    RET	0x10
  086A    3407    RET	0x7
  086B    3402    RET	0x2
  086C    3400    RET	0x0
  086D    3400    RET	0x0
  086E    3400    RET	0x0
  086F    3400    RET	0x0
  0870    3400    RET	0x0
  0871    3400    RET	0x0
  0872    3400    RET	0x0
  0873    3400    RET	0x0
  0874    342D    RET	0x2D
  0875    34D7    RET	0xD7
  0876    34B9    RET	0xB9
  0877    34CC    RET	0xCC
  0878    34CC    RET	0xCC
  0879    34CC    RET	0xCC
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280B    JP	0xB
  000B    158A    SETB	0xA,3
  000C    28FF    JP	0xFF
---- start_initialization ------------------------------------------------------------------
  0899    0064    CLRWDT
  089A    0180    CLR	0x0
  089B    0A84    INCR	0x4
  089C    0604    XORA	0x4
  089D    1903    SZB	0x3,2
  089E    3400    RET	0x0
  089F    0604    XORA	0x4
  08A0    289A    JP	0x9A
  08FF    3020    LDIA	0x20
  0900    01F7    CLR	0x77
  0901    01F8    CLR	0x78
  0902    01F9    CLR	0x79
  0903    01FA    CLR	0x7A
  0904    1383    CLRB	0x3,7
  0905    0084    LD	0x4,A
  0906    3045    LDIA	0x45
  0907    158A    SETB	0xA,3
  0908    2099    CALL	0x99
  0909    158A    SETB	0xA,3
  090A    30A0    LDIA	0xA0
  090B    0084    LD	0x4,A
  090C    30D2    LDIA	0xD2
  090D    158A    SETB	0xA,3
  090E    2099    CALL	0x99
  090F    158A    SETB	0xA,3
  0910    1683    SETB	0x3,5
  0911    3045    LDIA	0x45
  0912    00D2    LD	0x52,A
  0913    3021    LDIA	0x21
  0914    00D3    LD	0x53,A
  0915    303F    LDIA	0x3F
  0916    00D4    LD	0x54,A
  0917    302D    LDIA	0x2D
  0918    00D5    LD	0x55,A
  0919    305C    LDIA	0x5C
  091A    00D6    LD	0x56,A
  091B    3040    LDIA	0x40
  091C    00D7    LD	0x57,A
  091D    300A    LDIA	0xA
  091E    00D8    LD	0x58,A
  091F    306D    LDIA	0x6D
  0920    00D9    LD	0x59,A
  0921    3067    LDIA	0x67
  0922    00DA    LD	0x5A,A
  0923    309C    LDIA	0x9C
  0924    00DB    LD	0x5B,A
  0925    3046    LDIA	0x46
  0926    00DC    LD	0x5C,A
  0927    3016    LDIA	0x16
  0928    00DD    LD	0x5D,A
  0929    3033    LDIA	0x33
  092A    00DE    LD	0x5E,A
  092B    3027    LDIA	0x27
  092C    00DF    LD	0x5F,A
  092D    300B    LDIA	0xB
  092E    00E0    LD	0x60,A
  092F    30DF    LDIA	0xDF
  0930    00E1    LD	0x61,A
  0931    3002    LDIA	0x2
  0932    00E2    LD	0x62,A
  0933    30A5    LDIA	0xA5
  0934    00E3    LD	0x63,A
  0935    308D    LDIA	0x8D
  0936    00E4    LD	0x64,A
  0937    301E    LDIA	0x1E
  0938    00E5    LD	0x65,A
  0939    30C9    LDIA	0xC9
  093A    00E6    LD	0x66,A
  093B    306B    LDIA	0x6B
  093C    00E7    LD	0x67,A
  093D    1283    CLRB	0x3,5
  093E    30FF    LDIA	0xFF
  093F    00E8    LD	0x68,A
  0940    00E9    LD	0x69,A
  0941    3001    LDIA	0x1
  0942    00EA    LD	0x6A,A
  0943    01EB    CLR	0x6B
  0944    00EC    LD	0x6C,A
  0945    00ED    LD	0x6D,A
  0946    0183    CLR	0x3
  0947    158A    SETB	0xA,3
  0948    2CAC    JP	0x4AC
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    158A    SETB	0xA,3
  000A    28B7    JP	0xB7
---- common_function ------------------------------------------------------------------
  0002    158A    SETB	0xA,3
  0003    2DCD    JP	0x5CD
  0764    00E2    LD	0x62,A
  0765    01E3    CLR	0x63
  0766    0834    LD	A,0x34
  0767    07E2    ADDR	0x62
  0768    1803    SZB	0x3,0
  0769    0AE3    INCR	0x63
  076A    3000    LDIA	0x0
  076B    0263    SUBA	0x63
  076C    30FB    LDIA	0xFB
  076D    1903    SZB	0x3,2
  076E    0262    SUBA	0x62
  076F    1C03    SNZB	0x3,0
  0770    2F74    JP	0x774
  0771    30FA    LDIA	0xFA
  0772    00E2    LD	0x62,A
  0773    01E3    CLR	0x63
  0774    01F3    CLR	0x73
  0775    0AF3    INCR	0x73
  0776    0833    LD	A,0x33
  0777    00F4    LD	0x74,A
  0778    3000    LDIA	0x0
  0779    01F5    CLR	0x75
  077A    0008    RET
  077B    01F3    CLR	0x73
  077C    0AF3    INCR	0x73
  077D    0833    LD	A,0x33
  077E    00F4    LD	0x74,A
  077F    3000    LDIA	0x0
  0780    01F5    CLR	0x75
  0781    0008    RET
  0782    01F3    CLR	0x73
  0783    0AF3    INCR	0x73
  0784    0834    LD	A,0x34
  0785    00F4    LD	0x74,A
  0786    3001    LDIA	0x1
  0787    01F5    CLR	0x75
  0788    0008    RET
  0789    0874    LD	A,0x74
  078A    00CD    LD	0x4D,A
  078B    0873    LD	A,0x73
  078C    00CC    LD	0x4C,A
  078D    3064    LDIA	0x64
  078E    00F3    LD	0x73,A
  078F    01F4    CLR	0x74
  0790    084D    LD	A,0x4D
  0791    00F6    LD	0x76,A
  0792    084C    LD	A,0x4C
  0793    00F5    LD	0x75,A
  0794    0008    RET
  0795    0874    LD	A,0x74
  0796    00CC    LD	0x4C,A
  0797    0873    LD	A,0x73
  0798    00CB    LD	0x4B,A
  0799    3064    LDIA	0x64
  079A    00F3    LD	0x73,A
  079B    01F4    CLR	0x74
  079C    084C    LD	A,0x4C
  079D    00F6    LD	0x76,A
  079E    084B    LD	A,0x4B
  079F    00F5    LD	0x75,A
  07A0    0008    RET
  07A1    0865    LD	A,0x65
  07A2    00F3    LD	0x73,A
  07A3    3003    LDIA	0x3
  07A4    01F4    CLR	0x74
  07A5    0AF4    INCR	0x74
  07A6    00F5    LD	0x75,A
  07A7    0008    RET
  07A8    00F3    LD	0x73,A
  07A9    3003    LDIA	0x3
  07AA    01F4    CLR	0x74
  07AB    0AF4    INCR	0x74
  07AC    00F5    LD	0x75,A
  07AD    0008    RET
  07AE    3E14    ADDIA	0x14
  07AF    00D8    LD	0x58,A
  07B0    3000    LDIA	0x0
  07B1    1803    SZB	0x3,0
  07B2    3001    LDIA	0x1
  07B3    00D9    LD	0x59,A
  07B4    3000    LDIA	0x0
  07B5    0259    SUBA	0x59
  07B6    34FA    RET	0xFA
  07B7    00E5    LD	0x65,A
  07B8    00F3    LD	0x73,A
  07B9    01F4    CLR	0x74
  07BA    0AF4    INCR	0x74
  07BB    0864    LD	A,0x64
  07BC    00F5    LD	0x75,A
  07BD    0008    RET
  07BE    3A00    XORIA	0x0
  07BF    3000    LDIA	0x0
  07C0    1903    SZB	0x3,2
  07C1    3001    LDIA	0x1
  07C2    00E5    LD	0x65,A
  07C3    0008    RET
  07C4    00E5    LD	0x65,A
  07C5    00F3    LD	0x73,A
  07C6    3001    LDIA	0x1
  07C7    01F4    CLR	0x74
  07C8    0AF4    INCR	0x74
  07C9    01F5    CLR	0x75
  07CA    0AF5    INCR	0x75
  07CB    0008    RET
  07CC    00E5    LD	0x65,A
  07CD    00F3    LD	0x73,A
  07CE    3000    LDIA	0x0
  07CF    01F4    CLR	0x74
  07D0    0AF4    INCR	0x74
  07D1    01F5    CLR	0x75
  07D2    0AF5    INCR	0x75
  07D3    0008    RET
  07D4    0848    LD	A,0x48
  07D5    00C5    LD	0x45,A
  07D6    3005    LDIA	0x5
  07D7    01C6    CLR	0x46
  07D8    00C7    LD	0x47,A
  07D9    0008    RET
  07DA    00C5    LD	0x45,A
  07DB    3080    LDIA	0x80
  07DC    00C6    LD	0x46,A
  07DD    3003    LDIA	0x3
  07DE    00C7    LD	0x47,A
  07DF    0008    RET
  07E0    3003    LDIA	0x3
  07E1    01F3    CLR	0x73
  07E2    01F4    CLR	0x74
  07E3    0AF4    INCR	0x74
  07E4    00F5    LD	0x75,A
  07E5    0008    RET
  07E6    01F3    CLR	0x73
  07E7    0AF3    INCR	0x73
  07E8    00F4    LD	0x74,A
  07E9    3001    LDIA	0x1
  07EA    01F5    CLR	0x75
  07EB    0008    RET
  07EC    1283    CLRB	0x3,5
  07ED    3078    LDIA	0x78
  07EE    1303    CLRB	0x3,6
  07EF    0ACA    INCR	0x4A
  07F0    024A    SUBA	0x4A
  07F1    0008    RET
  07F2    118A    CLRB	0xA,3
  07F3    2971    JP	0x171
  07F4    118A    CLRB	0xA,3
  07F5    2975    JP	0x175
  07F6    118A    CLRB	0xA,3
  07F7    2977    JP	0x177
  07F8    118A    CLRB	0xA,3
  07F9    2979    JP	0x179
  07FA    118A    CLRB	0xA,3
  07FB    297C    JP	0x17C
  07FC    118A    CLRB	0xA,3
  07FD    297E    JP	0x17E
  0A2E    0084    LD	0x4,A
  0A2F    1383    CLRB	0x3,7
  0A30    0800    LD	A,0x0
  0A31    00F3    LD	0x73,A
  0A32    0845    LD	A,0x45
  0A33    3EA2    ADDIA	0xA2
  0A34    0084    LD	0x4,A
  0A35    0873    LD	A,0x73
  0A36    0008    RET
  0CA6    1683    SETB	0x3,5
  0CA7    1306    CLRB	0x6,6
  0CA8    1283    CLRB	0x3,5
  0CA9    3001    LDIA	0x1
  0CAA    1306    CLRB	0x6,6
  0CAB    0008    RET
  0FFB    1683    SETB	0x3,5
  0FFC    3000    LDIA	0x0
  0FFD    1715    SETB	0x15,6
  0FFE    1706    SETB	0x6,6
