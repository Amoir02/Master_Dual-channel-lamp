---- C:\item\pan2416\gitforpan2416\PAV03new\FWSWES-PAV03-SCENESWITCHES-PAN2416AV\src\main.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "system.h"
3:                #include "WDT.h"
4:                #include "rf297L.h"
5:                #include "timer1.h"
6:                #include "timer2.h"
7:                #include "PWM.h"
8:                #include "key_scan.h"
9:                #include "INT0.h"
10:               #include "ADC.h"
11:               #include "PORTB_interrupt.h"
12:               #include "recive.h"
13:               #include "iic.h"
14:               #include "e2prom.h"
15:               /**********************************************************/
16:               //1����ʹ���жϹ����У���Ҫ��systerm.c��û�õ����жϼ����ж����������ε�
17:               //2��RF�����շ���ʱ�ͻ�����ʱ���������޸Ŀ⣬��������RF���ȶ����
18:               //3����оƬ����ѡ���У���Ҫ�ѿ��Ź��رգ�����Ҫʹ�ÿ��Ź��������п���ʹ�ÿ��Ź����ɡ�
19:               //4��VPPOUTEN - ENABLE
20:               /**********************************************************/
21:               
22:               
23:               
24:               
25:               //unsigned int sleep_flag = 0;
26:               unsigned char flag_rx = 0;
27:               extern uint8_t rf_buf[18];
28:               extern uint8_t  is_factory_flag;
29:               
30:               // ID1 ID2 ID3 ID4  CHANNEL  COUNT
31:               uint8_t control_id[12][6]=
32:               {
33:               	{0,0,0,0,0,0},    //0   channel 0
34:               	{0,0,0,0,0,0},    //1   channel 0
35:               	{0,0,0,0,0,0},    //2   channel 0
36:               	{0,0,0,0,0,0},    //3   channel 1
37:               	{0,0,0,0,0,0},    //4   channel 1
38:               	{0,0,0,0,0,0},    //5   channel 1
39:               	{0,0,0,0,0,0},    //6   channel 2
40:               	{0,0,0,0,0,0},    //7   channel 2
41:               	{0,0,0,0,0,0},    //8   channel 2
42:               	{0,0,0,0,0,0},    //9   channel scene
43:               	{0,0,0,0,0,0},    //10  channel scene
44:               	{0,0,0,0,0,0}     //11  channel scene
45:               };
46:                   
47:                   
48:               // 各通道使用的资源位索引
49:               // bit7~bit6 for channel_scene;
50:               // bit5~bit4 for channel_2;
51:               // bit3~bit2 for channel_1;
52:               // bit1~bit0 for channel_0;
53:               uint8_t channel_flag    = 0;
54:               
55:               // 各通道开关状态 0-关；1-开
56:               // bit7~bit3 reverse;
57:               // bit2 for channel_2;
58:               // bit1 for channel_1;
59:               // bit0 for channel_0;
60:               uint8_t channel_status  = 0;
61:               
62:               // 各通道上电动作配置 0-上电关；1-上电开；2-上电保持
63:               // bit7~bit6 reverse;
64:               // bit5~bit4 for channel_2;
65:               // bit3~bit2 for channel_1;
66:               // bit1~bit0 for channel_0;
67:               uint8_t channel_startup = 0;
68:               
69:               extern channel_flag_stu KEY0;
70:               extern channel_flag_stu KEY1;
71:               extern channel_flag_stu KEY2;
72:               extern unsigned char sys_stute;
73:               uint8_t power_on_flag = 0;
74:               uint8_t power_on_delay_flag = 0;
75:               
76:               static void loadPowerOnEeprom(void)
77:               {
  0CF8    304E    LDIA	0x4E
78:               	power_on_delay_flag = 1;
  0CF9    01EF    CLR	0x6F
  0CFA    0AEF    INCR	0x6F
79:               	AT24C02_Read_Msg(POWER_ON_NUM, &power_on_flag, POWER_ON_NUM_SIZE);
  0CFB    00D5    LD	0x55,A
  0CFC    3073    LDIA	0x73
  0CFD    01D6    CLR	0x56
  0CFE    0AD6    INCR	0x56
  0CFF    24D2    CALL	0x4D2
  0D00    158A    SETB	0xA,3
80:               	if(power_on_flag > 3)
  0D01    3004    LDIA	0x4
  0D02    024E    SUBA	0x4E
  0D03    1803    SZB	0x3,0
81:               	{
82:               		power_on_flag = 0;
  0D04    01CE    CLR	0x4E
  0D05    304E    LDIA	0x4E
83:               	}
84:               	power_on_flag++;
  0D06    0ACE    INCR	0x4E
85:               	AT24C02_Write_Msg(POWER_ON_NUM, &power_on_flag, POWER_ON_NUM_SIZE);
  0D07    00D3    LD	0x53,A
  0D08    3073    LDIA	0x73
  0D09    01D4    CLR	0x54
  0D0A    0AD4    INCR	0x54
  0D0B    276D    CALL	0x76D
  0D0C    158A    SETB	0xA,3
86:               	if(power_on_flag == 3)
  0D0D    084E    LD	A,0x4E
  0D0E    3A03    XORIA	0x3
  0D0F    1D03    SNZB	0x3,2
  0D10    0008    RET
  0D11    304E    LDIA	0x4E
87:               	{
88:               		power_on_flag = 0;
  0D12    01CE    CLR	0x4E
89:               		AT24C02_Write_Msg(POWER_ON_NUM, &power_on_flag, POWER_ON_NUM_SIZE);
  0D13    00D3    LD	0x53,A
  0D14    3073    LDIA	0x73
  0D15    01D4    CLR	0x54
  0D16    0AD4    INCR	0x54
  0D17    276D    CALL	0x76D
  0D18    158A    SETB	0xA,3
90:               		sys_stute = MATCH_MSG;
  0D19    3002    LDIA	0x2
  0D1A    00EE    LD	0x6E,A
91:               		soft_delay_ms(200);
  0D1B    30C8    LDIA	0xC8
  0D1C    00F3    LD	0x73,A
  0D1D    01F4    CLR	0x74
  0D1E    26DD    CALL	0x6DD
  0D1F    158A    SETB	0xA,3
92:               		sledBlink();
  0D20    2ED0    JP	0x6D0
93:               	}
94:               
95:               }
96:               
97:               static loadParamsFromEeprom(void)
98:               {
99:                   unsigned char i;
100:                  unsigned char startup;
101:                  uint8_t factory_flag[2] = {0, 0};
  0C61    01DD    CLR	0x5D
  0C62    01DE    CLR	0x5E
102:                  
103:              	for(i=0; i<12; i++)
  0C63    01E0    CLR	0x60
  0C64    300C    LDIA	0xC
  0C65    0260    SUBA	0x60
  0C66    1803    SZB	0x3,0
  0C67    2C79    JP	0x479
104:              	{
105:              		AT24C02_Read_Msg(i*6, control_id[i], 6);    /**<Reads paired data stored at EEPROM*/
  0C68    3006    LDIA	0x6
  0C69    00F3    LD	0x73,A
  0C6A    0860    LD	A,0x60
  0C6B    24EA    CALL	0x4EA
  0C6C    158A    SETB	0xA,3
  0C6D    3EA8    ADDIA	0xA8
  0C6E    00D5    LD	0x55,A
  0C6F    3006    LDIA	0x6
  0C70    00D6    LD	0x56,A
  0C71    00F3    LD	0x73,A
  0C72    0860    LD	A,0x60
  0C73    24EA    CALL	0x4EA
  0C74    158A    SETB	0xA,3
  0C75    24D2    CALL	0x4D2
  0C76    158A    SETB	0xA,3
  0C77    0AE0    INCR	0x60
  0C78    2C64    JP	0x464
106:              	}
107:              	
108:              	AT24C02_Read_Msg(ADDR_CHN_FLAG, &channel_flag, 1);         /**<Reads the number of bindings per channel*/
  0C79    304B    LDIA	0x4B
  0C7A    00D5    LD	0x55,A
  0C7B    306E    LDIA	0x6E
  0C7C    01D6    CLR	0x56
  0C7D    0AD6    INCR	0x56
  0C7E    24D2    CALL	0x4D2
  0C7F    158A    SETB	0xA,3
109:                  AT24C02_Read_Msg(ADDR_CHN_STATUS, &channel_status, 1);
  0C80    304D    LDIA	0x4D
  0C81    00D5    LD	0x55,A
  0C82    306F    LDIA	0x6F
  0C83    01D6    CLR	0x56
  0C84    0AD6    INCR	0x56
  0C85    24D2    CALL	0x4D2
  0C86    158A    SETB	0xA,3
110:                  AT24C02_Read_Msg(ADDR_CHN_STARTUP, &channel_startup, 1);
  0C87    304C    LDIA	0x4C
  0C88    00D5    LD	0x55,A
  0C89    3070    LDIA	0x70
  0C8A    01D6    CLR	0x56
  0C8B    0AD6    INCR	0x56
  0C8C    24D2    CALL	0x4D2
  0C8D    158A    SETB	0xA,3
111:              	AT24C02_Read_Msg(ADDR_NOT_FACTORY_FLAG, factory_flag, NOT_FACTORY_FLAG_SIZE);
  0C8E    305D    LDIA	0x5D
  0C8F    00D5    LD	0x55,A
  0C90    3002    LDIA	0x2
  0C91    00D6    LD	0x56,A
  0C92    3071    LDIA	0x71
  0C93    24D2    CALL	0x4D2
  0C94    158A    SETB	0xA,3
112:              
113:                  if (NOT_FACTORY_FLAG0 == factory_flag[0] && NOT_FACTORY_FLAG1 == factory_flag[1])
  0C95    085D    LD	A,0x5D
  0C96    3A5E    XORIA	0x5E
  0C97    1D03    SNZB	0x3,2
  0C98    2C9F    JP	0x49F
  0C99    085E    LD	A,0x5E
  0C9A    3AF6    XORIA	0xF6
  0C9B    1D03    SNZB	0x3,2
  0C9C    2C9F    JP	0x49F
114:                  {
115:                      is_factory_flag = 0;
  0C9D    01EC    CLR	0x6C
116:                  }
  0C9E    2CA1    JP	0x4A1
117:                  else
118:                  {
119:                      is_factory_flag = 1;
  0C9F    01EC    CLR	0x6C
  0CA0    0AEC    INCR	0x6C
120:                  }
121:              	//for( i=0; i<12; i++ )
122:              	//{
123:              	//	if(channel_flag[i] >= 4)
124:              	//	{
125:              	//		channel_flag[i] = 0;  /**<Determines if the number of bindings per channel exceeds 4 groups*/
126:              	//	}
127:              	//}
128:              
129:              	for(i = 0; i < CHANNEL_NUM; i++)
  0CA1    01E0    CLR	0x60
  0CA2    3003    LDIA	0x3
  0CA3    0260    SUBA	0x60
  0CA4    1803    SZB	0x3,0
  0CA5    0008    RET
130:              	{
131:              	    startup = getChnStartupConfig(channel_startup, i);
  0CA6    084C    LD	A,0x4C
  0CA7    00DB    LD	0x5B,A
  0CA8    0860    LD	A,0x60
  0CA9    00DC    LD	0x5C,A
  0CAA    075C    ADDA	0x5C
  0CAB    3E01    ADDIA	0x1
  0CAC    2CAF    JP	0x4AF
  0CAD    1003    CLRB	0x3,0
  0CAE    0CDB    RRCR	0x5B
  0CAF    3EFF    ADDIA	0xFF
  0CB0    1D03    SNZB	0x3,2
  0CB1    2CAD    JP	0x4AD
  0CB2    085B    LD	A,0x5B
  0CB3    00DF    LD	0x5F,A
  0CB4    3003    LDIA	0x3
  0CB5    05DF    ANDR	0x5F
132:              		if (STARTUP_OFF == startup)
  0CB6    0B5F    SZDECA	0x5F
  0CB7    2CB9    JP	0x4B9
  0CB8    2CC8    JP	0x4C8
133:              		{
134:              		    setChannelStatus(i, CHANNEL_OFF);
135:              		}
136:              		else if (STARTUP_STAY == startup)
  0CB9    085F    LD	A,0x5F
  0CBA    3A02    XORIA	0x2
  0CBB    1D03    SNZB	0x3,2
  0CBC    2CCA    JP	0x4CA
137:              		{
138:              		    if (CHANNEL_OFF == getChannelStatus(channel_status, i))
  0CBD    084D    LD	A,0x4D
  0CBE    00DB    LD	0x5B,A
  0CBF    0A60    INCA	0x60
  0CC0    2CC3    JP	0x4C3
  0CC1    1003    CLRB	0x3,0
  0CC2    0CDB    RRCR	0x5B
  0CC3    3EFF    ADDIA	0xFF
  0CC4    1D03    SNZB	0x3,2
  0CC5    2CC1    JP	0x4C1
  0CC6    185B    SZB	0x5B,0
  0CC7    2CCB    JP	0x4CB
139:              		    {
140:              		        setChannelStatus(i, CHANNEL_OFF);
  0CC8    01D8    CLR	0x58
  0CC9    2CCD    JP	0x4CD
141:              		    }
142:              		    else
143:              		    {
144:              		        setChannelStatus(i, CHANNEL_ON);
145:              		    }
146:              		}
147:              		else if (STARTUP_ON == startup)
  0CCA    08DF    TESTZ	0x5F
148:              		{
149:              		    setChannelStatus(i, CHANNEL_ON);
150:              		}
151:              
152:              #if (FACTORY_STARTUP == FACTORY_STARTUP_ON)
153:                      
154:                      else
155:                      {
156:                          setChannelStatus(i, CHANNEL_ON);
  0CCB    01D8    CLR	0x58
  0CCC    0AD8    INCR	0x58
  0CCD    0860    LD	A,0x60
  0CCE    26F9    CALL	0x6F9
  0CCF    158A    SETB	0xA,3
  0CD0    0AE0    INCR	0x60
  0CD1    2CA2    JP	0x4A2
157:                      }
158:              #else
159:                      else
160:                      {
161:                          setChannelStatus(i, CHANNEL_OFF);
162:                      }
163:              #endif
164:              		
165:              	}
166:              }
167:              
168:              
169:              void main()
170:              {
171:              	system_set_CPU_frequency(CPU_FREQUENCY_8M);
  07A1    3071    LDIA	0x71
  07A2    158A    SETB	0xA,3
  07A3    2114    CALL	0x114
  07A4    118A    CLRB	0xA,3
172:              	/**IO initialization**/
173:              	TRISC = 0x00;
  07A5    0187    CLR	0x7
174:              	TRISB |= 0x70;
  07A6    3070    LDIA	0x70
  07A7    0486    ORR	0x6
175:              
176:              	RC0 = 1;            /**<Turn off the lights*/
  07A8    1283    CLRB	0x3,5
  07A9    1407    SETB	0x7,0
177:              	loadPowerOnEeprom();
  07AA    158A    SETB	0xA,3
  07AB    24F8    CALL	0x4F8
  07AC    118A    CLRB	0xA,3
178:              
179:              	soft_delay_ms(500);
  07AD    30F4    LDIA	0xF4
  07AE    00F3    LD	0x73,A
  07AF    3001    LDIA	0x1
  07B0    00F4    LD	0x74,A
  07B1    158A    SETB	0xA,3
  07B2    26DD    CALL	0x6DD
  07B3    118A    CLRB	0xA,3
  07B4    0000    NOP
180:              	asm("nop");
181:              	
182:              	
183:              	IIC_Init();       /**<IIC initialization*/
  07B5    158A    SETB	0xA,3
  07B6    211F    CALL	0x11F
  07B7    118A    CLRB	0xA,3
184:              	key_Init();       /**<Key initialization*/
  07B8    158A    SETB	0xA,3
  07B9    2119    CALL	0x119
  07BA    118A    CLRB	0xA,3
185:              	RF_Init();        /**<RF initialization*/
  07BB    158A    SETB	0xA,3
  07BC    234A    CALL	0x34A
  07BD    118A    CLRB	0xA,3
186:              	RF_Set_RxMode();  /**<Set to receive mode*/
  07BE    158A    SETB	0xA,3
  07BF    2413    CALL	0x413
  07C0    118A    CLRB	0xA,3
187:              
188:              	Timer1_Init(TIMER1_DIV_8);   /**<Timer is initialized and set to 8 frequency division*/
  07C1    3030    LDIA	0x30
  07C2    158A    SETB	0xA,3
  07C3    2126    CALL	0x126
  07C4    118A    CLRB	0xA,3
189:              	Timer1_start(10000, 0);       /**< 10ms*/
  07C5    3010    LDIA	0x10
  07C6    00F3    LD	0x73,A
  07C7    3027    LDIA	0x27
  07C8    00F4    LD	0x74,A
  07C9    01F5    CLR	0x75
  07CA    118A    CLRB	0xA,3
  07CB    27F7    CALL	0x7F7
  07CC    118A    CLRB	0xA,3
190:              
191:              	loadParamsFromEeprom();
  07CD    158A    SETB	0xA,3
  07CE    2461    CALL	0x461
  07CF    118A    CLRB	0xA,3
192:              	Enable_Interrupt();                           /**<The interrupt enable*/
  07D0    118A    CLRB	0xA,3
  07D1    2002    CALL	0x2
  07D2    118A    CLRB	0xA,3
193:              	// sledBlink();
194:              	
195:              
196:              	while(1)
197:              	{	
198:              		channel_set(0, KEY0.channel_status);	  /**<Channel 0 output state Settings*/
  07D3    0820    LD	A,0x20
  07D4    00F3    LD	0x73,A
  07D5    3000    LDIA	0x0
  07D6    158A    SETB	0xA,3
  07D7    218A    CALL	0x18A
  07D8    118A    CLRB	0xA,3
199:              		channel_set(1, KEY1.channel_status);	  /**<Channel 1 output state Settings*/
  07D9    0823    LD	A,0x23
  07DA    00F3    LD	0x73,A
  07DB    3001    LDIA	0x1
  07DC    158A    SETB	0xA,3
  07DD    218A    CALL	0x18A
  07DE    118A    CLRB	0xA,3
200:              		channel_set(2, KEY2.channel_status);	  /**<Channel 2 output state Settings*/
  07DF    0826    LD	A,0x26
  07E0    00F3    LD	0x73,A
  07E1    3002    LDIA	0x2
  07E2    158A    SETB	0xA,3
  07E3    218A    CALL	0x18A
  07E4    118A    CLRB	0xA,3
201:              
202:              		recive_task();		/**<2.4g receive tasks*/
  07E5    158A    SETB	0xA,3
  07E6    21BF    CALL	0x1BF
  07E7    118A    CLRB	0xA,3
203:              
204:              		key_value_read();	/**<Key reading task*/
  07E8    158A    SETB	0xA,3
  07E9    25D3    CALL	0x5D3
  07EA    118A    CLRB	0xA,3
205:              
206:              		delay_task();       /**<Delayed task execution*/
  07EB    158A    SETB	0xA,3
  07EC    2521    CALL	0x521
  07ED    118A    CLRB	0xA,3
  07EE    2FD3    JP	0x7D3
207:              	}
208:              }
209:              
---- C:\item\pan2416\gitforpan2416\PAV03new\FWSWES-PAV03-SCENESWITCHES-PAN2416AV\src\recive.c ----------------------------------------------------------------------
1:                #include "recive.h"
2:                #include "rf297L.h"
3:                #include "e2prom.h"
4:                #include "delay.h"
5:                #include "key_scan.h"
6:                #include "system.h"
7:                
8:                #define CMD_SWITCH (0x10)
9:                #define CMD_SWITCH_COMPAT (0x11)
10:               #define CMD_SCENE_EXE (0x20)
11:               #define CMD_SCENE_SET (0x21)
12:               #define CMD_STARTUP_CONFIG (0x30)
13:               
14:               #define SCENE_NUM (6)
15:               #define SCENE_ACTION_OFF (0)
16:               #define SCENE_ACTION_ON  (1)
17:               
18:               #define FACTORY_ADDR0_VALUE      0x11
19:               #define FACTORY_ADDR1_VALUE      0x56
20:               #define FACTORY_ADDR2_VALUE      0x32
21:               #define FACTORY_ADDR3_VALUE      0xF9
22:               
23:               const unsigned char crc_2_4G_lib[21] = {0xc7 ,0x8d ,0xd2 ,0x57 ,0xa1 ,0x3d ,0xa7 ,0x66 ,0xb0 ,0x75 ,0x31 ,0x11 ,0x48 ,0x96 ,0x77 ,0xf8 ,0xe3 ,0x46 ,0xe9,0xab ,0xd0 };
24:               const unsigned char crc_lab[16] = {0x41,0x92,0x53,0x2A,0xFC,0xAB,0xCE,0x26,0x0D,0x1E,0x99,0x78,0x00,0x22,0x99,0xDE};
25:               const unsigned char ble_crc_38[42] = {
26:               		0xD6, 0xC5, 0x44, 0x20, 0x59,
27:               		0xDE, 0xE1, 0x8F, 0x1B, 0xA5,
28:               		0xAF, 0x42, 0x7B, 0x4E, 0xCD,
29:               		0x60, 0xEB, 0x62, 0x22, 0x90,
30:               		0x2C, 0xEF, 0xF0, 0xC7, 0x8D,
31:               		0xD2, 0x57, 0xA1, 0x3D, 0xA7,
32:               		0x66, 0xB0, 0x75, 0x31, 0x11,
33:               		0x48, 0x96, 0x77 ,0xF8, 0xE3,
34:               		0x46, 0xE9
35:               	};
36:               
37:               
38:               
39:               uint8_t rf_buf[18];
40:               unsigned char sys_stute = RX_MSG;  /**<Default power on pairing*/
41:               uint16_t flag_5s_add = 0;
42:               extern uint8_t power_on_flag;
43:               
44:               extern uint8_t control_id[12][6];
45:               extern uint8_t channel_flag;
46:               extern unsigned char key_long_flag;
47:               extern channel_flag_stu KEY0;
48:               extern channel_flag_stu KEY1;
49:               extern channel_flag_stu KEY2;
50:               uint8_t channel_delay[3] = {0,0,0};
51:               extern uint16_t flag_5min_add;
52:               
53:               extern unsigned char  KEY0_FLAG;
54:               extern unsigned char  KEY1_FLAG;
55:               extern unsigned char  KEY2_FLAG;
56:               static uint8_t delay_flag = 0;
57:               
58:               extern uint8_t channel_status;
59:               extern uint8_t channel_startup;
60:               uint8_t  is_factory_flag = 1;
61:               extern uint8_t power_on_delay_flag;
62:               
63:               
64:               unsigned short UpdateCRC(unsigned char *CRC_input, unsigned int len)
65:               {
  0AEC    00D2    LD	0x52,A
  0AED    3055    LDIA	0x55
66:                   unsigned char i,k = 0; 
  0AEE    01D3    CLR	0x53
67:                   unsigned short CRC_acc = 0x5555;
  0AEF    00D5    LD	0x55,A
  0AF0    00D6    LD	0x56,A
68:                   #define POLY_  0x1021
69:                   while (len--)
  0AF1    3001    LDIA	0x1
  0AF2    02F3    SUBR	0x73
  0AF3    3000    LDIA	0x0
  0AF4    1C03    SNZB	0x3,0
  0AF5    03F4    DECR	0x74
  0AF6    02F4    SUBR	0x74
  0AF7    0A73    INCA	0x73
  0AF8    1903    SZB	0x3,2
  0AF9    0A74    INCA	0x74
  0AFA    1903    SZB	0x3,2
  0AFB    2B1E    JP	0x31E
70:                   {
71:                       CRC_acc = CRC_acc ^ (CRC_input[k++] << 8);
  0AFC    0853    LD	A,0x53
  0AFD    0752    ADDA	0x52
  0AFE    00CF    LD	0x4F,A
  0AFF    0084    LD	0x4,A
  0B00    0800    LD	A,0x0
  0B01    00D0    LD	0x50,A
  0B02    01D1    CLR	0x51
  0B03    00D1    LD	0x51,A
  0B04    01D0    CLR	0x50
  0B05    0850    LD	A,0x50
  0B06    06D5    XORR	0x55
  0B07    0851    LD	A,0x51
  0B08    06D6    XORR	0x56
  0B09    0AD3    INCR	0x53
72:                       
73:                       for (i = 0; i < 8; i++)
  0B0A    01D4    CLR	0x54
74:                       {
75:                           if ((CRC_acc & 0x8000) == 0x8000)
  0B0B    1FD6    SNZB	0x56,7
  0B0C    2B15    JP	0x315
  0B0D    3021    LDIA	0x21
76:                           {
77:                               CRC_acc = CRC_acc << 1;
  0B0E    1003    CLRB	0x3,0
  0B0F    0DD5    RLCR	0x55
  0B10    0DD6    RLCR	0x56
78:                               CRC_acc ^= POLY_;
  0B11    06D5    XORR	0x55
  0B12    3010    LDIA	0x10
  0B13    06D6    XORR	0x56
79:                           }
  0B14    2B18    JP	0x318
80:                           else
81:                           {
82:                               CRC_acc = CRC_acc << 1;
  0B15    1003    CLRB	0x3,0
  0B16    0DD5    RLCR	0x55
  0B17    0DD6    RLCR	0x56
  0B18    3008    LDIA	0x8
  0B19    0AD4    INCR	0x54
  0B1A    0254    SUBA	0x54
  0B1B    1803    SZB	0x3,0
  0B1C    2AF1    JP	0x2F1
  0B1D    2B0B    JP	0x30B
83:                           }
84:                       }
85:                   }
86:                   return CRC_acc;
  0B1E    0856    LD	A,0x56
  0B1F    00F4    LD	0x74,A
  0B20    0855    LD	A,0x55
  0B21    00F3    LD	0x73,A
  0B22    0008    RET
87:               }
88:               
89:               
90:               
91:               uint8_t rx_data(void)
92:               {
  0A5D    3012    LDIA	0x12
93:               	uint8_t rx_flag = 0;
  0A5E    01DD    CLR	0x5D
94:               	uint8_t rand = 0;
95:               	uint8_t i = 0;
  0A5F    01DE    CLR	0x5E
96:               	uint16_t crc16 = 0; 
  0A60    01DA    CLR	0x5A
  0A61    01DB    CLR	0x5B
97:               
98:               	if(RF_RxData(rf_buf,18))
  0A62    00D3    LD	0x53,A
  0A63    3039    LDIA	0x39
  0A64    2323    CALL	0x323
  0A65    158A    SETB	0xA,3
  0A66    3A00    XORIA	0x0
  0A67    1903    SZB	0x3,2
  0A68    2AEA    JP	0x2EA
99:               	{
100:              		for(i = 0; i < 18; i++)
  0A69    01DE    CLR	0x5E
101:              			{
102:              				rf_buf[i] = rf_buf[i] ^ crc_2_4G_lib[3+i] ^ ble_crc_38[21+i];
  0A6A    085E    LD	A,0x5E
  0A6B    3E16    ADDIA	0x16
  0A6C    0084    LD	0x4,A
  0A6D    158A    SETB	0xA,3
  0A6E    2000    CALL	0x0
  0A6F    158A    SETB	0xA,3
  0A70    00D7    LD	0x57,A
  0A71    085E    LD	A,0x5E
  0A72    3E2E    ADDIA	0x2E
  0A73    0084    LD	0x4,A
  0A74    158A    SETB	0xA,3
  0A75    2000    CALL	0x0
  0A76    158A    SETB	0xA,3
  0A77    00D8    LD	0x58,A
  0A78    085E    LD	A,0x5E
  0A79    3E39    ADDIA	0x39
  0A7A    0084    LD	0x4,A
  0A7B    1383    CLRB	0x3,7
  0A7C    0800    LD	A,0x0
  0A7D    0658    XORA	0x58
  0A7E    0657    XORA	0x57
  0A7F    00D9    LD	0x59,A
  0A80    085E    LD	A,0x5E
  0A81    3E39    ADDIA	0x39
  0A82    0084    LD	0x4,A
  0A83    0859    LD	A,0x59
  0A84    0080    LD	0x0,A
  0A85    3012    LDIA	0x12
  0A86    0ADE    INCR	0x5E
  0A87    025E    SUBA	0x5E
  0A88    1C03    SNZB	0x3,0
  0A89    2A6A    JP	0x26A
103:              			}
104:              		crc16 = rf_buf[16] + rf_buf[17] * 256;
  0A8A    084A    LD	A,0x4A
  0A8B    00D7    LD	0x57,A
  0A8C    01D8    CLR	0x58
  0A8D    00D8    LD	0x58,A
  0A8E    01D7    CLR	0x57
  0A8F    0849    LD	A,0x49
  0A90    0757    ADDA	0x57
  0A91    00DA    LD	0x5A,A
  0A92    0858    LD	A,0x58
  0A93    1803    SZB	0x3,0
  0A94    0A58    INCA	0x58
  0A95    00DB    LD	0x5B,A
105:              		for(i = 0; i < 16; i++)
  0A96    01DE    CLR	0x5E
106:              			{
107:              				rf_buf[i] = rf_buf[i] ^ crc_lab[i];
  0A97    085E    LD	A,0x5E
  0A98    3E40    ADDIA	0x40
  0A99    0084    LD	0x4,A
  0A9A    158A    SETB	0xA,3
  0A9B    2000    CALL	0x0
  0A9C    158A    SETB	0xA,3
  0A9D    00D7    LD	0x57,A
  0A9E    085E    LD	A,0x5E
  0A9F    3E39    ADDIA	0x39
  0AA0    0084    LD	0x4,A
  0AA1    0800    LD	A,0x0
  0AA2    0657    XORA	0x57
  0AA3    00D8    LD	0x58,A
  0AA4    085E    LD	A,0x5E
  0AA5    3E39    ADDIA	0x39
  0AA6    0084    LD	0x4,A
  0AA7    0858    LD	A,0x58
  0AA8    0080    LD	0x0,A
  0AA9    3010    LDIA	0x10
  0AAA    0ADE    INCR	0x5E
  0AAB    025E    SUBA	0x5E
  0AAC    1C03    SNZB	0x3,0
  0AAD    2A97    JP	0x297
108:              			}
109:              		rand = rf_buf[15];
  0AAE    0848    LD	A,0x48
  0AAF    00DC    LD	0x5C,A
110:              		for(i = 7; i < 15; i++)
  0AB0    3007    LDIA	0x7
  0AB1    00DE    LD	0x5E,A
111:              			{
112:              				rf_buf[i] ^= rand;
  0AB2    085E    LD	A,0x5E
  0AB3    3E39    ADDIA	0x39
  0AB4    0084    LD	0x4,A
  0AB5    085C    LD	A,0x5C
  0AB6    0680    XORR	0x0
  0AB7    300F    LDIA	0xF
  0AB8    0ADE    INCR	0x5E
  0AB9    025E    SUBA	0x5E
  0ABA    1C03    SNZB	0x3,0
  0ABB    2AB2    JP	0x2B2
113:              			}
114:              		if(crc16 == UpdateCRC(rf_buf,16) )
  0ABC    3010    LDIA	0x10
  0ABD    00F3    LD	0x73,A
  0ABE    3039    LDIA	0x39
  0ABF    01F4    CLR	0x74
  0AC0    22EC    CALL	0x2EC
  0AC1    158A    SETB	0xA,3
  0AC2    085B    LD	A,0x5B
  0AC3    0674    XORA	0x74
  0AC4    1D03    SNZB	0x3,2
  0AC5    2AC8    JP	0x2C8
  0AC6    085A    LD	A,0x5A
  0AC7    0673    XORA	0x73
  0AC8    1D03    SNZB	0x3,2
  0AC9    2AEA    JP	0x2EA
115:              			{
116:              				if((rf_buf[3] == 0) && (rf_buf[4] == 0) && (rf_buf[5] == 0) && (rf_buf[6] == 0))
  0ACA    08BC    TESTZ	0x3C
  0ACB    1D03    SNZB	0x3,2
  0ACC    2AD8    JP	0x2D8
  0ACD    08BD    TESTZ	0x3D
  0ACE    1D03    SNZB	0x3,2
  0ACF    2AD8    JP	0x2D8
  0AD0    08BE    TESTZ	0x3E
  0AD1    1D03    SNZB	0x3,2
  0AD2    2AD8    JP	0x2D8
  0AD3    08BF    TESTZ	0x3F
  0AD4    1D03    SNZB	0x3,2
  0AD5    2AD8    JP	0x2D8
117:              					{
118:              						rx_flag=0;
  0AD6    01DD    CLR	0x5D
119:              					}
  0AD7    2AEA    JP	0x2EA
120:              				else if((rf_buf[3] == 0xff) && (rf_buf[4] == 0xff) && (rf_buf[5] == 0xff) && (rf_buf[6] == 0xff))
  0AD8    083C    LD	A,0x3C
  0AD9    3AFF    XORIA	0xFF
  0ADA    1D03    SNZB	0x3,2
  0ADB    2AE8    JP	0x2E8
  0ADC    083D    LD	A,0x3D
  0ADD    3AFF    XORIA	0xFF
  0ADE    1D03    SNZB	0x3,2
  0ADF    2AE8    JP	0x2E8
  0AE0    083E    LD	A,0x3E
  0AE1    3AFF    XORIA	0xFF
  0AE2    1D03    SNZB	0x3,2
  0AE3    2AE8    JP	0x2E8
  0AE4    083F    LD	A,0x3F
  0AE5    3AFF    XORIA	0xFF
  0AE6    1903    SZB	0x3,2
  0AE7    2AD6    JP	0x2D6
121:              					{
122:              						rx_flag = 0;
123:              					}
124:              				else
125:              					rx_flag = 1;
  0AE8    01DD    CLR	0x5D
  0AE9    0ADD    INCR	0x5D
126:              			}
127:              		
128:              	}
129:              	return rx_flag;
  0AEA    085D    LD	A,0x5D
  0AEB    0008    RET
130:              }
131:              
132:              static uint8_t debug = 0;
133:              extern unsigned char match_channel_flag;
134:              void recive_task(void)
135:              {
136:              	uint8_t i = 0;
  09BF    01EB    CLR	0x6B
137:              	//uint8_t cmd = 0;
138:              	uint8_t match_flag = 0;
  09C0    01E9    CLR	0x69
139:              	uint8_t flag = 0;
  09C1    01EA    CLR	0x6A
140:              	unsigned char msg[6];
141:              	
142:              	switch(sys_stute)
  09C2    086E    LD	A,0x6E
  09C3    3A01    XORIA	0x1
  09C4    118A    CLRB	0xA,3
  09C5    1903    SZB	0x3,2
  09C6    2B95    JP	0x395
  09C7    158A    SETB	0xA,3
  09C8    3A03    XORIA	0x3
  09C9    1903    SZB	0x3,2
  09CA    2A5B    JP	0x25B
  09CB    3A01    XORIA	0x1
  09CC    1903    SZB	0x3,2
  09CD    29D0    JP	0x1D0
  09CE    118A    CLRB	0xA,3
  09CF    2FA0    JP	0x7A0
143:                  {
144:                  	case CLEAN_MSG:    /**<Clear pairs*/
145:                  	{
146:                  		LED_OFF;
  09D0    1683    SETB	0x3,5
  09D1    1007    CLRB	0x7,0
  09D2    1283    CLRB	0x3,5
  09D3    1407    SETB	0x7,0
147:                  		if(key_long_flag == 0x11)
  09D4    0837    LD	A,0x37
  09D5    3A11    XORIA	0x11
  09D6    1D03    SNZB	0x3,2
  09D7    29ED    JP	0x1ED
148:                  		{
149:                  			key_long_flag = 0;
  09D8    01B7    CLR	0x37
150:                  			KEY0.key_flag_5s = 0;					/**<Reset long press marker*/
  09D9    01A2    CLR	0x22
151:                  			for(i = 0; i < 18; i++)					/**<Each channel can bind 3 groups, each group can store 6 data, 3*6=18*/
  09DA    01EB    CLR	0x6B
  09DB    3012    LDIA	0x12
  09DC    026B    SUBA	0x6B
  09DD    1803    SZB	0x3,0
  09DE    2A21    JP	0x221
152:              				{
153:              					AT24C02_Write_Byte(i + 0, 0xff);	/**<The channel 0 storage area writes 0xFF to override the original data*/
  09DF    30FF    LDIA	0xFF
  09E0    00CF    LD	0x4F,A
  09E1    086B    LD	A,0x6B
  09E2    158A    SETB	0xA,3
  09E3    2786    CALL	0x786
  09E4    158A    SETB	0xA,3
154:              					soft_delay_ms(1);
  09E5    01F3    CLR	0x73
  09E6    0AF3    INCR	0x73
  09E7    01F4    CLR	0x74
  09E8    158A    SETB	0xA,3
  09E9    26DD    CALL	0x6DD
  09EA    158A    SETB	0xA,3
  09EB    0AEB    INCR	0x6B
  09EC    29DB    JP	0x1DB
155:              				}
156:                  		}
157:                  		else if(key_long_flag == 0x21)
  09ED    0837    LD	A,0x37
  09EE    3A21    XORIA	0x21
  09EF    1D03    SNZB	0x3,2
  09F0    2A07    JP	0x207
  09F1    3012    LDIA	0x12
158:                  		{
159:                  			key_long_flag = 0;
  09F2    01B7    CLR	0x37
160:                  			KEY1.key_flag_5s = 0;						/**<Reset long press marker*/
  09F3    01A5    CLR	0x25
161:                  			for(i = 18; i < 36; i++)						/**<Each channel can bind 3 groups, each group can store 6 data, 3*6=18*/
  09F4    00EB    LD	0x6B,A
  09F5    3024    LDIA	0x24
  09F6    026B    SUBA	0x6B
  09F7    1803    SZB	0x3,0
  09F8    2A21    JP	0x221
162:                  			{
163:                  				AT24C02_Write_Byte(i, 0xff);	/**<The channel 1 storage area writes 0xFF to override the original data*/
  09F9    30FF    LDIA	0xFF
  09FA    00CF    LD	0x4F,A
  09FB    086B    LD	A,0x6B
  09FC    158A    SETB	0xA,3
  09FD    2786    CALL	0x786
  09FE    158A    SETB	0xA,3
164:                  				soft_delay_ms(1);
  09FF    01F3    CLR	0x73
  0A00    0AF3    INCR	0x73
  0A01    01F4    CLR	0x74
  0A02    158A    SETB	0xA,3
  0A03    26DD    CALL	0x6DD
  0A04    158A    SETB	0xA,3
  0A05    0AEB    INCR	0x6B
  0A06    29F5    JP	0x1F5
165:                  			}
166:                  		}
167:                  		else if(key_long_flag == 0x41)
  0A07    0837    LD	A,0x37
  0A08    3A41    XORIA	0x41
  0A09    1D03    SNZB	0x3,2
  0A0A    2A21    JP	0x221
  0A0B    3024    LDIA	0x24
168:                  		{
169:                  			key_long_flag = 0;
  0A0C    01B7    CLR	0x37
170:                  			KEY2.key_flag_5s = 0;						/**<Reset long press marker*/
  0A0D    01A8    CLR	0x28
171:                  			for(i = 36; i < 54; i++)						/**<Each channel can bind 3 groups, each group can store 6 data, 3*6=18*/
  0A0E    00EB    LD	0x6B,A
  0A0F    3036    LDIA	0x36
  0A10    026B    SUBA	0x6B
  0A11    1803    SZB	0x3,0
  0A12    2A21    JP	0x221
172:                  			{
173:                  				AT24C02_Write_Byte(i, 0xff);	/**<The channel 2 storage area writes 0xFF to override the original data*/
  0A13    30FF    LDIA	0xFF
  0A14    00CF    LD	0x4F,A
  0A15    086B    LD	A,0x6B
  0A16    158A    SETB	0xA,3
  0A17    2786    CALL	0x786
  0A18    158A    SETB	0xA,3
174:                  				soft_delay_ms(1);
  0A19    01F3    CLR	0x73
  0A1A    0AF3    INCR	0x73
  0A1B    01F4    CLR	0x74
  0A1C    158A    SETB	0xA,3
  0A1D    26DD    CALL	0x6DD
  0A1E    158A    SETB	0xA,3
  0A1F    0AEB    INCR	0x6B
  0A20    2A0F    JP	0x20F
175:                  			}
176:                  		}
177:              
178:                          for(i = 54; i < 72; i++)					/**<Each channel can bind 3 groups, each group can store 6 data, 3*6=18*/
  0A21    3036    LDIA	0x36
  0A22    00EB    LD	0x6B,A
  0A23    3048    LDIA	0x48
  0A24    026B    SUBA	0x6B
  0A25    1803    SZB	0x3,0
  0A26    2A34    JP	0x234
179:              			{
180:              				AT24C02_Write_Byte(i, 0x00);	/**<The channel_scene storage area writes 0x00 to override the original data*/
  0A27    01CF    CLR	0x4F
  0A28    086B    LD	A,0x6B
  0A29    158A    SETB	0xA,3
  0A2A    2786    CALL	0x786
  0A2B    158A    SETB	0xA,3
181:              				soft_delay_ms(1);
  0A2C    01F3    CLR	0x73
  0A2D    0AF3    INCR	0x73
  0A2E    01F4    CLR	0x74
  0A2F    158A    SETB	0xA,3
  0A30    26DD    CALL	0x6DD
  0A31    158A    SETB	0xA,3
  0A32    0AEB    INCR	0x6B
  0A33    2A23    JP	0x223
182:              			}
183:                  		
184:                  		for(i = 0; i < 12; i++)
  0A34    01EB    CLR	0x6B
  0A35    300C    LDIA	0xC
  0A36    026B    SUBA	0x6B
  0A37    1803    SZB	0x3,0
  0A38    2A4D    JP	0x24D
185:                  		{
186:                  			AT24C02_Read_Msg(i * 6, control_id[i], 6);	/**<Reads paired data stored at EEPROM*/
  0A39    3006    LDIA	0x6
  0A3A    00F3    LD	0x73,A
  0A3B    086B    LD	A,0x6B
  0A3C    158A    SETB	0xA,3
  0A3D    24EA    CALL	0x4EA
  0A3E    158A    SETB	0xA,3
  0A3F    3EA8    ADDIA	0xA8
  0A40    00D5    LD	0x55,A
  0A41    3006    LDIA	0x6
  0A42    00D6    LD	0x56,A
  0A43    00F3    LD	0x73,A
  0A44    086B    LD	A,0x6B
  0A45    158A    SETB	0xA,3
  0A46    24EA    CALL	0x4EA
  0A47    158A    SETB	0xA,3
  0A48    158A    SETB	0xA,3
  0A49    24D2    CALL	0x4D2
  0A4A    158A    SETB	0xA,3
  0A4B    0AEB    INCR	0x6B
  0A4C    2A35    JP	0x235
187:                  		}
188:                  		sledBlink();
  0A4D    158A    SETB	0xA,3
  0A4E    26D0    CALL	0x6D0
  0A4F    158A    SETB	0xA,3
189:                  		soft_delay_ms(100);
  0A50    3064    LDIA	0x64
  0A51    00F3    LD	0x73,A
  0A52    01F4    CLR	0x74
  0A53    158A    SETB	0xA,3
  0A54    26DD    CALL	0x6DD
  0A55    158A    SETB	0xA,3
190:                  		sledBlink();
  0A56    158A    SETB	0xA,3
  0A57    26D0    CALL	0x6D0
191:                  		sys_stute=RX_MSG;
  0A58    01EE    CLR	0x6E
  0A59    0AEE    INCR	0x6E
192:                  	}break;
  0A5A    0008    RET
  0A5B    118A    CLRB	0xA,3
  0A5C    280D    JP	0xD
193:                  	
194:                  	case MATCH_MSG:
195:                  	{
196:                  		match_channel_flag |= 0x01;
197:                  		if(key_long_flag == 0x11)
198:                  		{
199:                  			KEY0.key_flag_3s = 0;			/**<Reset long press marker*/
200:                  			flag_5s_add = 0;
201:                  			key_long_flag = 0;
202:                  			match_channel_flag = 0x10;		/**<Channel 0 paired flag*/
203:                  		}
204:                  		else if(key_long_flag == 0x21)
205:                  		{
206:                  			KEY1.key_flag_3s = 0;			/**<Reset long press marker*/
207:                  			flag_5s_add = 0;
208:                  			key_long_flag = 0;
209:                  			match_channel_flag = 0x20;		/**<Channel 1 paired flag*/
210:                  		}
211:                  		else if(key_long_flag == 0x41)
212:                  		{
213:                  			KEY2.key_flag_3s = 0;			/**<Reset long press marker*/
214:                  			flag_5s_add = 0;
215:                  			key_long_flag = 0;
216:                  			match_channel_flag = 0x40;		/**<Channel 2 paired flag*/
217:                  		}
218:              
219:              
220:                  /*
221:                  0       1          2        3     4     5     6     7          8      9        10      11      12     13     14    15
222:                  type  version    count     ID1   ID2   ID3   ID4   GROUP      cmd    para0    para1   para2
223:              
224:                  */
225:              
226:                  		if(rx_data())			    /**<Whether the data was received*/
227:                  		{
228:                  			msg[0] = rf_buf[3];	/**<ID1*/
229:                  			msg[1] = rf_buf[4];	/**<ID2*/
230:                  			msg[2] = rf_buf[5];	/**<ID3*/
231:                  			msg[3] = rf_buf[6];	/**<ID4*/
232:                  			msg[4] = rf_buf[10];/**<para1,the channel number*/
233:                  			msg[5] = rf_buf[2];	/**<count*/
234:                  			//cmd    = rf_buf[8];	/**<cmd*/
235:              
236:                  			if (rf_buf[8] == CMD_SCENE_EXE)
237:                  			{
238:              					for(i = 0; i < 3; i++)
239:              					{
240:              						if((msg[0] == control_id[i + 9][0]) /**<Determine if there has been a match*/
241:              						 &&(msg[1] == control_id[i + 9][1])
242:              						 &&(msg[2] == control_id[i + 9][2])
243:              						 &&(msg[3] == control_id[i + 9][3])
244:              						)
245:              						{
246:              							match_flag = 1;				/**<Have paired*/
247:              							break;
248:              						}
249:              						else
250:              						{
251:              							match_flag = 0;				/**<Unpaired too*/
252:              						}
253:              					}
254:              					
255:              					if(match_flag == 0)
256:              					{
257:              					    flag = (channel_flag >> 6) & 0x03;
258:              					    if(flag >= 3)
259:              						{
260:              							flag = 0;							 
261:              						}
262:              						AT24C02_Write_Msg(9 * 6 + flag * 6, msg, 4);         /**<Writes paired data to the EEPROM, starting at address 48*/ 
263:              						AT24C02_Write_Msg(9 * 6 + flag * 6 + 5, msg + 5, 1); /**<Writes Count*/ 
264:              						for(i = 0; i < 4; i++)
265:              						{
266:              							control_id[flag + 9][i] = msg[i];	/**<The pairing information is assigned to the Control_ID*/
267:              						}
268:              
269:              						control_id[flag + 9][5] = msg[5];
270:              						flag ++;									/**<Channel 2 plus 1 for each pair*/
271:              						if(flag >= 3)
272:              						{
273:              							flag = 0;							/**<Determines if the number of channel 2 bindings exceeds 4 groups*/ 
274:              						}
275:              						channel_flag &= (~(0x03 << 6));
276:              						channel_flag |= (flag << 6);
277:              					}
278:              					else
279:              					{
280:              					    flag = i;
281:              						AT24C02_Write_Msg(9 * 6 + flag * 6 + 5, msg + 5, 1); /**<Writes Count*/ 
282:              						control_id[flag + 9][5] = msg[5];
283:              					}
284:              
285:              #if 1
286:                                  //配对完成后，执行相应的动作
287:                                  for(i = 9; i < 12; i++)
288:                                  {
289:                                      if ((control_id[i][4] & (0x01 << rf_buf[9])) != 0)
290:                                      {
291:                                          setChannelStatus(i - 9, CHANNEL_ON);
292:                                      }
293:                                      else
294:                                      {
295:                                          setChannelStatus(i - 9, CHANNEL_OFF);
296:                                      }
297:                                  }
298:                             
299:              #endif
300:              					
301:              					key_long_flag = 0;
302:                  				
303:                      			AT24C02_Write_Msg(ADDR_CHN_FLAG, &channel_flag,1);	   		/**<Writes the number of bindings per channel to the EEPROM*/
304:                      			AT24C02_Write_Msg(ADDR_CHN_FLAG, &channel_flag,1);
305:                      			
306:                      			for(i = 0; i < 12; i++)
307:                      			{
308:                      				AT24C02_Read_Msg(i * 6, control_id[i], 6);  /**<Reads paired data stored at EEPROM*/
309:                      			}
310:                      			AT24C02_Read_Msg(ADDR_CHN_FLAG, &channel_flag, 1);	   		/**<Reads the number of bindings per channel*/
311:              
312:                                  if (is_factory_flag)
313:                                  {
314:                                      AT24C02_Write_Byte(ADDR_NOT_FACTORY_FLAG, NOT_FACTORY_FLAG0);
315:                  	                soft_delay_ms(5);
316:                  	                AT24C02_Write_Byte(ADDR_NOT_FACTORY_FLAG + 1, NOT_FACTORY_FLAG1);
317:                  	                soft_delay_ms(5);
318:                  	                is_factory_flag = 0;
319:                                  }
320:              
321:                      			sys_stute = RX_MSG;						   
322:                      			
323:                      			sledBlink();
324:                      			match_channel_flag = 0;
325:                  			}
326:                  			else if ((rf_buf[8] == CMD_SWITCH || rf_buf[8] == CMD_SWITCH_COMPAT)
327:                  			        && msg[4] != 0xff)	/**<Determine if it is a full channel*/
328:                  			{
329:                  			    if(match_channel_flag & 0x10)						/**<Channel 0 enters the pairing*/
330:                  				{
331:                  					for(i = 0; i < 3; i++)
332:                  					{
333:                  						if((msg[0] == control_id[i][0])		/**<Determine if there has been a match*/
334:                  						&&(msg[1] == control_id[i][1])
335:                  						&&(msg[2] == control_id[i][2])
336:                  						&&(msg[3] == control_id[i][3])
337:                  						&&(msg[4] == control_id[i][4])
338:                  						)
339:                  						{
340:                  							match_flag = 1;			/**<Have paired*/
341:                  							break;
342:                  						}
343:                  						else
344:                  						{
345:                  							match_flag = 0;			/**<Unpaired too*/
346:                  						}
347:                  					}
348:                  					
349:                  					if(match_flag == 0)
350:                  					{   
351:                  					    flag = (channel_flag >> 0) & 0x03;
352:                  					    
353:                  					    if(flag >= 3)
354:                  						{
355:                  							flag = 0;
356:                  						}
357:                  						
358:                  						AT24C02_Write_Msg(0 + flag * 6, msg, 6);	/**<Writes paired data to the EEPROM, starting at address 0*/
359:                  						for(i = 0; i < 6; i++)
360:                  						{
361:                  							control_id[flag][i] = msg[i];	/**<The pairing information is assigned to the Control_ID*/
362:                  						}
363:                  						
364:                  						flag ++;									/**<Channel 0 plus 1 for each pair*/
365:                  						if(flag >= 3)
366:                  						{
367:                  							flag = 0;		/**<Determines if the number of channel 0 bindings exceeds 4 groups*/ 
368:                  						}
369:                  						
370:                  						channel_flag &= (~(0x03 << 0));
371:                  						channel_flag |= (flag << 0);
372:                  					}
373:                  					else
374:                  					{   
375:                  					    flag = i;
376:                  						AT24C02_Write_Msg(0 + flag * 6 + 5, &msg[5], 1);	/**<Writes paired data to the EEPROM, starting at address 0*/
377:                  					}
378:              
379:                                      setChannelStatus(CHANNEL_0, rf_buf[9]);
380:                  					
381:                  					key_long_flag = 0;
382:                  				}
383:                  			    else if(match_channel_flag & 0x20)				/**<Channel 1 enters the pairing*/
384:                  				{
385:                  					for(i = 0; i < 3; i++)
386:                  					{
387:                  						if((msg[0] == control_id[i+3][0])	/**<Determine if there has been a match*/
388:                  						&&(msg[1] == control_id[i+3][1])
389:                  						&&(msg[2] == control_id[i+3][2])
390:                  						&&(msg[3] == control_id[i+3][3])
391:                  						&&(msg[4] == control_id[i+3][4])
392:                  						)
393:                  						{
394:                  							match_flag = 1;				/**<Have paired*/
395:                  							break;
396:                  						}
397:                  						else
398:                  						{
399:                  							match_flag = 0;				/**<Unpaired too*/
400:                  						}
401:                  					}
402:                  					
403:                  					if(match_flag == 0)
404:                  					{
405:                  					    flag = (channel_flag >> 2) & 0x03;
406:                  					    
407:                  					    if(flag >= 3)
408:                  						{
409:                  							flag = 0;
410:                  						}
411:                  						
412:                  						AT24C02_Write_Msg(3 * 6 + flag * 6, msg, 6);		/**<Writes paired data to the EEPROM, starting at address 24*/
413:                  						for(i = 0; i < 6; i++)
414:                  						{
415:                  							control_id[flag + 3][i] = msg[i];	/**<The pairing information is assigned to the Control_ID*/
416:                  						}
417:                  						
418:                  						flag ++;									/**<Channel 1 plus 1 for each pair*/
419:                  						if(flag >= 3)
420:                  						{
421:                  							flag = 0;	/**<Determines if the number of channel 1 bindings exceeds 4 groups*/ 
422:                  						}
423:                  						channel_flag &= (~(0x03 << 2));
424:                  						channel_flag |= (flag << 2);
425:              
426:                  					}
427:                  					else
428:                  					{
429:                  					    flag = i;
430:                  					    debug = flag;
431:                  					    debug = flag;
432:                  					    //control_id[flag + 3][5] = msg[5];
433:                  						AT24C02_Write_Msg(3 * 6 + flag * 6 + 5, &msg[5], 1);	/**<Writes paired data to the EEPROM, starting at address 0*/
434:                                          soft_delay_ms(2);
435:                  					}
436:              
437:                                      setChannelStatus(CHANNEL_1, rf_buf[9]);
438:              
439:                  					key_long_flag = 0;
440:                  				}
441:                  			    else if(match_channel_flag&0x40)				/**<Channel 2 enters the pairing*/
442:                  				{
443:              
444:                  					for(i = 0; i < 3; i++)
445:                  					{
446:                  						if((msg[0] == control_id[i+6][0]) /**<Determine if there has been a match*/
447:                  						&&(msg[1] == control_id[i+6][1])
448:                  						&&(msg[2] == control_id[i+6][2])
449:                  						&&(msg[3] == control_id[i+6][3])
450:                  						&&(msg[4] == control_id[i+6][4])
451:                  							)
452:                  						{
453:                  							match_flag = 1;				/**<Have paired*/
454:                  							break;
455:                  						}
456:                  						else
457:                  						{
458:                  							match_flag = 0;				/**<Unpaired too*/
459:                  						}
460:                  					}
461:                  					
462:                  					if(match_flag == 0)
463:                  					{
464:                  					    flag = (channel_flag >> 4) & 0x03;
465:                  					    
466:                  					    if (flag >= 3)
467:                  						{
468:                  							flag = 0;
469:                  						}
470:                  						
471:                  						AT24C02_Write_Msg(6 * 6 + flag * 6, msg, 6); /**<Writes paired data to the EEPROM, starting at address 48*/ 
472:                  						for(i = 0; i < 6; i++)
473:                  						{
474:                  							control_id[flag + 6][i] = msg[i];	/**<The pairing information is assigned to the Control_ID*/
475:                  						}
476:                  						
477:                  						flag ++;									/**<Channel 2 plus 1 for each pair*/
478:                  						if(flag >= 3)
479:                  						{
480:                  							flag = 0;							/**<Determines if the number of channel 2 bindings exceeds 4 groups*/ 
481:                  						}
482:                  						
483:                  						channel_flag &= (~(0x03 << 4));
484:                  						channel_flag |= (flag << 4);
485:              
486:                  					}
487:                  					else
488:                  					{   
489:                  					    flag = i;
490:                  						AT24C02_Write_Msg(6 * 6 + flag * 6 + 5, &msg[5], 1);	/**<Writes paired data to the EEPROM, starting at address 0*/
491:                  					}
492:              
493:                                      setChannelStatus(CHANNEL_2, rf_buf[9]);
494:              
495:                  					key_long_flag = 0;
496:                  				}
497:              
498:                      			AT24C02_Write_Msg(ADDR_CHN_FLAG, &channel_flag,1);	   		/**<Writes the number of bindings per channel to the EEPROM*/
499:                      			AT24C02_Write_Msg(ADDR_CHN_FLAG, &channel_flag,1);
500:                      			
501:                      			for(i = 0; i < 12; i++)
502:                      			{
503:                      				AT24C02_Read_Msg(i * 6, control_id[i], 6);  /**<Reads paired data stored at EEPROM*/
504:                      			}
505:                      			AT24C02_Read_Msg(ADDR_CHN_FLAG, &channel_flag, 1);	   		/**<Reads the number of bindings per channel*/
506:              
507:                                  if (is_factory_flag)
508:                                  {
509:                                      AT24C02_Write_Byte(ADDR_NOT_FACTORY_FLAG, NOT_FACTORY_FLAG0);
510:                  	                soft_delay_ms(5);
511:                  	                AT24C02_Write_Byte(ADDR_NOT_FACTORY_FLAG + 1, NOT_FACTORY_FLAG1);
512:                  	                soft_delay_ms(5);
513:                  	                is_factory_flag = 0;
514:                                  }
515:                      			
516:                      			sys_stute = RX_MSG;						   
517:                      			
518:                      			sledBlink();
519:                      			match_channel_flag = 0;
520:                  			}
521:                  		}
522:                  		else
523:                  		{
524:                  			if(flag_5s_add > 500)							   /**<After 5s, exit pairing and enter receiving state*/
525:                  			{
526:                  				sys_stute = RX_MSG;
527:                  				match_channel_flag = 0;
528:                  			}
529:                  		}
530:                  	}break;
531:                  	case RX_MSG:
532:                  	{
533:                  		if(rx_data())					/**<Whether the data was received*/
534:                  		{
535:                              if (rf_buf[8] == CMD_SCENE_EXE)
536:                  			{
537:                      			if(rf_buf[10] != 0xff)	/**<Determine if it is a full channel*/
538:                      			{
539:                      				for (i = 9; i < 12; i++)
540:                      				{
541:                      					if((rf_buf[3] == control_id[i][0])	          			/**<Determine if there has been a match*/
542:                      					&&(rf_buf[4] == control_id[i][1])
543:                      					&&(rf_buf[5] == control_id[i][2])
544:                      					&&(rf_buf[6] == control_id[i][3]))
545:                      					{
546:                      						if(rf_buf[2] != control_id[i][5])	      		/**<Determine if it is the same frame of data*/
547:                      						{
548:                      							control_id[i][5] = rf_buf[2];   		/**<Update counter*/											
549:              
550:                      							if(rf_buf[9] < SCENE_NUM)		/**<Determine if the channels have been paired*/
551:                      							{
552:                      								sledBlink();
553:              
554:                                                      //由于此循环执行完成后会退出外循环，故复用了外层循环的i，注意。
555:                                                      for(i = 9; i < 12; i++)
556:                      				                {
557:                      				                    if ((control_id[i][4] & (0x01 << rf_buf[9])) != 0)
558:                      				                    {
559:                                                              setChannelStatus(i - 9, CHANNEL_ON);
560:                      				                    }
561:                      				                    else
562:                      				                    {
563:                      				                        setChannelStatus(i - 9, CHANNEL_OFF);
564:                      				                    }
565:                                                      }
566:                      								
567:                      							}
568:                      							
569:                      						}
570:                      						break;
571:                      					}
572:                      					
573:                      				}
574:                      			}
575:                  			
576:                  			}
577:                  			else if (rf_buf[8] == CMD_SCENE_SET)
578:                  			{
579:                  			    match_flag = 0;
580:                                  for(i= 0; i< 12; i++)
581:                                  {
582:                                      if((rf_buf[3] == control_id[i][0])                      /**<Determine if there has been a match*/
583:                                      &&(rf_buf[4] == control_id[i][1])
584:                                      &&(rf_buf[5] == control_id[i][2])
585:                                      &&(rf_buf[6] == control_id[i][3]))
586:                                      {
587:                                          if(rf_buf[2] != control_id[i][5])               /**<Determine if it is the same frame of data*/
588:                                          {
589:                                              control_id[i][5] = rf_buf[2];           /**<Update counter*/                                            
590:                                              match_flag = 1;   
591:                                          }
592:                                          break;
593:                                      }
594:                                  }
595:              
596:                                  if (match_flag && rf_buf[9] < SCENE_NUM && rf_buf[10] <= SCENE_ACTION_ON && rf_buf[11] < CHANNEL_NUM)
597:                                  {
598:                                      // off
599:                                      if (rf_buf[10] == SCENE_ACTION_OFF)
600:                                      {
601:                                          control_id[9 + rf_buf[11]][4] &= (~ (0x01 << rf_buf[9]));
602:                                      }
603:                                      else  //on
604:                                      {
605:                                          control_id[9 + rf_buf[11]][4] |= ((0x01 << rf_buf[9]));
606:                                      }
607:              
608:                                      AT24C02_Write_Msg(9 * 6 + rf_buf[11] * 6 + 4, &control_id[9 + rf_buf[11]][4], 1); /** */ 
609:                                      soft_delay_ms(1);
610:                                      
611:                                      //由于此循环执行完成后会退出外循环，故复用了外层循环的i，注意。
612:                                      for(i = 0; i < 12; i++)
613:                                      {
614:                                          AT24C02_Read_Msg(i * 6, control_id[i], 6);  /**<Reads paired data stored at EEPROM*/
615:                                      }
616:                                      AT24C02_Read_Msg(ADDR_CHN_FLAG, &channel_flag, 1);         /**<Reads the number of bindings per channel*/                     
617:              
618:              
619:                                      if (rf_buf[10] == SCENE_ACTION_ON)
620:                                      {
621:                                          setChannelStatus(rf_buf[11], CHANNEL_ON);
622:                                      }
623:                                      else if (rf_buf[10] == SCENE_ACTION_OFF)
624:                                      {
625:                                          setChannelStatus(rf_buf[11], CHANNEL_OFF);
626:                                      }
627:                                      
628:                                      sledBlink();
629:                                  } 
630:                                 
631:                  			}
632:                  			else if (rf_buf[8] == CMD_SWITCH || rf_buf[8] == CMD_SWITCH_COMPAT)
633:                  			{
634:                                  if(rf_buf[10] != 0xff)  /**<Determine if it is a full channel*/
635:                                  {
636:                                      for(i=0; i<9; i++)
637:                                      {
638:                                          if ((is_factory_flag == 1)
639:                                          &&((rf_buf[3] == FACTORY_ADDR0_VALUE)                      /**<Determine if there has been a match*/
640:                                          &&(rf_buf[4] == FACTORY_ADDR1_VALUE)
641:                                          &&(rf_buf[5] == FACTORY_ADDR2_VALUE)
642:                                          &&(rf_buf[6] == FACTORY_ADDR3_VALUE))
643:                                          ||
644:                                          ((rf_buf[3] == control_id[i][0])                      /**<Determine if there has been a match*/
645:                                          &&(rf_buf[4] == control_id[i][1])
646:                                          &&(rf_buf[5] == control_id[i][2])
647:                                          &&(rf_buf[6] == control_id[i][3]))
648:                                          )
649:                                          {
650:                                              if(rf_buf[2] != control_id[i][5])               /**<Determine if it is the same frame of data*/
651:                                              {
652:                                                  control_id[i][5] = rf_buf[2];           /**<Update counter*/                                            
653:                                                  if(rf_buf[10] == control_id[i][4])      /**<Determine if the channels have been paired*/
654:                                                  {
655:                                                      if(flag == 0)   
656:                                                      {
657:                                                          flag = 1;               /**<Prompt for remote control of paired device received*/
658:                                                          sledBlink();
659:                                                      }
660:                                                      
661:                                                      if(rf_buf[11] == 0)             /**<Determine if it is a delay instruction*/
662:                                                      {
663:                                                          if(i < 3)               /**<Change the state of channel 0 according to the instruction*/
664:                                                          {
665:                                                              if((KEY0_FLAG == 0))
666:                                                                  {
667:                                                                      if(rf_buf[9] == 2)
668:                                                                          setChannelStatus(CHANNEL_0, CHANNEL_SW);
669:                                                                      else
670:                                                                          setChannelStatus(CHANNEL_0, rf_buf[9]);
671:                                                                  }
672:                                                          }
673:                                                          else if(i < 6)          /**<Change the state of channel 1 according to the instruction*/
674:                                                          {
675:                                                              if((KEY1_FLAG == 0))
676:                                                              {
677:                                                              if(rf_buf[9] == 2)
678:                                                                  setChannelStatus(CHANNEL_1, CHANNEL_SW);
679:                                                              else
680:                                                                  setChannelStatus(CHANNEL_1, rf_buf[9]);
681:                                  
682:                                                              }
683:                                                          }
684:                                                          else
685:                                                          {
686:                                                              if((KEY2_FLAG == 0))    /**<Change the state of channel 0 according to the instruction*/
687:                                                              {
688:                                                              if(rf_buf[9] == 2)
689:                                                                  setChannelStatus(CHANNEL_2, CHANNEL_SW);
690:                                                              else
691:                                                                  setChannelStatus(CHANNEL_2, rf_buf[9]);
692:                                                              }
693:                                                          }
694:                                                      }
695:                                                      else                                    /**<Delay operation*/
696:                                                      {
697:                                                          flag_5min_add = 0;
698:                                                          if(delay_flag == 1)
699:                                                          {
700:                                                              channel_delay[0] = 0;           /**<Reset delay channel*/
701:                                                              delay_flag = 0;                 /**<Set it to 1 in delay_task(void)*/
702:                                                          }
703:                                                          if(i < 3)
704:                                                          {
705:                                                              channel_delay[0] |= 0x01;       /**<channel 0*/
706:                                                          }
707:                                                          else if(i < 6)
708:                                                          {
709:                                                              channel_delay[0] |= 0x02;       /**<channel 1*/
710:                                                          }
711:                                                          else
712:                                                          {
713:                                                              channel_delay[0] |= 0x04;       /**<channel 2*/
714:                                                          }
715:                                                          channel_delay[1] = rf_buf[9];       /**<Motion commands*/
716:                                                          channel_delay[2] = rf_buf[11];      /**<Delay time*/
717:                                                      }
718:                                                  }
719:                                              }
720:                                          }
721:                                          
722:                                      }
723:                                  }
724:                                  else
725:                                  {
726:              						for(i=0; i<9; i++)
727:                                      {
728:                                          if ((is_factory_flag == 1)
729:                                          &&((rf_buf[3] == FACTORY_ADDR0_VALUE)                      /**<Determine if there has been a match*/
730:                                          &&(rf_buf[4] == FACTORY_ADDR1_VALUE)
731:                                          &&(rf_buf[5] == FACTORY_ADDR2_VALUE)
732:                                          &&(rf_buf[6] == FACTORY_ADDR3_VALUE))
733:                                          ||
734:                                          ((rf_buf[3] == control_id[i][0])                      /**<Determine if there has been a match*/
735:                                          &&(rf_buf[4] == control_id[i][1])
736:                                          &&(rf_buf[5] == control_id[i][2])
737:                                          &&(rf_buf[6] == control_id[i][3]))
738:                                          )
739:                                          {
740:                                              if((rf_buf[2] != control_id[i][5]))     /**<Determine if it is the same frame of data*/
741:                                              {
742:                                                  control_id[i][5] = rf_buf[2];       /**<Update counter*/
743:                                                 
744:                                                  sledBlink();
745:                                                 
746:                                                  if((rf_buf[11] == 0))               /**<Determine if it is a delay instruction*/
747:                                                  {
748:                                                      
749:                                                      if((KEY0_FLAG == 0))
750:                                                      {
751:                                                          if(rf_buf[9] == 2)
752:                                                              setChannelStatus(CHANNEL_0, CHANNEL_SW);
753:                                                          else
754:                                                              setChannelStatus(CHANNEL_0, rf_buf[9]);
755:                                                      }
756:                                              
757:                                                      if((KEY1_FLAG == 0))
758:                                                      {
759:                                                          if(rf_buf[9] == 2)
760:                                                              setChannelStatus(CHANNEL_1, CHANNEL_SW);
761:                                                          else
762:                                                              setChannelStatus(CHANNEL_1, rf_buf[9]);
763:                                                      }
764:                                             
765:                                                      if((KEY2_FLAG == 0)) /**<Change the state of channel 2 according to the instruction*/
766:                                                      {
767:                                                          if(rf_buf[9] == 2)
768:                                                              setChannelStatus(CHANNEL_2, CHANNEL_SW);
769:                                                          else
770:                                                              setChannelStatus(CHANNEL_2, rf_buf[9]);
771:                                                      }
772:                                                      
773:                                                  }
774:                                                  else                                        /**<Delay operation*/
775:                                                  {
776:                                                      flag_5min_add = 0;
777:                                                      if(delay_flag == 1)
778:                                                      {
779:                                                          channel_delay[0] = 0;       /**<Reset delay channel*/
780:                                                          delay_flag = 0;             /**<Set it to 1 in delay_task(void)*/
781:                                                      }
782:                                                      
783:                                                      channel_delay[0] |= 0x01;       /**<channel 0*/
784:                                                      channel_delay[0] |= 0x02;       /**<channel 1*/
785:                                                      channel_delay[0] |= 0x04;       /**<channel 2*/
786:                                                  
787:                                                      channel_delay[1] = rf_buf[9];       /**<Motion commands*/
788:                                                      channel_delay[2] = rf_buf[11];      /**<Delay time*/
789:                                                  }
790:                                                  
791:                                              }
792:                                          }
793:                                  	}
794:              					}
795:                  			}
796:                  			else if (rf_buf[8] == CMD_STARTUP_CONFIG)
797:                  			{
798:              
799:              #define CMD_STARTUP_ACTION_INDEX 9
800:              #define CMD_STARTUP_OUTLET_INDEX 10
801:              
802:                                  if(rf_buf[2] != control_id[i][5])               /**<Determine if it is the same frame of data*/
803:                                  {
804:                                      control_id[i][5] = rf_buf[2];           /**<Update counter*/                                            
805:                   
806:                                      match_flag = 0;
807:                                      for(i= 0; i< 9; i++)
808:                                      {
809:                                          if((rf_buf[3] == control_id[i][0])                      /**<Determine if there has been a match*/
810:                                          &&(rf_buf[4] == control_id[i][1])
811:                                          &&(rf_buf[5] == control_id[i][2])
812:                                          &&(rf_buf[6] == control_id[i][3]))
813:                                          {
814:                                              if (rf_buf[CMD_STARTUP_OUTLET_INDEX] == 0xFF)
815:                                              {
816:                                                  match_flag |= 0x07;
817:                                                  break;
818:                                              }
819:                                              else if (rf_buf[CMD_STARTUP_OUTLET_INDEX] == control_id[i][4])
820:                                              {
821:                                                  match_flag |= (1 << (i / 3));
822:                                              }
823:                                          }
824:                                      }
825:                                  }
826:              
827:                                  if (match_flag
828:                                      && rf_buf[CMD_STARTUP_ACTION_INDEX] <= PROTOCOL_STARTUP_STAY)
829:                                  {
830:              
831:                                      for(i = 0; i < CHANNEL_NUM; i++)
832:                                      {
833:                                          if (match_flag & (1 << i))
834:                                          {
835:                                              if (rf_buf[CMD_STARTUP_ACTION_INDEX] == PROTOCOL_STARTUP_OFF)
836:                                              {
837:                                                  setChnStartupOff(channel_startup, i);
838:                                                  setChannelStatus(i, CHANNEL_OFF);
839:                                              }
840:                                              else if (rf_buf[CMD_STARTUP_ACTION_INDEX] == PROTOCOL_STARTUP_ON)
841:                                              {
842:                                                  setChnStartupOn(channel_startup, i);
843:                                                  setChannelStatus(i, CHANNEL_ON);
844:                                              }
845:                                              else if (rf_buf[CMD_STARTUP_ACTION_INDEX] == PROTOCOL_STARTUP_STAY)
846:                                              {
847:                                                  setChnStartupStay(channel_startup, i);
848:                                                  
849:                                                  if (i == CHANNEL_0)
850:                                                  {
851:                                                      setChannelStatus(CHANNEL_0, KEY0.channel_status);
852:                                                  }
853:                                                  else if (i == CHANNEL_1)
854:                                                  {
855:                                                      setChannelStatus(CHANNEL_1, KEY1.channel_status);
856:                                                  }
857:                                                  else if (i == CHANNEL_2)
858:                                                  {
859:                                                      setChannelStatus(CHANNEL_2, KEY2.channel_status);
860:                                                  }
861:                                              }
862:                                          }
863:                                      }
864:              
865:                                      AT24C02_Write_Msg(ADDR_CHN_STARTUP, &channel_startup, CHN_STARTUP_SIZE);
866:                                      
867:                                      sledBlink();
868:                                  } 
869:                                 
870:                  			}
871:                  			
872:                  			//��ֹͬһ֡�����ظ���Ӧ
873:                  			soft_delay_ms(100);
874:                  			RF_ClearFIFO();
875:                  			RF_ClearStatus();
876:              
877:                  		}
878:                  	}break;
879:                  }
880:              	
881:              }
882:              
883:              
884:              void channel_set(uint8_t channel_num, uint8_t status)
885:              {
  098A    00F4    LD	0x74,A
886:              	switch(channel_num)
  098B    29B3    JP	0x1B3
887:              		{
888:              			case 0 :
889:              					{
890:              						if(status)
  098C    0873    LD	A,0x73
  098D    1903    SZB	0x3,2
  098E    2994    JP	0x194
891:              							{
892:              								TRISB6 = 0;
  098F    1683    SETB	0x3,5
  0990    1306    CLRB	0x6,6
893:              								RB6 = 1;		/**<Channel 0 outputs high level*/
  0991    1283    CLRB	0x3,5
  0992    1706    SETB	0x6,6
894:              							}
  0993    0008    RET
895:              						else 
896:              							{
897:              								TRISB6 = 0;
  0994    1683    SETB	0x3,5
  0995    1306    CLRB	0x6,6
898:              								RB6 = 0;		/**<Channel 0 outputs low level*/
  0996    1283    CLRB	0x3,5
  0997    1306    CLRB	0x6,6
  0998    0008    RET
899:              							}
900:              					}break;
901:              			case 1:
902:              					{
903:              						if(status)
  0999    0873    LD	A,0x73
  099A    1903    SZB	0x3,2
  099B    29A1    JP	0x1A1
904:              							{
905:              								TRISB5 = 0;
  099C    1683    SETB	0x3,5
  099D    1286    CLRB	0x6,5
906:              								RB5 = 1;			/**<Channel 1 outputs high level*/
  099E    1283    CLRB	0x3,5
  099F    1686    SETB	0x6,5
907:              							}
  09A0    0008    RET
908:              						else 
909:              							{
910:              								TRISB5 = 0;
  09A1    1683    SETB	0x3,5
  09A2    1286    CLRB	0x6,5
911:              								RB5 = 0;			/**<Channel 1 outputs low level*/
  09A3    1283    CLRB	0x3,5
  09A4    1286    CLRB	0x6,5
  09A5    0008    RET
912:              							}
913:              					}break;
914:              			case 2: 
915:              					{
916:              						if(status)
  09A6    0873    LD	A,0x73
  09A7    1903    SZB	0x3,2
  09A8    29AE    JP	0x1AE
917:              							{
918:              								TRISB4 = 0;
  09A9    1683    SETB	0x3,5
  09AA    1206    CLRB	0x6,4
919:              								RB4 = 1;			/**<Channel 2 outputs high level*/
  09AB    1283    CLRB	0x3,5
  09AC    1606    SETB	0x6,4
920:              							}
  09AD    0008    RET
921:              						else 
922:              							{
923:              								TRISB4 = 0;
  09AE    1683    SETB	0x3,5
  09AF    1206    CLRB	0x6,4
924:              								RB4 = 0;			/**<Channel 2 outputs low level*/
  09B0    1283    CLRB	0x3,5
  09B1    1206    CLRB	0x6,4
  09B2    0008    RET
  09B3    0874    LD	A,0x74
  09B4    3A00    XORIA	0x0
  09B5    1903    SZB	0x3,2
  09B6    298C    JP	0x18C
  09B7    3A01    XORIA	0x1
  09B8    1903    SZB	0x3,2
  09B9    2999    JP	0x199
  09BA    3A03    XORIA	0x3
  09BB    1903    SZB	0x3,2
  09BC    29A6    JP	0x1A6
  09BD    29BE    JP	0x1BE
  09BE    0008    RET
925:              							}
926:              					}break;
927:              		}
928:              }
929:              
930:              void delay_task(void)
931:              {
932:              	if(power_on_delay_flag == 1)
  0D21    0B6F    SZDECA	0x6F
  0D22    2D33    JP	0x533
933:              	{
934:              		if(flag_5s_add > 200)
  0D23    3000    LDIA	0x0
  0D24    022F    SUBA	0x2F
  0D25    30C9    LDIA	0xC9
  0D26    1903    SZB	0x3,2
  0D27    022E    SUBA	0x2E
  0D28    1C03    SNZB	0x3,0
  0D29    2D33    JP	0x533
  0D2A    304E    LDIA	0x4E
935:              		{
936:              			power_on_delay_flag = 0;
  0D2B    01EF    CLR	0x6F
937:              			power_on_flag = 0;
  0D2C    01CE    CLR	0x4E
938:              			AT24C02_Write_Msg(POWER_ON_NUM, &power_on_flag, POWER_ON_NUM_SIZE);
  0D2D    00D3    LD	0x53,A
  0D2E    3073    LDIA	0x73
  0D2F    01D4    CLR	0x54
  0D30    0AD4    INCR	0x54
  0D31    276D    CALL	0x76D
  0D32    158A    SETB	0xA,3
939:              		}
940:              	}
941:                  
942:              	if(channel_delay[0] != 0)						/**<Determine if there are delayed tasks*/
  0D33    0829    LD	A,0x29
  0D34    1903    SZB	0x3,2
  0D35    0008    RET
943:              		{
944:              			if(delay_flag == 0)delay_flag = 1;		/**<There is already a delayed task*/
  0D36    08B6    TESTZ	0x36
  0D37    1D03    SNZB	0x3,2
  0D38    2D3B    JP	0x53B
  0D39    01B6    CLR	0x36
  0D3A    0AB6    INCR	0x36
945:              			if(channel_delay[2] > 0)				/**<Whether the delay is over*/
  0D3B    082B    LD	A,0x2B
  0D3C    1903    SZB	0x3,2
  0D3D    2D49    JP	0x549
946:              				{
947:              					if(flag_5min_add >= 30000)		/**<Five minutes a step,A 10ms timer,5min = (10*30000)ms*/
  0D3E    3075    LDIA	0x75
  0D3F    022D    SUBA	0x2D
  0D40    3030    LDIA	0x30
  0D41    1903    SZB	0x3,2
  0D42    022C    SUBA	0x2C
  0D43    1C03    SNZB	0x3,0
  0D44    0008    RET
948:              						{
949:              							flag_5min_add = 0;
  0D45    01AC    CLR	0x2C
  0D46    01AD    CLR	0x2D
950:              							channel_delay[2]--;		/**<Delay minus 1*/
  0D47    03AB    DECR	0x2B
  0D48    0008    RET
951:              						}
952:              				}
953:              			else
954:              				{
955:              
956:              
957:              #if 0
958:              				
959:              					switch(channel_delay[0])		/**<Arrival delay time,Change channel state based on the contents of channel_delay[0]*/
960:              						{
961:              						case 1:
962:              								{
963:              									if(channel_delay[1] != 2)
964:              										setChannelStatus(CHANNEL_0, channel_delay[1]);
965:              									else 
966:              										setChannelStatus(CHANNEL_0, CHANNEL_SW);									
967:              									}break;
968:              						case 2:
969:              								{
970:              									if(channel_delay[1] != 2)
971:              										setChannelStatus(CHANNEL_1, channel_delay[1]);
972:              									else 
973:              										setChannelStatus(CHANNEL_1, CHANNEL_SW);									
974:              									}break;
975:              						case 4:
976:              								{
977:              									if(channel_delay[1] != 2)
978:              										setChannelStatus(CHANNEL_2, channel_delay[1]);
979:              									else 
980:              										setChannelStatus(CHANNEL_2, CHANNEL_SW);
981:              									}break;
982:              						case 3:
983:              								{
984:              									if(channel_delay[1] != 2)
985:              										{
986:              											setChannelStatus(CHANNEL_0, channel_delay[1]);
987:              											setChannelStatus(CHANNEL_1, channel_delay[1]);
988:              										}
989:              									else 
990:              										{
991:              											setChannelStatus(CHANNEL_0, CHANNEL_SW);
992:              											setChannelStatus(CHANNEL_1, CHANNEL_SW);
993:              										}
994:              									}break;
995:              						case 5:
996:              								{
997:              									if(channel_delay[1] != 2)
998:              										{
999:              											setChannelStatus(CHANNEL_0, channel_delay[1]);
1000:             											setChannelStatus(CHANNEL_2, channel_delay[1]);
1001:             										}
1002:             									else 
1003:             										{
1004:             											setChannelStatus(CHANNEL_0, CHANNEL_SW);
1005:             											setChannelStatus(CHANNEL_2, CHANNEL_SW);
1006:             										}
1007:             									}break;
1008:             						case 6:
1009:             								{
1010:             									if(channel_delay[1] != 2)
1011:             										{
1012:             											setChannelStatus(CHANNEL_1, channel_delay[1]);
1013:             											setChannelStatus(CHANNEL_2, channel_delay[1]);
1014:             										}
1015:             									else 
1016:             										{
1017:             											setChannelStatus(CHANNEL_1, CHANNEL_SW);
1018:             											setChannelStatus(CHANNEL_2, CHANNEL_SW);
1019:             										}
1020:             									}break;
1021:             						case 7:
1022:             								{
1023:             									if(channel_delay[1] != 2)
1024:             										{
1025:             											setChannelStatus(CHANNEL_0, channel_delay[1]);
1026:             											setChannelStatus(CHANNEL_1, channel_delay[1]);
1027:             											setChannelStatus(CHANNEL_2, channel_delay[1]);
1028:             										}
1029:             									else 
1030:             										{
1031:             											setChannelStatus(CHANNEL_0, CHANNEL_SW);
1032:             											setChannelStatus(CHANNEL_1, CHANNEL_SW);
1033:             											setChannelStatus(CHANNEL_2, CHANNEL_SW);
1034:             										}
1035:             									}break;
1036:             						}
1037:             
1038:             
1039:             #else
1040:             
1041:             
1042:                                                 if (channel_delay[1] <= CHANNEL_SW)
  0D49    3003    LDIA	0x3
  0D4A    022A    SUBA	0x2A
  0D4B    1803    SZB	0x3,0
  0D4C    2D61    JP	0x561
1043:                                                 {
1044:                                                     if (channel_delay[0] & 0x01)
  0D4D    1C29    SNZB	0x29,0
  0D4E    2D54    JP	0x554
1045:                                                     {
1046:                                                         setChannelStatus(CHANNEL_0, channel_delay[1]);
  0D4F    082A    LD	A,0x2A
  0D50    00D8    LD	0x58,A
  0D51    3000    LDIA	0x0
  0D52    26F9    CALL	0x6F9
  0D53    158A    SETB	0xA,3
1047:                                                     }
1048:             
1049:                                                     if (channel_delay[0] & 0x02)
  0D54    1CA9    SNZB	0x29,1
  0D55    2D5B    JP	0x55B
1050:                                                     {
1051:                                                         setChannelStatus(CHANNEL_1, channel_delay[1]);
  0D56    082A    LD	A,0x2A
  0D57    00D8    LD	0x58,A
  0D58    3001    LDIA	0x1
  0D59    26F9    CALL	0x6F9
  0D5A    158A    SETB	0xA,3
1052:                                                     }
1053:             
1054:                                                     if (channel_delay[0] & 0x04)
  0D5B    1D29    SNZB	0x29,2
  0D5C    2D61    JP	0x561
1055:                                                     {
1056:                                                         setChannelStatus(CHANNEL_2, channel_delay[1]);
  0D5D    082A    LD	A,0x2A
  0D5E    00D8    LD	0x58,A
  0D5F    3002    LDIA	0x2
  0D60    26F9    CALL	0x6F9
1057:                                                     }
1058:                                                 }
1059:             									
1060:             
1061:             #endif
1062:             
1063:             					channel_delay[0] = 0;
  0D61    01A9    CLR	0x29
1064:             					channel_delay[1] = 0;
  0D62    01AA    CLR	0x2A
1065:             					channel_delay[2] = 0;
  0D63    01AB    CLR	0x2B
1066:             					delay_flag=0;
  0D64    01B6    CLR	0x36
  0D65    0008    RET
1067:             				}
1068:             		}
1069:             }
---- C:\item\pan2416\gitforpan2416\PAV03new\FWSWES-PAV03-SCENESWITCHES-PAN2416AV\src\rf297L.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "delay.h"
3:                #include "rf297l.h"
4:                
5:                #define delay_ms(ms) soft_delay_ms(ms)
6:                const unsigned char TX_ADDRESS_DEF[3] = {0xCC,0xCC,0xCC};
7:                const unsigned char RX_ADDRESS_DEF[3] = {0x2D,0xD7,0XB9};
8:                //static unsigned char ACK_Payload_length;
9:                
10:               unsigned char RF_ReadReg(unsigned char reg_addr);
11:               void RF_WriteReg(unsigned char reg_addr, unsigned char write_data);
12:               void RF_Write_Buff(unsigned char reg_addr,unsigned char *pBuff,unsigned char length);
13:               void RF_Read_Buff(unsigned char reg_addr, unsigned char *pBuff, unsigned char length);
14:               void RF_Set_TxMode(void);
15:               void RF_Set_RxMode(void);
16:               unsigned char RF_GetStatus(void);
17:               void RF_ClearStatus(void);
18:               void RF_ClearFIFO(void);
19:               void RF_SetChannel(unsigned char Channel);
20:               void RF_TxData(unsigned char *payload_buff,unsigned char length);
21:               unsigned char RF_Read_RxData(unsigned char *payload_buff,unsigned char length);
22:               void RF_Init(void);
23:               TX_RESULT_e RF_get_TX_result(void);
24:               
25:               static unsigned char SPI_RW(unsigned char read_reg_addr);
26:               static void SPI_init(void);
27:               
28:               
29:               TX_RESULT_e RF_get_TX_result(void)
30:               {
31:               	unsigned char status = 0;
32:               	status = RF_GetStatus();
33:               	if(status == TX_DS_FLAG){
34:               		return SENT_SUCCESS;
35:               	}else if(status == RX_TX_FLAG){
36:               		return ACK_PAYLOAD_SENT_SUCCESS;
37:               	}else if(MAX_RT_FLAG){
38:               		return SENT_FAILURE;
39:               	}else{
40:               		return UNKNOW_STATUS;
41:               	}
42:               }
43:               
44:               void RF_Init(void)
45:               {	
46:               #ifdef	IC_TYPE_MX5325          	  //MX5325
47:               	#if(DATA_RATE == DR_1M) 
48:               		const unsigned char  BB_cal_data[]    = {0x0A,0x6D,0x67,0x9C,0x46}; 
49:               		const unsigned char  RF_cal_data[]    = {0xF6,0x37,0x5D};                                      
50:               		const unsigned char  RF_cal2_data[]   = {0x45,0x21,0xeF,0x2c,0x5a,0x40};
51:               		const unsigned char  Dem_cal_data[]   = {0x01};  
52:               		const unsigned char  Dem_cal2_data[]  = {0x0B,0xDF,0x02};   
53:               	#elif(DATA_RATE == DR_250K) 
54:               		const unsigned char   BB_cal_data[]    = {0x12,0xec,0x6f,0xa1,0x46}; 
55:               		const unsigned char   RF_cal_data[]    = {0xf6,0x37,0x5d};
56:               		const unsigned char   RF_cal2_data[]   = {0xd5,0x21,0xeb,0x2c,0x5a,0x40};
57:               		const unsigned char   Dem_cal_data[]   = {0x1F};  
58:               		const unsigned char   Dem_cal2_data[]  = {0x0B,0xDF,0x02};
59:               	#endif
60:               #else			//PAN2416			//ӦPOWERֵһ
61:               	#if(DATA_RATE == DR_1M) 
62:               		const unsigned char  BB_cal_data[]    = {0x0A,0x6D,0x67,0x9C,0x46}; 
63:               		const unsigned char  RF_cal_data[]    = {0x16,0x33,0x27};                      
64:               		const unsigned char  RF_cal2_data[]   = {0x45,0x21,0x3F,0x2D,0x5C,0x40};
65:               		const unsigned char  Dem_cal_data[]   = {0x01};  
66:               		const unsigned char  Dem_cal2_data[]  = {0x0B,0xDF,0x02};   
67:               	#elif(DATA_RATE == DR_250K) 
68:               		const unsigned char   BB_cal_data[]    = {0x12,0xEC,0x6f,0xA9,0x46}; 
69:               		const unsigned char   RF_cal_data[]    = {0x06,0x33,0x00};
70:               		const unsigned char   RF_cal2_data[]   = {0xD5,0x21,0x3B,0x2D,0x5C,0x40};
71:               		const unsigned char   Dem_cal_data[]   = {0x03};  
72:               		const unsigned char   Dem_cal2_data[]  = {0x0B,0xDF,0x02};
73:               	#endif
74:               #endif
75:                   unsigned char feature = 0x00;
76:                   SPI_init();
  0B4A    23F4    CALL	0x3F4
  0B4B    158A    SETB	0xA,3
77:                   RF_WriteReg(RST_FSPI, 0x5A);	//Software Reset    			
  0B4C    305A    LDIA	0x5A
  0B4D    00F5    LD	0x75,A
  0B4E    3053    LDIA	0x53
  0B4F    23C1    CALL	0x3C1
  0B50    158A    SETB	0xA,3
78:                   RF_WriteReg(RST_FSPI, 0XA5);
  0B51    30A5    LDIA	0xA5
  0B52    00F5    LD	0x75,A
  0B53    3053    LDIA	0x53
  0B54    23C1    CALL	0x3C1
  0B55    158A    SETB	0xA,3
  0B56    30E1    LDIA	0xE1
79:                   RF_WriteReg(FLUSH_TX, 0);			// CLEAR TXFIFO		    			 
  0B57    01F5    CLR	0x75
  0B58    23C1    CALL	0x3C1
  0B59    158A    SETB	0xA,3
  0B5A    30E2    LDIA	0xE2
80:                   RF_WriteReg(FLUSH_RX, 0);			// CLEAR  RXFIFO
  0B5B    01F5    CLR	0x75
  0B5C    23C1    CALL	0x3C1
  0B5D    158A    SETB	0xA,3
81:                   RF_WriteReg(W_REGISTER + STATUS, 0x70);	// CLEAR  STATUS	
  0B5E    3070    LDIA	0x70
  0B5F    00F5    LD	0x75,A
  0B60    3027    LDIA	0x27
  0B61    23C1    CALL	0x3C1
  0B62    158A    SETB	0xA,3
  0B63    3022    LDIA	0x22
82:                   RF_WriteReg(W_REGISTER + EN_RXADDR, 0x01);	// Enable Pipe0
  0B64    01F5    CLR	0x75
  0B65    0AF5    INCR	0x75
  0B66    23C1    CALL	0x3C1
  0B67    158A    SETB	0xA,3
  0B68    3023    LDIA	0x23
83:                   RF_WriteReg(W_REGISTER + SETUP_AW,  0x01);	// address witdth is 5 bytes
  0B69    01F5    CLR	0x75
  0B6A    0AF5    INCR	0x75
  0B6B    23C1    CALL	0x3C1
  0B6C    158A    SETB	0xA,3
84:                   RF_WriteReg(W_REGISTER + RF_CH, DEFAULT_CHANNEL); // 2478M HZ
  0B6D    301A    LDIA	0x1A
  0B6E    00F5    LD	0x75,A
  0B6F    3025    LDIA	0x25
  0B70    23C1    CALL	0x3C1
  0B71    158A    SETB	0xA,3
85:                   RF_WriteReg(W_REGISTER + RX_PW_P0, PAYLOAD_WIDTH);// PAYLOAD_WIDTH bytes
  0B72    3012    LDIA	0x12
  0B73    00F5    LD	0x75,A
  0B74    3031    LDIA	0x31
  0B75    23C1    CALL	0x3C1
  0B76    158A    SETB	0xA,3
86:                   RF_Write_Buff(W_REGISTER + TX_ADDR, TX_ADDRESS_DEF, sizeof(TX_ADDRESS_DEF));	// Writes TX_Address to PN006
  0B77    3075    LDIA	0x75
  0B78    00CF    LD	0x4F,A
  0B79    3003    LDIA	0x3
  0B7A    00D0    LD	0x50,A
  0B7B    3030    LDIA	0x30
  0B7C    23CA    CALL	0x3CA
  0B7D    158A    SETB	0xA,3
87:                   RF_Write_Buff(W_REGISTER + RX_ADDR_P0,RX_ADDRESS_DEF, sizeof(RX_ADDRESS_DEF));	// RX_Addr0 same as TX_Adr for Auto.Ack   
  0B7E    3072    LDIA	0x72
  0B7F    00CF    LD	0x4F,A
  0B80    3003    LDIA	0x3
  0B81    00D0    LD	0x50,A
  0B82    302A    LDIA	0x2A
  0B83    23CA    CALL	0x3CA
  0B84    158A    SETB	0xA,3
88:                   RF_Write_Buff(W_REGISTER + BB_CAL,    BB_cal_data,  sizeof(BB_cal_data));
  0B85    3061    LDIA	0x61
  0B86    00CF    LD	0x4F,A
  0B87    3005    LDIA	0x5
  0B88    00D0    LD	0x50,A
  0B89    303F    LDIA	0x3F
  0B8A    23CA    CALL	0x3CA
  0B8B    158A    SETB	0xA,3
89:                   RF_Write_Buff(W_REGISTER + RF_CAL2,   RF_cal2_data, sizeof(RF_cal2_data));
  0B8C    3056    LDIA	0x56
  0B8D    00CF    LD	0x4F,A
  0B8E    3006    LDIA	0x6
  0B8F    00D0    LD	0x50,A
  0B90    303A    LDIA	0x3A
  0B91    23CA    CALL	0x3CA
  0B92    158A    SETB	0xA,3
90:                   RF_Write_Buff(W_REGISTER + DEM_CAL,   Dem_cal_data, sizeof(Dem_cal_data));
  0B93    3079    LDIA	0x79
  0B94    00CF    LD	0x4F,A
  0B95    3039    LDIA	0x39
  0B96    01D0    CLR	0x50
  0B97    0AD0    INCR	0x50
  0B98    23CA    CALL	0x3CA
  0B99    158A    SETB	0xA,3
91:                   RF_Write_Buff(W_REGISTER + RF_CAL,    RF_cal_data,  sizeof(RF_cal_data));
  0B9A    306F    LDIA	0x6F
  0B9B    00CF    LD	0x4F,A
  0B9C    3003    LDIA	0x3
  0B9D    00D0    LD	0x50,A
  0B9E    303E    LDIA	0x3E
  0B9F    23CA    CALL	0x3CA
  0BA0    158A    SETB	0xA,3
92:                   RF_Write_Buff(W_REGISTER + DEM_CAL2,  Dem_cal2_data,sizeof(Dem_cal2_data));
  0BA1    306C    LDIA	0x6C
  0BA2    00CF    LD	0x4F,A
  0BA3    3003    LDIA	0x3
  0BA4    00D0    LD	0x50,A
  0BA5    303B    LDIA	0x3B
  0BA6    23CA    CALL	0x3CA
  0BA7    158A    SETB	0xA,3
  0BA8    303C    LDIA	0x3C
93:                   RF_WriteReg(W_REGISTER + DYNPD, 0x00);					                            
  0BA9    01F5    CLR	0x75
  0BAA    23C1    CALL	0x3C1
  0BAB    158A    SETB	0xA,3
94:                   RF_WriteReg(W_REGISTER + RF_SETUP, RF_POWER);						// 		
  0BAC    300E    LDIA	0xE
  0BAD    00F5    LD	0x75,A
  0BAE    3026    LDIA	0x26
  0BAF    23C1    CALL	0x3C1
  0BB0    158A    SETB	0xA,3
95:                   RF_WriteReg(ACTIVATE, 0x73);
  0BB1    3073    LDIA	0x73
  0BB2    00F5    LD	0x75,A
  0BB3    3050    LDIA	0x50
  0BB4    23C1    CALL	0x3C1
  0BB5    158A    SETB	0xA,3
  0BB6    3024    LDIA	0x24
96:                   
97:               	#if(TRANSMIT_TYPE == TRANS_ENHANCE_MODE)      	//˫
98:               		RF_WriteReg(W_REGISTER + SETUP_RETR,0x01);							//  1 retrans... 	
99:               		RF_WriteReg(W_REGISTER + EN_AA,     0x01);							// Enable Auto.Ack:Pipe0  	
100:              	#elif(TRANSMIT_TYPE == TRANS_BURST_MODE)        //                                                      
101:              		RF_WriteReg(W_REGISTER + SETUP_RETR,0x00);							// Disable retrans... 	
  0BB7    01F5    CLR	0x75
  0BB8    23C1    CALL	0x3C1
  0BB9    158A    SETB	0xA,3
  0BBA    3021    LDIA	0x21
102:              		RF_WriteReg(W_REGISTER + EN_AA,     0x00);							// Disable AutoAck 
  0BBB    01F5    CLR	0x75
  0BBC    23C1    CALL	0x3C1
  0BBD    158A    SETB	0xA,3
103:              	#endif
104:              
105:              	#if(EN_DYNPLOAD == 1)		//ʹ̬ܶPAYLOAD
106:              		feature |= 0x04;
107:              		RF_WriteReg(W_REGISTER + DYNPD, 0x01);
108:              	#endif
109:              
110:              	#if(EN_ACK_PAYLOAD == 1)	//ʹACK_PAYLOAD
111:              		feature |= 0x02;
112:              	#endif
113:              	if(PAYLOAD_WIDTH >32){
  0BBE    303D    LDIA	0x3D
114:              		feature |= 0x18;
115:              	}
116:              	//feature |= 0x20 ; //ce order by mcu not pin
117:              	RF_WriteReg(W_REGISTER + FEATURE, feature);
  0BBF    01F5    CLR	0x75
  0BC0    2BC1    JP	0x3C1
118:              }
119:              
120:              
121:              /******************************************************************************/
122:              //            RF_RxDataͨģʽ
123:              //            յݣ
124:              //            
125:              //              1. payload_buff洢ȡݵBuffer
126:              //              2. length:    ȡݳ
127:              //              Return:
128:              //              1. 0: ûнյ
129:              //              2. 1: ȡյݳɹ
130:              //              note: Only use in Rx Mode
131:              //              length ͨ PAYLOAD_WIDTH
132:              /******************************************************************************/
133:              unsigned char RF_RxData(unsigned char *payload_buff,unsigned char length)
134:              { 
  0B23    00D5    LD	0x55,A
135:                  if(!(RF_GetStatus() & RX_DR_FLAG))
  0B24    23FB    CALL	0x3FB
  0B25    158A    SETB	0xA,3
  0B26    00D4    LD	0x54,A
  0B27    1F54    SNZB	0x54,6
136:                  {
137:                    return 0;                                                                 		
  0B28    3400    RET	0x0
138:                  }
139:              	RF_Read_Buff(R_RX_PAYLOAD, payload_buff, length);
  0B29    0855    LD	A,0x55
  0B2A    00CF    LD	0x4F,A
  0B2B    0853    LD	A,0x53
  0B2C    00D0    LD	0x50,A
  0B2D    3061    LDIA	0x61
  0B2E    2334    CALL	0x334
  0B2F    158A    SETB	0xA,3
140:              	
141:              	RF_ClearFIFO();
  0B30    23FF    CALL	0x3FF
  0B31    158A    SETB	0xA,3
142:              	RF_ClearStatus();
  0B32    240F    CALL	0x40F
143:                  return 1;
  0B33    3401    RET	0x1
144:              }
145:              
146:              /******************************************************************************/
147:              //            RF_ENHANCE_RxDataǿģʽ
148:              //            յݣ
149:              //            
150:              //              1. payload_buff洢ȡݵBuffer
151:              //              2. length:    ȡݳ
152:              //              3. postback_buff :ͻشݸͶ
153:              //              Return:
154:              //              1. 0: ûнյ
155:              //              2. 1: ȡյݳɹ
156:              //              note: Only use in Rx Mode
157:              //              length ͨ PAYLOAD_WIDTH
158:              /******************************************************************************/
159:              unsigned char RF_ENHANCE_RxData(unsigned char *payload_buff,unsigned char length,unsigned char *postback_buff)
160:              { 
161:                  if(!(RF_GetStatus() & RX_DR_FLAG))
162:                  {
163:                    return 0;                                                                 		
164:                  }
165:              	#if	(TRANSMIT_TYPE == TRANS_ENHANCE_MODE)			//ACK_PAYLOADģʽ
166:              	RF_Write_Buff(W_ACK_PAYLOAD, postback_buff, ACK_PAYLOAD_WIDTH);
167:              	delay_ms(2);
168:              	//̬RXݿ Ҫʹ̬ܶ1D ̬1CҪACK   
169:              	RF_Read_Buff(R_RX_PAYLOAD, payload_buff, length);  
170:              	
171:              	#else
172:              	RF_Read_Buff(R_RX_PAYLOAD, payload_buff, length);
173:              	#endif       //յݶucPayloadrxfifo
174:              	
175:              	RF_ClearFIFO();
176:              	RF_ClearStatus();
177:                  return 1;
178:              }
179:              /******************************************************************************/
180:              //           ͨģʽ ݣ
181:              //            
182:              //              1. payload_buffҪ͵׵ַ
183:              //              2. length:  Ҫ͵ݳ
184:              //              Return:
185:              //              1. MAX_RT: TX Failure  (Enhance mode)
186:              //              2. TX_DS:  TX Successful (Enhance mode)
187:              //              note: Only use in Tx Mode
188:              //              length ͨ PAYLOAD_WIDTH
189:              //            ͽ
190:              //            ֻǿģʽ£ʹackPayloadЧ
191:              //                  1ucAckPayload: AckPayload׵ַ
192:              //                  2lengthAckPayloadĳ
193:              /******************************************************************************/
194:              void RF_TxData(unsigned char *payload_buff,unsigned char length)
195:              {
196:              	unsigned char ret;
197:                  RF_Write_Buff(W_TX_PAYLOAD, payload_buff, length);                               		//write data to txfifo                                                                      		//rf entery tx mode start send data                                                                       		//rf entery stb3
198:                  delay_ms(3);
199:              	
200:              	RF_ClearFIFO();
201:              	RF_ClearStatus();
202:              }
203:              
204:              /******************************************************************************/
205:              //            ǿģʽ·ݣ
206:              //            
207:              //              1. payload_buffҪ͵׵ַ
208:              //              2. length:  Ҫ͵ݳ
209:              //              3. postback_buffɽն˻ش
210:              //              Return:
211:              //              1. MAX_RT: TX Failure  (Enhance mode)
212:              //              2. TX_DS:  TX Successful (Enhance mode)
213:              //              note: Only use in Tx Mode
214:              //              length ͨ PAYLOAD_WIDTH
215:              //            ͽ
216:              //            ֻǿģʽ£ʹackPayloadЧ
217:              //                  1ucAckPayload: AckPayload׵ַ
218:              //                  2lengthAckPayloadĳ
219:              /******************************************************************************/
220:              void RF_ENHANCE_TxData(unsigned char *payload_buff,unsigned char length,unsigned char *postback_buff)
221:              {
222:              	unsigned char ret;
223:                  RF_Write_Buff(W_TX_PAYLOAD, payload_buff, length);                               		//write data to txfifo                                                                      		//rf entery tx mode start send data                                                                       		//rf entery stb3
224:                  delay_ms(2);
225:              	#if	(TRANSMIT_TYPE == TRANS_ENHANCE_MODE)			//ACK_PAYLOADģʽ
226:              	ret = RF_GetStatus();
227:              	if(RF_GetStatus() == RX_TX_FLAG)
228:              	{
229:              		RF_Read_Buff(R_RX_PAYLOAD,postback_buff,ACK_PAYLOAD_WIDTH);//payload_buffѽյٷ͹ȥ feedback_buff 
230:              	}
231:              	#endif       //յݶucPayloadrxfifo
232:              	
233:              	RF_ClearFIFO();
234:              	RF_ClearStatus();
235:              }
236:              
237:              void RF_SetChannel(unsigned char Channel)
238:              {    
239:                  RF_WriteReg(W_REGISTER + RF_CH, Channel);
240:              }
241:              
242:              void RF_ClearFIFO(void)
243:              {
  0BFF    30E1    LDIA	0xE1
244:                  RF_WriteReg(FLUSH_TX, 0);			                                		//RF  TX FIFO		
  0C00    01F5    CLR	0x75
  0C01    23C1    CALL	0x3C1
  0C02    158A    SETB	0xA,3
  0C03    30E2    LDIA	0xE2
245:                  RF_WriteReg(FLUSH_RX, 0);                                                   		//RF  RX FIFO	
  0C04    01F5    CLR	0x75
  0C05    2BC1    JP	0x3C1
246:              }
247:              
248:              void RF_ClearStatus(void)
249:              {
250:                  RF_WriteReg(W_REGISTER + STATUS,0x70);							//RFIRQ־ 
  0C0F    3070    LDIA	0x70
  0C10    00F5    LD	0x75,A
  0C11    3027    LDIA	0x27
  0C12    2BC1    JP	0x3C1
251:              }
252:              
253:              unsigned char RF_GetStatus(void)
254:              {
255:                  return RF_ReadReg(STATUS)&0x70;		//ȡRF״̬ 
  0BFB    3007    LDIA	0x7
  0BFC    2406    CALL	0x406
  0BFD    3970    ANDIA	0x70
  0BFE    0008    RET
256:              }
257:              
258:              void RF_Set_TxMode(void)
259:              {
260:                  RF_WriteReg(W_REGISTER + CONFIG,  0X8E);							// RFóTXģʽ
261:                  delay_ms(10);   
262:                  CE_HIGH;	
263:                  delay_ms(10);
264:              }
265:              
266:              void RF_Set_RxMode(void)
267:              {
268:                  RF_WriteReg(W_REGISTER + CONFIG,  0X87);							// RFóTXģʽ
  0C13    3087    LDIA	0x87
  0C14    00F5    LD	0x75,A
  0C15    3020    LDIA	0x20
  0C16    158A    SETB	0xA,3
  0C17    23C1    CALL	0x3C1
  0C18    158A    SETB	0xA,3
269:                  delay_ms(10);   
  0C19    300A    LDIA	0xA
  0C1A    00F3    LD	0x73,A
  0C1B    01F4    CLR	0x74
  0C1C    26DD    CALL	0x6DD
  0C1D    158A    SETB	0xA,3
  0C1E    300A    LDIA	0xA
270:                  CE_HIGH;	
  0C1F    1785    SETB	0x5,7
271:                  delay_ms(10);
  0C20    00F3    LD	0x73,A
  0C21    01F4    CLR	0x74
  0C22    2EDD    JP	0x6DD
272:              }
273:              
274:              void RF_Read_Buff(unsigned char reg_addr, unsigned char *pBuff, unsigned char length)
275:              {
  0B34    00D1    LD	0x51,A
276:                  unsigned char byte_ctr;
277:                  CSN_LOW;                    		                               			
  0B35    1109    CLRB	0x9,2
278:                  SPI_RW(reg_addr);       		                                                		
  0B36    23DF    CALL	0x3DF
  0B37    158A    SETB	0xA,3
279:                  for(byte_ctr=0;byte_ctr<length;byte_ctr++){
  0B38    01D2    CLR	0x52
  0B39    0850    LD	A,0x50
  0B3A    0252    SUBA	0x52
  0B3B    1803    SZB	0x3,0
  0B3C    2B48    JP	0x348
280:                  	pBuff[byte_ctr] = SPI_RW(0);         
  0B3D    0852    LD	A,0x52
  0B3E    074F    ADDA	0x4F
  0B3F    00F5    LD	0x75,A
  0B40    0084    LD	0x4,A
  0B41    3000    LDIA	0x0
  0B42    23DF    CALL	0x3DF
  0B43    158A    SETB	0xA,3
  0B44    1383    CLRB	0x3,7
  0B45    0080    LD	0x0,A
  0B46    0AD2    INCR	0x52
  0B47    2B39    JP	0x339
281:              	}                                        		
282:                  CSN_HIGH;                                                                   		
  0B48    1509    SETB	0x9,2
  0B49    0008    RET
283:              }
284:              
285:              void RF_Write_Buff(unsigned char reg_addr,unsigned char *pBuff,unsigned char length)
286:              {
  0BCA    00D1    LD	0x51,A
287:                  unsigned char i;
288:                  CSN_LOW;
  0BCB    1109    CLRB	0x9,2
289:                  SPI_RW(reg_addr);
  0BCC    23DF    CALL	0x3DF
  0BCD    158A    SETB	0xA,3
290:                  for(i=0;i<length;i++)
  0BCE    01D2    CLR	0x52
  0BCF    0850    LD	A,0x50
  0BD0    0252    SUBA	0x52
  0BD1    1803    SZB	0x3,0
  0BD2    2BDD    JP	0x3DD
291:                  {
292:                      SPI_RW(pBuff[i]);
  0BD3    0852    LD	A,0x52
  0BD4    074F    ADDA	0x4F
  0BD5    0084    LD	0x4,A
  0BD6    158A    SETB	0xA,3
  0BD7    2000    CALL	0x0
  0BD8    158A    SETB	0xA,3
  0BD9    23DF    CALL	0x3DF
  0BDA    158A    SETB	0xA,3
  0BDB    0AD2    INCR	0x52
  0BDC    2BCF    JP	0x3CF
293:                  }
294:                  CSN_HIGH;
  0BDD    1509    SETB	0x9,2
  0BDE    0008    RET
295:              }
296:              
297:              void RF_WriteReg(unsigned char reg_addr, unsigned char write_data)
298:              {
  0BC1    1283    CLRB	0x3,5
  0BC2    00CF    LD	0x4F,A
299:                  CSN_LOW;
  0BC3    1109    CLRB	0x9,2
300:                  SPI_RW(reg_addr);
  0BC4    23DF    CALL	0x3DF
  0BC5    158A    SETB	0xA,3
301:                  SPI_RW(write_data);
  0BC6    0875    LD	A,0x75
  0BC7    23DF    CALL	0x3DF
302:                  CSN_HIGH;
  0BC8    1509    SETB	0x9,2
  0BC9    0008    RET
303:              }
304:              
305:              unsigned char RF_ReadReg(unsigned char reg_addr)
306:              {
  0C06    00CF    LD	0x4F,A
307:              	unsigned char tmp;
308:                  CSN_LOW;
  0C07    1109    CLRB	0x9,2
309:                  SPI_RW(reg_addr);
  0C08    23DF    CALL	0x3DF
  0C09    158A    SETB	0xA,3
310:                  tmp = SPI_RW(0);
  0C0A    3000    LDIA	0x0
  0C0B    23DF    CALL	0x3DF
  0C0C    00D0    LD	0x50,A
311:                  CSN_HIGH;
  0C0D    1509    SETB	0x9,2
312:                  return tmp;
  0C0E    0008    RET
313:              }
314:              
315:              static void SPI_init(void)
316:              {
317:              	
318:              	SPI_CSN_IO =0;	
  0BF4    1109    CLRB	0x9,2
319:              	SPI_SCK_IO=0;	
  0BF5    1089    CLRB	0x9,1
320:              	SPI_MOSI_IO=0;	
  0BF6    1285    CLRB	0x5,5
321:              	SPI_CE_IO = 0;
  0BF7    1385    CLRB	0x5,7
322:              
323:              	SPI_IRQ_IO = 1;
  0BF8    1585    SETB	0x5,3
324:              	SPI_MISO_IO=1;
  0BF9    1605    SETB	0x5,4
  0BFA    0008    RET
325:              }
326:              
327:              /******************************************************************************
328:              * SPIдһBYTEͬʱһBYTE
329:              ******************************************************************************/
330:              static unsigned char SPI_RW(unsigned char read_reg_addr)
331:              {
  0BDF    00F3    LD	0x73,A
332:                  unsigned char i;
333:                  for(i = 0; i < 8; i++)
  0BE0    01F4    CLR	0x74
334:                  {
335:                      SCK_LOW;
  0BE1    1089    CLRB	0x9,1
336:                      if(read_reg_addr & 0x80)
  0BE2    1FF3    SNZB	0x73,7
  0BE3    2BE6    JP	0x3E6
337:                      {
338:                          MOSI_HIGH;
  0BE4    1685    SETB	0x5,5
339:                      }
  0BE5    2BE7    JP	0x3E7
340:                      else
341:                      {
342:                          MOSI_LOW;
  0BE6    1285    CLRB	0x5,5
343:                      }
344:                      read_reg_addr = read_reg_addr << 1;
  0BE7    1003    CLRB	0x3,0
  0BE8    0DF3    RLCR	0x73
345:                      SCK_HIGH;
  0BE9    1489    SETB	0x9,1
346:                      if( MISO )
  0BEA    1A05    SZB	0x5,4
347:                      {
348:                        read_reg_addr = read_reg_addr | 0x01;
  0BEB    1473    SETB	0x73,0
  0BEC    3008    LDIA	0x8
  0BED    0AF4    INCR	0x74
  0BEE    0274    SUBA	0x74
349:                      }
350:                  }
351:                  SCK_LOW;
  0BEF    1089    CLRB	0x9,1
  0BF0    1C03    SNZB	0x3,0
  0BF1    2BE2    JP	0x3E2
352:                  return read_reg_addr;
  0BF2    0873    LD	A,0x73
  0BF3    0008    RET
353:              }
354:              
355:              /******************************************************************************/
356:              //            		RFģʽ
357:              /******************************************************************************/
358:              void RF_Sleep()
359:              {
360:              	unsigned char reg_config;
361:              	reg_config = RF_ReadReg(CONFIG);
362:              	RF_WriteReg(W_REGISTER + CONFIG, reg_config & (~(0x02))); 
363:              	CE_LOW;
364:              }
365:              
366:              
367:              /******************************************************************************/
368:              //            		RFģʽл
369:              /******************************************************************************/
370:              void RF_awaken()
371:              {
372:              	unsigned char reg_config;
373:              	reg_config = RF_ReadReg(CONFIG);
374:              	RF_WriteReg(W_REGISTER + CONFIG, reg_config | 0x02); 
375:              	CE_HIGH;
376:              	delay_ms(7);
377:              }
378:              
379:              /******************************************************************************/
380:              //            		زģʽ
381:              /******************************************************************************/
382:              void RF_Carrier(unsigned char Channel)
383:              {
384:                  const unsigned char  BB_cal_data[]    = {0x0A,0x6D,0x67,0x9C,0x46};
385:                  const unsigned char  RF_cal_data[]    = {0x16,0x33,0x27};                                       
386:                  const unsigned char  RF_cal2_data[]   = {0x45,0x21,0x3F,0x2D,0x5C,0x40};
387:                  const unsigned char  Dem_cal_data[]   = {0xE1};
388:                  const unsigned char  Dem_cal2_data[]  = {0x0B,0xDF,0x02};
389:                  CE_LOW;
390:                  delay_ms(1);				 						                    //delay 500us
391:                  RF_WriteReg(W_REGISTER + CONFIG, 0X8e);        					         	//tx mode 
392:                  RF_WriteReg(W_REGISTER + RF_CH, Channel);						        //زƵ	   
393:                  RF_WriteReg(W_REGISTER + RF_SETUP, RF_POWER);      					     	//dbm
394:                  RF_Write_Buff(W_REGISTER + BB_CAL,    BB_cal_data,  sizeof(BB_cal_data));
395:                  RF_Write_Buff(W_REGISTER + RF_CAL2,   RF_cal2_data, sizeof(RF_cal2_data));
396:                  RF_Write_Buff(W_REGISTER + DEM_CAL,   Dem_cal_data, sizeof(Dem_cal_data));
397:                  RF_Write_Buff(W_REGISTER + RF_CAL,    RF_cal_data,  sizeof(RF_cal_data));
398:                  RF_Write_Buff(W_REGISTER + DEM_CAL2,  Dem_cal2_data,sizeof(Dem_cal2_data));
399:                  delay_ms(1);
400:              }
401:              
402:              
---- C:\item\pan2416\gitforpan2416\PAV03new\FWSWES-PAV03-SCENESWITCHES-PAN2416AV\src\iic.c ----------------------------------------------------------------------
1:                #include "iic.h"
2:                #include "cms.h"
3:                
4:                
5:                void iic_delay_us(unsigned char delay)
6:                {
  0FE3    00F3    LD	0x73,A
7:                	while(delay--);
  0FE4    03F3    DECR	0x73
  0FE5    0873    LD	A,0x73
  0FE6    3AFF    XORIA	0xFF
  0FE7    1903    SZB	0x3,2
  0FE8    0008    RET
  0FE9    2FE4    JP	0x7E4
8:                }
9:                
10:               void IIC_Init(void)
11:               {
12:               	OPTION_REG &= ~0x80;
  091F    1683    SETB	0x3,5
  0920    1303    CLRB	0x3,6
  0921    1381    CLRB	0x1,7
13:               //	TRISC&=~(3<<1);
14:               	SDA_H;
  0922    1283    CLRB	0x3,5
  0923    1487    SETB	0x7,1
15:               	SCL_H;
  0924    1507    SETB	0x7,2
  0925    0008    RET
16:               }
17:               
18:               
19:               void IIC_START(void)
20:               {
21:                   SDA_OUT;
  0FEA    1683    SETB	0x3,5
  0FEB    1087    CLRB	0x7,1
22:                   SDA_H;
  0FEC    1283    CLRB	0x3,5
  0FED    3001    LDIA	0x1
  0FEE    1487    SETB	0x7,1
23:                   SCL_H;
  0FEF    1507    SETB	0x7,2
24:                   iic_delay_us(1);
  0FF0    27E3    CALL	0x7E3
  0FF1    158A    SETB	0xA,3
  0FF2    3001    LDIA	0x1
25:                   SDA_L; //START:when CLK is high,SDA change from hig to low
  0FF3    1087    CLRB	0x7,1
26:                   iic_delay_us(1);
  0FF4    27E3    CALL	0x7E3
27:                   SCL_L; //Ready Transmit or Receive
  0FF5    1107    CLRB	0x7,2
  0FF6    0008    RET
28:               }
29:               
30:               
31:               void IIC_STOP(void)
32:               {
33:                   SDA_OUT;
  0FF7    1683    SETB	0x3,5
  0FF8    1087    CLRB	0x7,1
34:                   SDA_L;
  0FF9    1283    CLRB	0x3,5
  0FFA    3001    LDIA	0x1
  0FFB    1087    CLRB	0x7,1
35:                   SCL_H; 
  0FFC    1507    SETB	0x7,2
36:                   iic_delay_us(1);
  0FFD    27E3    CALL	0x7E3
37:                   SDA_H; //STOP:when CLK is low,SDA change from low to high
  0FFE    1487    SETB	0x7,1
38:               }
39:               
40:               
41:               unsigned char IIC_Wait_ACK(void)
42:               {
43:                   unsigned char RE = 0;
44:               	SDA_OUT;
  0FB5    1683    SETB	0x3,5
  0FB6    1087    CLRB	0x7,1
45:               	SDA_H;
  0FB7    1283    CLRB	0x3,5
  0FB8    1487    SETB	0x7,1
46:               	SDA_IN;
  0FB9    1683    SETB	0x3,5
  0FBA    1487    SETB	0x7,1
  0FBB    1703    SETB	0x3,6
  0FBC    148F    SETB	0xF,1
47:               	
48:               	SCL_L;  
  0FBD    1283    CLRB	0x3,5
  0FBE    3001    LDIA	0x1
  0FBF    1303    CLRB	0x3,6
  0FC0    1107    CLRB	0x7,2
49:                   iic_delay_us(1);
  0FC1    27E3    CALL	0x7E3
  0FC2    158A    SETB	0xA,3
  0FC3    3001    LDIA	0x1
50:               	SCL_H;
  0FC4    1507    SETB	0x7,2
51:               	iic_delay_us(1);   
  0FC5    27E3    CALL	0x7E3
52:                   
53:                  if(IIC_SDA)
  0FC6    1107    CLRB	0x7,2
  0FC7    0008    RET
54:                  	{
55:                  		RE=1;
56:                  	}
57:                  else
58:                  	{
59:               		RE=0;
60:                  	}
61:                   SCL_L; //ʱ0
62:                   return RE;
63:               
64:               }
65:               
66:               void IIC_ACK(void)
67:               {
68:                   SDA_OUT;
  0C23    1683    SETB	0x3,5
  0C24    1087    CLRB	0x7,1
69:                   SDA_L;
  0C25    1283    CLRB	0x3,5
  0C26    3001    LDIA	0x1
  0C27    1087    CLRB	0x7,1
70:                   iic_delay_us(1);
  0C28    27E3    CALL	0x7E3
  0C29    158A    SETB	0xA,3
  0C2A    3001    LDIA	0x1
71:                   SCL_H;
  0C2B    1507    SETB	0x7,2
72:                   iic_delay_us(1);
  0C2C    27E3    CALL	0x7E3
73:                   SCL_L;
  0C2D    1107    CLRB	0x7,2
74:                   SDA_H;
  0C2E    1487    SETB	0x7,1
  0C2F    0008    RET
75:               }
76:               
77:               void IIC_NACK(void)
78:               {
  0C30    3001    LDIA	0x1
79:               	SDA_H;	/* CPU?y?SDA = 1 */
  0C31    1487    SETB	0x7,1
80:               	iic_delay_us(1);
  0C32    27E3    CALL	0x7E3
  0C33    158A    SETB	0xA,3
  0C34    3001    LDIA	0x1
81:               	SCL_H;	/* CPU21??? */
  0C35    1507    SETB	0x7,2
82:               	iic_delay_us(1);
  0C36    27E3    CALL	0x7E3
  0C37    158A    SETB	0xA,3
  0C38    3001    LDIA	0x1
83:               	SCL_L;
  0C39    1107    CLRB	0x7,2
84:               	iic_delay_us(1);	
  0C3A    2FE3    JP	0x7E3
85:               }
86:               
87:               
88:               
89:               
90:               void I2C_SendByte(unsigned char Data)
91:               {
  0FC8    00F4    LD	0x74,A
92:                 unsigned char cnt;
93:                 SDA_OUT;
  0FC9    1683    SETB	0x3,5
  0FCA    1087    CLRB	0x7,1
94:                 for(cnt=0; cnt<8; cnt++)
  0FCB    01F5    CLR	0x75
95:                 {
96:               
97:                
98:                   if(Data & 0x80)
  0FCC    1FF4    SNZB	0x74,7
  0FCD    2FD1    JP	0x7D1
99:                   {
100:                    SDA_H;                         
  0FCE    1283    CLRB	0x3,5
  0FCF    1487    SETB	0x7,1
101:                  }
  0FD0    2FD3    JP	0x7D3
102:                  else
103:                  {
104:                    SDA_L;                         
  0FD1    1283    CLRB	0x3,5
  0FD2    1087    CLRB	0x7,1
  0FD3    3001    LDIA	0x1
105:                  }
106:                  Data <<= 1;
  0FD4    1003    CLRB	0x3,0
  0FD5    0DF4    RLCR	0x74
107:                  SCL_H;                              
  0FD6    1507    SETB	0x7,2
108:                  iic_delay_us(1);
  0FD7    27E3    CALL	0x7E3
  0FD8    158A    SETB	0xA,3
  0FD9    3001    LDIA	0x1
109:                  SCL_L;                              
  0FDA    1107    CLRB	0x7,2
110:                  iic_delay_us(1);
  0FDB    27E3    CALL	0x7E3
  0FDC    158A    SETB	0xA,3
  0FDD    3008    LDIA	0x8
  0FDE    0AF5    INCR	0x75
  0FDF    0275    SUBA	0x75
  0FE0    1803    SZB	0x3,0
  0FE1    0008    RET
  0FE2    2FCC    JP	0x7CC
111:              //    if(cnt==7)SDA_H; 
112:                }
113:              }
114:              
115:              
116:              unsigned int I2C_ReadByte(unsigned char ack)
117:              {
  0C3B    00CF    LD	0x4F,A
118:                unsigned char cnt;
119:                unsigned int data;
120:                SDA_IN;	
  0C3C    1683    SETB	0x3,5
  0C3D    1487    SETB	0x7,1
  0C3E    1703    SETB	0x3,6
  0C3F    148F    SETB	0xF,1
121:              	
122:                for(cnt=0; cnt<8; cnt++)
  0C40    1283    CLRB	0x3,5
  0C41    1303    CLRB	0x3,6
  0C42    01D2    CLR	0x52
  0C43    3001    LDIA	0x1
123:                {
124:                  SCL_L;                                
  0C44    1107    CLRB	0x7,2
125:                  iic_delay_us(1);
  0C45    27E3    CALL	0x7E3
  0C46    158A    SETB	0xA,3
126:              		
127:                  SCL_H;                             
  0C47    1507    SETB	0x7,2
128:                  data <<= 1;
  0C48    1003    CLRB	0x3,0
  0C49    0DD0    RLCR	0x50
  0C4A    0DD1    RLCR	0x51
129:                  if(IIC_SDA)
  0C4B    1887    SZB	0x7,1
130:                  {
131:                    data |= 0x01;                              
  0C4C    1450    SETB	0x50,0
132:                  }
133:                   iic_delay_us(1);
  0C4D    3001    LDIA	0x1
  0C4E    27E3    CALL	0x7E3
  0C4F    158A    SETB	0xA,3
  0C50    3008    LDIA	0x8
  0C51    0AD2    INCR	0x52
  0C52    0252    SUBA	0x52
  0C53    1C03    SNZB	0x3,0
  0C54    2C43    JP	0x443
134:                }
135:                if(ack == 0)
  0C55    08CF    TESTZ	0x4F
  0C56    1D03    SNZB	0x3,2
  0C57    2C5B    JP	0x45B
136:                {
137:                   IIC_NACK();
  0C58    2430    CALL	0x430
  0C59    158A    SETB	0xA,3
138:                }
  0C5A    2C5C    JP	0x45C
139:                else
140:                {
141:                   IIC_ACK();
  0C5B    2423    CALL	0x423
142:                }
143:                return data;                                  
  0C5C    0851    LD	A,0x51
  0C5D    00F5    LD	0x75,A
  0C5E    0850    LD	A,0x50
  0C5F    00F4    LD	0x74,A
  0C60    0008    RET
144:              }
145:              
146:              
147:              
148:              
149:              
150:              
151:              
---- C:\item\pan2416\gitforpan2416\PAV03new\FWSWES-PAV03-SCENESWITCHES-PAN2416AV\src\e2prom.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "iic.h"
3:                #include "e2prom.h"
4:                #include "delay.h"
5:                
6:                
7:                
8:                void AT24C02_Write_Byte(unsigned char addr ,unsigned char data)
9:                {
  0F86    00D0    LD	0x50,A
10:               	IIC_START();
  0F87    27EA    CALL	0x7EA
  0F88    158A    SETB	0xA,3
11:               	I2C_SendByte(0XA0);	 
  0F89    30A0    LDIA	0xA0
  0F8A    27C8    CALL	0x7C8
  0F8B    158A    SETB	0xA,3
12:               	IIC_Wait_ACK(); 
  0F8C    27B5    CALL	0x7B5
  0F8D    158A    SETB	0xA,3
13:               	I2C_SendByte(addr);
  0F8E    0850    LD	A,0x50
  0F8F    27C8    CALL	0x7C8
  0F90    158A    SETB	0xA,3
14:               	IIC_Wait_ACK(); 
  0F91    27B5    CALL	0x7B5
  0F92    158A    SETB	0xA,3
15:               	I2C_SendByte(data);
  0F93    084F    LD	A,0x4F
  0F94    27C8    CALL	0x7C8
  0F95    158A    SETB	0xA,3
16:               	IIC_Wait_ACK(); 
  0F96    27B5    CALL	0x7B5
  0F97    158A    SETB	0xA,3
17:               	IIC_STOP();	
  0F98    2FF7    JP	0x7F7
18:               }
19:               
20:               unsigned char AT24C02_Read_Byte(unsigned char addr)
21:               {
  0F99    00D3    LD	0x53,A
22:               	unsigned char temp = 0;		  	    																 
23:                  	IIC_START();
  0F9A    27EA    CALL	0x7EA
  0F9B    158A    SETB	0xA,3
24:               
25:               	I2C_SendByte(0XA0);	   		
  0F9C    30A0    LDIA	0xA0
  0F9D    27C8    CALL	0x7C8
  0F9E    158A    SETB	0xA,3
26:               	IIC_Wait_ACK();
  0F9F    27B5    CALL	0x7B5
  0FA0    158A    SETB	0xA,3
27:               	I2C_SendByte(addr);			    	 	   
  0FA1    0853    LD	A,0x53
  0FA2    27C8    CALL	0x7C8
  0FA3    158A    SETB	0xA,3
28:               	IIC_Wait_ACK(); 
  0FA4    27B5    CALL	0x7B5
  0FA5    158A    SETB	0xA,3
29:               //  I2C_SendByte(addr%256);   		
30:               //	IIC_Wait_ACK();	    
31:               	IIC_START(); 	 	   
  0FA6    27EA    CALL	0x7EA
  0FA7    158A    SETB	0xA,3
32:               	I2C_SendByte(0XA1);           				   
  0FA8    30A1    LDIA	0xA1
  0FA9    27C8    CALL	0x7C8
  0FAA    158A    SETB	0xA,3
33:               	IIC_Wait_ACK();	 
  0FAB    27B5    CALL	0x7B5
  0FAC    158A    SETB	0xA,3
34:               	temp = I2C_ReadByte(1);		   
  0FAD    3001    LDIA	0x1
  0FAE    243B    CALL	0x43B
  0FAF    158A    SETB	0xA,3
  0FB0    0874    LD	A,0x74
  0FB1    00D4    LD	0x54,A
35:                  	IIC_STOP();								   
  0FB2    27F7    CALL	0x7F7
36:               	
37:               	return temp;
  0FB3    0854    LD	A,0x54
  0FB4    0008    RET
38:               }
39:               
40:               void AT24C02_Write_Msg(unsigned char addr ,unsigned char *data,unsigned char len)
41:               {
  0F6D    00D6    LD	0x56,A
42:               	unsigned char i=0;
  0F6E    01D7    CLR	0x57
43:               	for(i=0;i<len;i++)
  0F6F    01D7    CLR	0x57
  0F70    0854    LD	A,0x54
  0F71    0257    SUBA	0x57
  0F72    1803    SZB	0x3,0
  0F73    0008    RET
44:               	{
45:               	AT24C02_Write_Byte(addr,data[i]);
  0F74    0857    LD	A,0x57
  0F75    0753    ADDA	0x53
  0F76    00D5    LD	0x55,A
  0F77    0084    LD	0x4,A
  0F78    1383    CLRB	0x3,7
  0F79    0800    LD	A,0x0
  0F7A    00CF    LD	0x4F,A
  0F7B    0856    LD	A,0x56
  0F7C    2786    CALL	0x786
  0F7D    158A    SETB	0xA,3
  0F7E    3005    LDIA	0x5
46:               	addr++;
  0F7F    0AD6    INCR	0x56
47:               	soft_delay_ms(5);
  0F80    00F3    LD	0x73,A
  0F81    01F4    CLR	0x74
  0F82    26DD    CALL	0x6DD
  0F83    158A    SETB	0xA,3
  0F84    0AD7    INCR	0x57
  0F85    2F70    JP	0x770
48:               	}
49:               }
50:               
51:               
52:               void AT24C02_Read_Msg(unsigned char addr,unsigned char *data,unsigned char len)
53:               {
  0CD2    00D8    LD	0x58,A
54:               	unsigned char i=0;
  0CD3    01D9    CLR	0x59
55:               	for(i=0;i<len;i++)
  0CD4    01D9    CLR	0x59
  0CD5    0856    LD	A,0x56
  0CD6    0259    SUBA	0x59
  0CD7    1803    SZB	0x3,0
  0CD8    0008    RET
56:               	{
57:               	data[i]=AT24C02_Read_Byte(addr);
  0CD9    0859    LD	A,0x59
  0CDA    0755    ADDA	0x55
  0CDB    00D7    LD	0x57,A
  0CDC    0084    LD	0x4,A
  0CDD    0858    LD	A,0x58
  0CDE    2799    CALL	0x799
  0CDF    158A    SETB	0xA,3
  0CE0    1383    CLRB	0x3,7
  0CE1    0080    LD	0x0,A
58:               	addr++;
  0CE2    0AD8    INCR	0x58
59:               	soft_delay_ms(1);
  0CE3    01F3    CLR	0x73
  0CE4    0AF3    INCR	0x73
  0CE5    01F4    CLR	0x74
  0CE6    26DD    CALL	0x6DD
  0CE7    158A    SETB	0xA,3
  0CE8    0AD9    INCR	0x59
  0CE9    2CD5    JP	0x4D5
60:               	}
61:               }
62:               
63:               
64:               
65:               
66:               
67:               
68:               
---- C:\item\pan2416\gitforpan2416\PAV03new\FWSWES-PAV03-SCENESWITCHES-PAN2416AV\src\key_scan.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "key_scan.h"
3:                #include "timer1.h"
4:                #include "PORTB_interrupt.h"
5:                #include "recive.h"
6:                #include "delay.h"
7:                #include "system.h"
8:                #include "e2prom.h"
9:                
10:               unsigned char  KEY0_FLAG = 0;
11:               unsigned char  KEY1_FLAG = 0;
12:               unsigned char  KEY2_FLAG = 0;
13:               
14:               uint16_t flag_time_key0_add = 0;
15:               uint16_t flag_time_key1_add = 0;
16:               uint16_t flag_time_key2_add = 0;
17:               
18:               channel_flag_stu KEY0 = 0;
19:               channel_flag_stu KEY1 = 0;
20:               channel_flag_stu KEY2 = 0;
21:               
22:               unsigned char key_long_flag = 0;
23:               
24:               extern unsigned char sys_stute ;
25:               unsigned char match_channel_flag = 0x10;  /**< Channel 0 pairing*/
26:               unsigned char key_long_flag_add = 0;
27:               
28:               extern uint8_t channel_status;
29:               extern uint8_t channel_startup;
30:               
31:               void sledBlink(void)
32:               {
33:                   LED_ON;                                      
  0ED0    1683    SETB	0x3,5
  0ED1    1007    CLRB	0x7,0
  0ED2    1283    CLRB	0x3,5
  0ED3    3064    LDIA	0x64
  0ED4    1007    CLRB	0x7,0
34:                   soft_delay_ms(100);
  0ED5    00F3    LD	0x73,A
  0ED6    01F4    CLR	0x74
  0ED7    26DD    CALL	0x6DD
35:                   LED_OFF;
  0ED8    1683    SETB	0x3,5
  0ED9    1007    CLRB	0x7,0
  0EDA    1283    CLRB	0x3,5
  0EDB    1407    SETB	0x7,0
  0EDC    0008    RET
36:               }
37:               
38:               void setChannelStatus(unsigned char  channel, unsigned char  status)
39:               {
  0EF9    00DA    LD	0x5A,A
40:                   if (channel == CHANNEL_0)
  0EFA    08DA    TESTZ	0x5A
  0EFB    1D03    SNZB	0x3,2
  0EFC    2F1E    JP	0x71E
41:                   {
42:                       if (status == CHANNEL_OFF)
  0EFD    08D8    TESTZ	0x58
  0EFE    1D03    SNZB	0x3,2
  0EFF    2F02    JP	0x702
43:                       {
44:                           KEY0.channel_status = 0;
  0F00    01A0    CLR	0x20
45:                       }
  0F01    2F0D    JP	0x70D
46:                       else if (status == CHANNEL_ON)
  0F02    0B58    SZDECA	0x58
  0F03    2F07    JP	0x707
47:                       {
48:                           KEY0.channel_status = 1;
  0F04    01A0    CLR	0x20
  0F05    0AA0    INCR	0x20
49:                       }
  0F06    2F0D    JP	0x70D
50:                       else if (status == CHANNEL_SW)
  0F07    0858    LD	A,0x58
  0F08    3A02    XORIA	0x2
  0F09    1D03    SNZB	0x3,2
  0F0A    2F0D    JP	0x70D
51:                       {
52:                           KEY0.channel_status ^= 1;
  0F0B    3001    LDIA	0x1
  0F0C    06A0    XORR	0x20
53:                       }
54:               
55:                       if (STARTUP_STAY == getChnStartupConfig(channel_startup, CHANNEL_0))
  0F0D    084C    LD	A,0x4C
  0F0E    3903    ANDIA	0x3
  0F0F    3A02    XORIA	0x2
  0F10    1D03    SNZB	0x3,2
  0F11    0008    RET
56:                       {
57:                           if (KEY0.channel_status == CHANNEL_OFF)
  0F12    08A0    TESTZ	0x20
  0F13    1D03    SNZB	0x3,2
  0F14    2F17    JP	0x717
58:                           {
59:                               setChannelOff(channel_status, CHANNEL_0);
  0F15    104D    CLRB	0x4D,0
60:                           }
  0F16    2F18    JP	0x718
61:                           else
62:                           {
63:                               setChannelOn(channel_status, CHANNEL_0);
  0F17    144D    SETB	0x4D,0
64:                           }
65:                           AT24C02_Write_Msg(ADDR_CHN_STATUS, &channel_status, CHN_STATUS_SIZE);
  0F18    304D    LDIA	0x4D
  0F19    00D3    LD	0x53,A
  0F1A    306F    LDIA	0x6F
  0F1B    01D4    CLR	0x54
  0F1C    0AD4    INCR	0x54
  0F1D    2F6D    JP	0x76D
66:                       }
67:                   }
68:                   else if (channel == CHANNEL_1)
  0F1E    0B5A    SZDECA	0x5A
  0F1F    2F47    JP	0x747
69:                   {
70:                       if (status == CHANNEL_OFF)
  0F20    08D8    TESTZ	0x58
  0F21    1D03    SNZB	0x3,2
  0F22    2F25    JP	0x725
71:                       {
72:                           KEY1.channel_status = 0;
  0F23    01A3    CLR	0x23
73:                       }
  0F24    2F30    JP	0x730
74:                       else if (status == CHANNEL_ON)
  0F25    0B58    SZDECA	0x58
  0F26    2F2A    JP	0x72A
75:                       {
76:                           KEY1.channel_status = 1;
  0F27    01A3    CLR	0x23
  0F28    0AA3    INCR	0x23
77:                       }
  0F29    2F30    JP	0x730
78:                       else if (status == CHANNEL_SW)
  0F2A    0858    LD	A,0x58
  0F2B    3A02    XORIA	0x2
  0F2C    1D03    SNZB	0x3,2
  0F2D    2F30    JP	0x730
79:                       {
80:                           KEY1.channel_status ^= 1;
  0F2E    3001    LDIA	0x1
  0F2F    06A3    XORR	0x23
81:                       }
82:               
83:                       if (STARTUP_STAY == getChnStartupConfig(channel_startup, CHANNEL_1))
  0F30    084C    LD	A,0x4C
  0F31    00D9    LD	0x59,A
  0F32    1003    CLRB	0x3,0
  0F33    0CD9    RRCR	0x59
  0F34    1003    CLRB	0x3,0
  0F35    0CD9    RRCR	0x59
  0F36    0859    LD	A,0x59
  0F37    3903    ANDIA	0x3
  0F38    3A02    XORIA	0x2
  0F39    1D03    SNZB	0x3,2
  0F3A    0008    RET
84:                       {
85:                           if (KEY1.channel_status == CHANNEL_OFF)
  0F3B    08A3    TESTZ	0x23
  0F3C    1D03    SNZB	0x3,2
  0F3D    2F40    JP	0x740
86:                           {
87:                               setChannelOff(channel_status, CHANNEL_1);
  0F3E    10CD    CLRB	0x4D,1
88:                           }
  0F3F    2F41    JP	0x741
89:                           else
90:                           {
91:                               setChannelOn(channel_status, CHANNEL_1);
  0F40    14CD    SETB	0x4D,1
92:                           }
93:                           AT24C02_Write_Msg(ADDR_CHN_STATUS, &channel_status, CHN_STATUS_SIZE);
  0F41    304D    LDIA	0x4D
  0F42    00D3    LD	0x53,A
  0F43    306F    LDIA	0x6F
  0F44    01D4    CLR	0x54
  0F45    0AD4    INCR	0x54
  0F46    2F6D    JP	0x76D
94:                       }
95:                   }
96:                   else if (channel == CHANNEL_2)
  0F47    085A    LD	A,0x5A
  0F48    3A02    XORIA	0x2
  0F49    1D03    SNZB	0x3,2
  0F4A    0008    RET
97:                   {
98:                       if (status == CHANNEL_OFF)
  0F4B    08D8    TESTZ	0x58
  0F4C    1D03    SNZB	0x3,2
  0F4D    2F50    JP	0x750
99:                       {
100:                          KEY2.channel_status = 0;
  0F4E    01A6    CLR	0x26
101:                      }
  0F4F    2F5B    JP	0x75B
102:                      else if (status == CHANNEL_ON)
  0F50    0B58    SZDECA	0x58
  0F51    2F55    JP	0x755
103:                      {
104:                          KEY2.channel_status = 1;
  0F52    01A6    CLR	0x26
  0F53    0AA6    INCR	0x26
105:                      }
  0F54    2F5B    JP	0x75B
106:                      else if (status == CHANNEL_SW)
  0F55    0858    LD	A,0x58
  0F56    3A02    XORIA	0x2
  0F57    1D03    SNZB	0x3,2
  0F58    2F5B    JP	0x75B
107:                      {
108:                          KEY2.channel_status ^= 1;
  0F59    3001    LDIA	0x1
  0F5A    06A6    XORR	0x26
109:                      }
110:              
111:                      if (STARTUP_STAY == getChnStartupConfig(channel_startup, CHANNEL_2))
  0F5B    0E4C    SWAPA	0x4C
  0F5C    390F    ANDIA	0xF
  0F5D    3903    ANDIA	0x3
  0F5E    3A02    XORIA	0x2
  0F5F    1D03    SNZB	0x3,2
  0F60    0008    RET
112:                      {
113:                          if (KEY2.channel_status == CHANNEL_OFF)
  0F61    08A6    TESTZ	0x26
  0F62    1D03    SNZB	0x3,2
  0F63    2F66    JP	0x766
114:                          {
115:                              setChannelOff(channel_status, CHANNEL_2);
  0F64    114D    CLRB	0x4D,2
116:                          }
  0F65    2F67    JP	0x767
117:                          else
118:                          {
119:                              setChannelOn(channel_status, CHANNEL_2);
  0F66    154D    SETB	0x4D,2
120:                          }
121:                          AT24C02_Write_Msg(ADDR_CHN_STATUS, &channel_status, CHN_STATUS_SIZE);
  0F67    304D    LDIA	0x4D
  0F68    00D3    LD	0x53,A
  0F69    306F    LDIA	0x6F
  0F6A    01D4    CLR	0x54
  0F6B    0AD4    INCR	0x54
  0F6C    2F6D    JP	0x76D
122:                      }
123:                  }
124:              }
125:              
126:              
127:              void key_scan(void)
128:              {
129:              	if(RB1 == 0)
  0D66    1886    SZB	0x6,1
  0D67    2D79    JP	0x579
130:              		{
131:              			soft_delay_ms(10);
  0D68    300A    LDIA	0xA
  0D69    00F3    LD	0x73,A
  0D6A    01F4    CLR	0x74
  0D6B    26DD    CALL	0x6DD
  0D6C    158A    SETB	0xA,3
132:              			if(RB1 == 0)
  0D6D    1C86    SNZB	0x6,1
133:              			if((KEY0_FLAG&0x01) == 0)
  0D6E    1876    SZB	0x76,0
  0D6F    2D7F    JP	0x57F
134:              			{
135:              				flag_time_key0_add = 0;		/**<Long press to clear zero*/
  0D70    01B0    CLR	0x30
  0D71    01B1    CLR	0x31
136:              				KEY0_FLAG|=0X01;
  0D72    1476    SETB	0x76,0
137:              				if(key_long_flag_add == 0)
  0D73    08FA    TESTZ	0x7A
  0D74    1D03    SNZB	0x3,2
  0D75    2D7F    JP	0x57F
138:              				{
139:              					key_long_flag_add = 1;	/**<The button is long pressed*/
  0D76    01FA    CLR	0x7A
  0D77    0AFA    INCR	0x7A
  0D78    2D7F    JP	0x57F
140:              				}
141:              			}
142:              		}
143:              	else 
144:              		{
145:              			if(KEY0_FLAG&0x01)
  0D79    1C76    SNZB	0x76,0
  0D7A    2D7F    JP	0x57F
146:              			{
147:              				KEY0_FLAG |= 0X02;
  0D7B    14F6    SETB	0x76,1
148:              				if(key_long_flag_add == 1)
  0D7C    0B7A    SZDECA	0x7A
  0D7D    2D7F    JP	0x57F
149:              				{
150:              					key_long_flag_add = 0;	/**<The long press of the key has been released*/
  0D7E    01FA    CLR	0x7A
151:              				}
152:              			}
153:              		}
154:              
155:              	if(RB2 == 0)
  0D7F    1906    SZB	0x6,2
  0D80    2D92    JP	0x592
156:              		{
157:              			soft_delay_ms(10);
  0D81    300A    LDIA	0xA
  0D82    00F3    LD	0x73,A
  0D83    01F4    CLR	0x74
  0D84    26DD    CALL	0x6DD
  0D85    158A    SETB	0xA,3
158:              			if(RB2 == 0)
  0D86    1D06    SNZB	0x6,2
159:              			if((KEY1_FLAG&0x01) == 0)
  0D87    1877    SZB	0x77,0
  0D88    2D99    JP	0x599
160:              			{
161:              				flag_time_key1_add = 0;
  0D89    01B2    CLR	0x32
  0D8A    01B3    CLR	0x33
162:              				KEY1_FLAG |= 0X01;
  0D8B    1477    SETB	0x77,0
163:              				if(key_long_flag_add == 0)
  0D8C    08FA    TESTZ	0x7A
  0D8D    1D03    SNZB	0x3,2
  0D8E    2D99    JP	0x599
164:              				{
165:              					key_long_flag_add = 2;
  0D8F    3002    LDIA	0x2
  0D90    00FA    LD	0x7A,A
  0D91    2D99    JP	0x599
166:              				}			
167:              			}
168:              		
169:              		}
170:              	else 
171:              		{
172:              			if(KEY1_FLAG & 0x01)
  0D92    1C77    SNZB	0x77,0
  0D93    2D99    JP	0x599
173:              			{
174:              				KEY1_FLAG |= 0X02;
  0D94    14F7    SETB	0x77,1
175:              				if(key_long_flag_add == 2)
  0D95    087A    LD	A,0x7A
  0D96    3A02    XORIA	0x2
  0D97    1903    SZB	0x3,2
176:              				{
177:              					key_long_flag_add = 0;
  0D98    01FA    CLR	0x7A
178:              				}
179:              			}
180:              		}
181:              
182:              
183:              
184:              	
185:              
186:              	if(RB3 == 0)
  0D99    1986    SZB	0x6,3
  0D9A    2DAC    JP	0x5AC
187:              		{
188:              			soft_delay_ms(10);
  0D9B    300A    LDIA	0xA
  0D9C    00F3    LD	0x73,A
  0D9D    01F4    CLR	0x74
  0D9E    26DD    CALL	0x6DD
  0D9F    158A    SETB	0xA,3
189:              			if(RB3 == 0)
  0DA0    1D86    SNZB	0x6,3
190:              			if((KEY2_FLAG&0x01) == 0)
  0DA1    1878    SZB	0x78,0
  0DA2    2DC4    JP	0x5C4
191:              			{
192:              				flag_time_key2_add = 0;
  0DA3    01B4    CLR	0x34
  0DA4    01B5    CLR	0x35
193:              				KEY2_FLAG|=0X01;
  0DA5    1478    SETB	0x78,0
194:              				if(key_long_flag_add == 0)
  0DA6    08FA    TESTZ	0x7A
  0DA7    1D03    SNZB	0x3,2
  0DA8    2DC4    JP	0x5C4
195:              				{
196:              					key_long_flag_add = 4;
  0DA9    3004    LDIA	0x4
  0DAA    00FA    LD	0x7A,A
  0DAB    2DC4    JP	0x5C4
197:              				}
198:              			}
199:              		}
200:              	else
201:              		{
202:              			if(KEY2_FLAG & 0x01)
  0DAC    1C78    SNZB	0x78,0
  0DAD    2DC4    JP	0x5C4
203:              			{
204:              				KEY2_FLAG |= 0X02;
  0DAE    14F8    SETB	0x78,1
205:              				if(key_long_flag_add == 4)
  0DAF    087A    LD	A,0x7A
  0DB0    3A04    XORIA	0x4
  0DB1    1D03    SNZB	0x3,2
  0DB2    2DC4    JP	0x5C4
206:              				{
207:              					key_long_flag_add = 0;
  0DB3    01FA    CLR	0x7A
  0DB4    2DC4    JP	0x5C4
208:              				}
209:              			}
210:              		}
211:              
212:              
213:              	switch(key_long_flag_add)
214:              		{
215:              			case 0:
216:              				{
217:              					
218:              				}break;
219:              			case 1:
220:              				{
221:              					flag_time_key1_add = 0;	/**<Long press to clear zero*/
  0DB5    01B2    CLR	0x32
  0DB6    01B3    CLR	0x33
222:              					flag_time_key2_add = 0;
  0DB7    01B4    CLR	0x34
  0DB8    01B5    CLR	0x35
223:              				}break;
  0DB9    0008    RET
224:              			case 2:
225:              				{
226:              					flag_time_key0_add = 0;
  0DBA    01B0    CLR	0x30
  0DBB    01B1    CLR	0x31
227:              					flag_time_key2_add = 0;
  0DBC    01B4    CLR	0x34
  0DBD    01B5    CLR	0x35
228:              				}break;
  0DBE    0008    RET
229:              			case 4:
230:              				{
231:              					flag_time_key0_add = 0;
  0DBF    01B0    CLR	0x30
  0DC0    01B1    CLR	0x31
232:              					flag_time_key1_add = 0;
  0DC1    01B2    CLR	0x32
  0DC2    01B3    CLR	0x33
233:              				}break;
  0DC3    0008    RET
  0DC4    087A    LD	A,0x7A
  0DC5    3A00    XORIA	0x0
  0DC6    1903    SZB	0x3,2
  0DC7    2DD2    JP	0x5D2
  0DC8    3A01    XORIA	0x1
  0DC9    1903    SZB	0x3,2
  0DCA    2DB5    JP	0x5B5
  0DCB    3A03    XORIA	0x3
  0DCC    1903    SZB	0x3,2
  0DCD    2DBA    JP	0x5BA
  0DCE    3A06    XORIA	0x6
  0DCF    1903    SZB	0x3,2
  0DD0    2DBF    JP	0x5BF
  0DD1    2DD2    JP	0x5D2
  0DD2    0008    RET
234:              		}
235:              }
236:              
237:              
238:              
239:              
240:              void key_value_read(void)
241:              {
242:              	key_scan();
  0DD3    2566    CALL	0x566
  0DD4    158A    SETB	0xA,3
243:              	if(KEY0_FLAG == 0x01)									/**<Is it in the pressed state*/
  0DD5    0B76    SZDECA	0x76
  0DD6    2DF9    JP	0x5F9
244:              		{
245:              			 	
246:              				if(flag_time_key0_add >= 500)				/**<Determine if the long press time is greater than 5s*/
  0DD7    3001    LDIA	0x1
  0DD8    0231    SUBA	0x31
  0DD9    30F4    LDIA	0xF4
  0DDA    1903    SZB	0x3,2
  0DDB    0230    SUBA	0x30
  0DDC    1C03    SNZB	0x3,0
  0DDD    2DEC    JP	0x5EC
247:              				{
248:              					if(key_long_flag == 0x01)		/**<More than 3s*/
  0DDE    0B37    SZDECA	0x37
  0DDF    2E28    JP	0x628
249:              						{
250:              							key_long_flag = 0x10; /**<sys_stute=CLEAN_MSG*/
  0DE0    3010    LDIA	0x10
  0DE1    00B7    LD	0x37,A
251:              							sledBlink();
  0DE2    26D0    CALL	0x6D0
  0DE3    158A    SETB	0xA,3
252:              							soft_delay_ms(100);
  0DE4    3064    LDIA	0x64
  0DE5    00F3    LD	0x73,A
  0DE6    01F4    CLR	0x74
  0DE7    26DD    CALL	0x6DD
  0DE8    158A    SETB	0xA,3
253:              							sledBlink();
  0DE9    26D0    CALL	0x6D0
  0DEA    158A    SETB	0xA,3
254:              						}
255:              				}
  0DEB    2E28    JP	0x628
256:              				else if(flag_time_key0_add >= 300)	/**<Determine if the long press time is greater than 3s*/
  0DEC    3001    LDIA	0x1
  0DED    0231    SUBA	0x31
  0DEE    302C    LDIA	0x2C
  0DEF    1903    SZB	0x3,2
  0DF0    0230    SUBA	0x30
  0DF1    1C03    SNZB	0x3,0
  0DF2    2E28    JP	0x628
257:              				{
258:              					if(key_long_flag == 0)
  0DF3    08B7    TESTZ	0x37
  0DF4    1D03    SNZB	0x3,2
  0DF5    2E28    JP	0x628
259:              						{
260:              							key_long_flag = 0x01;	/**<sys_stute=MATCH_MSG*/
  0DF6    01B7    CLR	0x37
  0DF7    0AB7    INCR	0x37
  0DF8    2DE9    JP	0x5E9
261:              							sledBlink();
262:              						}
263:              				}
264:              					
265:              
266:              		}
267:              	else if(KEY0_FLAG == 0x03)							/**<Key released*/
  0DF9    0876    LD	A,0x76
  0DFA    3A03    XORIA	0x3
  0DFB    1D03    SNZB	0x3,2
  0DFC    2E28    JP	0x628
  0DFD    3001    LDIA	0x1
268:              		{
269:              			KEY0_FLAG = 0;
  0DFE    01F6    CLR	0x76
270:              			
271:              			if((flag_time_key0_add < 300))
  0DFF    0231    SUBA	0x31
  0E00    302C    LDIA	0x2C
  0E01    1903    SZB	0x3,2
  0E02    0230    SUBA	0x30
  0E03    1803    SZB	0x3,0
  0E04    2E0B    JP	0x60B
272:              			{
273:              				setChannelStatus(CHANNEL_0, CHANNEL_SW);				/**<Less than 3s state flip*/
  0E05    3002    LDIA	0x2
  0E06    00D8    LD	0x58,A
  0E07    3000    LDIA	0x0
  0E08    26F9    CALL	0x6F9
  0E09    158A    SETB	0xA,3
274:              			}
  0E0A    2E28    JP	0x628
275:              			else  if(flag_time_key0_add < 500)		/**<Less than 5s enter MATCH_MSG*/
  0E0B    3001    LDIA	0x1
  0E0C    0231    SUBA	0x31
  0E0D    30F4    LDIA	0xF4
  0E0E    1903    SZB	0x3,2
  0E0F    0230    SUBA	0x30
  0E10    1803    SZB	0x3,0
  0E11    2E1A    JP	0x61A
276:              			{
277:              				if(key_long_flag == 0x01)
  0E12    0B37    SZDECA	0x37
  0E13    2E28    JP	0x628
  0E14    3011    LDIA	0x11
278:              				{
279:              					KEY0.key_flag_3s = 1;
  0E15    01A1    CLR	0x21
  0E16    0AA1    INCR	0x21
280:              					key_long_flag = 0x11;
  0E17    00B7    LD	0x37,A
281:              					sys_stute = MATCH_MSG;
  0E18    3002    LDIA	0x2
  0E19    2E23    JP	0x623
282:              					flag_time_key1_add = 0;
  0E24    01B2    CLR	0x32
  0E25    01B3    CLR	0x33
283:              					flag_time_key2_add = 0;
  0E26    01B4    CLR	0x34
  0E27    01B5    CLR	0x35
284:              				}
285:              			}
286:              			else
287:              			{
288:              				if(key_long_flag == 0x10)			/**<Greater than 5s enter CLEAN_MSG*/
  0E1A    0837    LD	A,0x37
  0E1B    3A10    XORIA	0x10
  0E1C    1D03    SNZB	0x3,2
  0E1D    2E28    JP	0x628
  0E1E    3011    LDIA	0x11
289:              				{
290:              					KEY0.key_flag_5s = 1;
  0E1F    01A2    CLR	0x22
  0E20    0AA2    INCR	0x22
291:              					key_long_flag = 0x11;
  0E21    00B7    LD	0x37,A
292:              					sys_stute = CLEAN_MSG;
  0E22    3003    LDIA	0x3
  0E23    00EE    LD	0x6E,A
293:              					flag_time_key1_add = 0;
294:              					flag_time_key2_add = 0;
295:              				}
296:              			}
297:              				
298:              		}
299:              	
300:              
301:              	if(KEY1_FLAG == 0x01)
  0E28    0B77    SZDECA	0x77
  0E29    2E4E    JP	0x64E
302:              		{	
303:              			if(flag_time_key1_add >= 500)
  0E2A    3001    LDIA	0x1
  0E2B    0233    SUBA	0x33
  0E2C    30F4    LDIA	0xF4
  0E2D    1903    SZB	0x3,2
  0E2E    0232    SUBA	0x32
  0E2F    1C03    SNZB	0x3,0
  0E30    2E41    JP	0x641
304:              			{
305:              				if(key_long_flag == 0x02)
  0E31    0837    LD	A,0x37
  0E32    3A02    XORIA	0x2
  0E33    1D03    SNZB	0x3,2
  0E34    2E7E    JP	0x67E
306:              				{
307:              					key_long_flag = 0x20;
  0E35    3020    LDIA	0x20
  0E36    00B7    LD	0x37,A
308:              					sledBlink();
  0E37    26D0    CALL	0x6D0
  0E38    158A    SETB	0xA,3
309:              					soft_delay_ms(100);
  0E39    3064    LDIA	0x64
  0E3A    00F3    LD	0x73,A
  0E3B    01F4    CLR	0x74
  0E3C    26DD    CALL	0x6DD
  0E3D    158A    SETB	0xA,3
310:              					sledBlink();
  0E3E    26D0    CALL	0x6D0
  0E3F    158A    SETB	0xA,3
311:              				}
312:              			}
  0E40    2E7E    JP	0x67E
313:              			else if(flag_time_key1_add >= 300)
  0E41    3001    LDIA	0x1
  0E42    0233    SUBA	0x33
  0E43    302C    LDIA	0x2C
  0E44    1903    SZB	0x3,2
  0E45    0232    SUBA	0x32
  0E46    1C03    SNZB	0x3,0
  0E47    2E7E    JP	0x67E
314:              			{
315:              				if(key_long_flag == 0)
  0E48    08B7    TESTZ	0x37
  0E49    1D03    SNZB	0x3,2
  0E4A    2E7E    JP	0x67E
316:              				{
317:              					key_long_flag = 0x02;
  0E4B    3002    LDIA	0x2
  0E4C    00B7    LD	0x37,A
  0E4D    2E3E    JP	0x63E
318:              					sledBlink();
319:              				}
320:              			}
321:              			
322:              		}
323:              	else if(KEY1_FLAG == 0x03)
  0E4E    0877    LD	A,0x77
  0E4F    3A03    XORIA	0x3
  0E50    1D03    SNZB	0x3,2
  0E51    2E7E    JP	0x67E
  0E52    3001    LDIA	0x1
324:              		{
325:              			KEY1_FLAG = 0;
  0E53    01F7    CLR	0x77
326:              			if((flag_time_key1_add < 300))
  0E54    0233    SUBA	0x33
  0E55    302C    LDIA	0x2C
  0E56    1903    SZB	0x3,2
  0E57    0232    SUBA	0x32
  0E58    1803    SZB	0x3,0
  0E59    2E60    JP	0x660
327:              			{
328:              				setChannelStatus(CHANNEL_1, CHANNEL_SW);
  0E5A    3002    LDIA	0x2
  0E5B    00D8    LD	0x58,A
  0E5C    3001    LDIA	0x1
  0E5D    26F9    CALL	0x6F9
  0E5E    158A    SETB	0xA,3
329:              			}
  0E5F    2E7E    JP	0x67E
330:              			else if(flag_time_key1_add < 500)
  0E60    3001    LDIA	0x1
  0E61    0233    SUBA	0x33
  0E62    30F4    LDIA	0xF4
  0E63    1903    SZB	0x3,2
  0E64    0232    SUBA	0x32
331:              			{
332:              				if(key_long_flag == 0x02)
  0E65    0837    LD	A,0x37
  0E66    1803    SZB	0x3,0
  0E67    2E71    JP	0x671
  0E68    3A02    XORIA	0x2
  0E69    1D03    SNZB	0x3,2
  0E6A    2E7E    JP	0x67E
  0E6B    3021    LDIA	0x21
333:              				{
334:              					KEY1.key_flag_3s = 1;
  0E6C    01A4    CLR	0x24
  0E6D    0AA4    INCR	0x24
335:              					key_long_flag = 0x21;
  0E6E    00B7    LD	0x37,A
336:              					sys_stute = MATCH_MSG;
  0E6F    3002    LDIA	0x2
  0E70    2E79    JP	0x679
337:              					flag_time_key2_add = 0;
  0E7A    01B4    CLR	0x34
  0E7B    01B5    CLR	0x35
338:              						flag_time_key0_add = 0;
  0E7C    01B0    CLR	0x30
  0E7D    01B1    CLR	0x31
339:              				}
340:              			}
341:              			else
342:              			{
343:              				if(key_long_flag == 0x20)
  0E71    3A20    XORIA	0x20
  0E72    1D03    SNZB	0x3,2
  0E73    2E7E    JP	0x67E
  0E74    3021    LDIA	0x21
344:              				{
345:              					KEY1.key_flag_5s = 1;
  0E75    01A5    CLR	0x25
  0E76    0AA5    INCR	0x25
346:              					key_long_flag = 0x21;
  0E77    00B7    LD	0x37,A
347:              					sys_stute = CLEAN_MSG;
  0E78    3003    LDIA	0x3
  0E79    00EE    LD	0x6E,A
348:              					flag_time_key2_add = 0;
349:              					flag_time_key0_add = 0;
350:              				}
351:              			}
352:              		}
353:              
354:              
355:              		if(KEY2_FLAG == 0x01)
  0E7E    0B78    SZDECA	0x78
  0E7F    2EA2    JP	0x6A2
356:              		{
357:              			if(flag_time_key2_add >= 500)
  0E80    3001    LDIA	0x1
  0E81    0235    SUBA	0x35
  0E82    30F4    LDIA	0xF4
  0E83    1903    SZB	0x3,2
  0E84    0234    SUBA	0x34
  0E85    1C03    SNZB	0x3,0
  0E86    2E95    JP	0x695
358:              			{
359:              				if(key_long_flag == 0x04)
  0E87    0837    LD	A,0x37
  0E88    3A04    XORIA	0x4
  0E89    1D03    SNZB	0x3,2
  0E8A    0008    RET
360:              				{
361:              					key_long_flag = 0x40;
  0E8B    3040    LDIA	0x40
  0E8C    00B7    LD	0x37,A
362:              					sledBlink();
  0E8D    26D0    CALL	0x6D0
  0E8E    158A    SETB	0xA,3
363:              					soft_delay_ms(100);
  0E8F    3064    LDIA	0x64
  0E90    00F3    LD	0x73,A
  0E91    01F4    CLR	0x74
  0E92    26DD    CALL	0x6DD
  0E93    158A    SETB	0xA,3
364:              					sledBlink();
  0E94    2ED0    JP	0x6D0
365:              				}
366:              			}
367:              			else if(flag_time_key2_add >= 300)
  0E95    3001    LDIA	0x1
  0E96    0235    SUBA	0x35
  0E97    302C    LDIA	0x2C
  0E98    1903    SZB	0x3,2
  0E99    0234    SUBA	0x34
  0E9A    1C03    SNZB	0x3,0
  0E9B    0008    RET
368:              			{
369:              				if(key_long_flag == 0)
  0E9C    08B7    TESTZ	0x37
  0E9D    1D03    SNZB	0x3,2
  0E9E    0008    RET
370:              				{
371:              					key_long_flag = 0x04;
  0E9F    3004    LDIA	0x4
  0EA0    00B7    LD	0x37,A
  0EA1    2E94    JP	0x694
372:              					sledBlink();
373:              				}
374:              			}
375:              		}
376:              		else if(KEY2_FLAG == 0x03)
  0EA2    0878    LD	A,0x78
  0EA3    3A03    XORIA	0x3
  0EA4    1D03    SNZB	0x3,2
  0EA5    0008    RET
  0EA6    3001    LDIA	0x1
377:              		{
378:              			KEY2_FLAG = 0;
  0EA7    01F8    CLR	0x78
379:              			if((flag_time_key2_add < 300))
  0EA8    0235    SUBA	0x35
  0EA9    302C    LDIA	0x2C
  0EAA    1903    SZB	0x3,2
  0EAB    0234    SUBA	0x34
  0EAC    1803    SZB	0x3,0
  0EAD    2EB1    JP	0x6B1
380:              			{
381:              				setChannelStatus(CHANNEL_2, CHANNEL_SW);
  0EAE    3002    LDIA	0x2
  0EAF    00D8    LD	0x58,A
  0EB0    2EF9    JP	0x6F9
382:              			}
383:              			else if(flag_time_key2_add < 500)
  0EB1    3001    LDIA	0x1
  0EB2    0235    SUBA	0x35
  0EB3    30F4    LDIA	0xF4
  0EB4    1903    SZB	0x3,2
  0EB5    0234    SUBA	0x34
384:              			{
385:              				if(key_long_flag == 0x04)
  0EB6    0837    LD	A,0x37
  0EB7    1803    SZB	0x3,0
  0EB8    2EC7    JP	0x6C7
  0EB9    3A04    XORIA	0x4
  0EBA    1D03    SNZB	0x3,2
  0EBB    0008    RET
  0EBC    3041    LDIA	0x41
386:              				{
387:              					KEY2.key_flag_3s = 1;
  0EBD    01A7    CLR	0x27
  0EBE    0AA7    INCR	0x27
388:              					key_long_flag = 0x41;
  0EBF    00B7    LD	0x37,A
389:              					sys_stute = MATCH_MSG;
  0EC0    3002    LDIA	0x2
  0EC1    00EE    LD	0x6E,A
390:              					flag_time_key1_add = 0;
  0EC2    01B2    CLR	0x32
  0EC3    01B3    CLR	0x33
391:              					flag_time_key0_add = 0;
  0EC4    01B0    CLR	0x30
  0EC5    01B1    CLR	0x31
  0EC6    0008    RET
392:              					
393:              				}
394:              			}
395:              			else
396:              			{
397:              				if(key_long_flag == 0x40)
  0EC7    3A40    XORIA	0x40
  0EC8    1D03    SNZB	0x3,2
  0EC9    0008    RET
  0ECA    3041    LDIA	0x41
398:              				{
399:              					KEY2.key_flag_5s = 1;
  0ECB    01A8    CLR	0x28
  0ECC    0AA8    INCR	0x28
400:              					key_long_flag = 0x41;
  0ECD    00B7    LD	0x37,A
401:              					sys_stute = CLEAN_MSG;
  0ECE    3003    LDIA	0x3
  0ECF    2EC1    JP	0x6C1
402:              					flag_time_key1_add = 0;
403:              					flag_time_key0_add = 0;
404:              				}
405:              			}
406:              		}
407:              
408:              }
409:              
410:              
411:              
412:              /************************************************
413:              *������ʼ��
414:              *PAN2416ͨ������PORTB��������
415:              *************************************************/
416:              void key_Init(void)
417:              {
418:              	OPTION_REG &= ~0x80;
  0919    1683    SETB	0x3,5
  091A    1381    CLRB	0x1,7
419:              	TRISB |= 0x0e;
  091B    300E    LDIA	0xE
  091C    0486    ORR	0x6
420:              	WPUB |= 0x0e;
  091D    0495    ORR	0x15
  091E    0008    RET
421:              }
---- C:\item\pan2416\gitforpan2416\PAV03new\FWSWES-PAV03-SCENESWITCHES-PAN2416AV\src\delay.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "delay.h"
3:                
4:                void soft_delay_ms(unsigned int ms);
5:                
6:                
7:                
8:                
9:                void soft_delay_ms(unsigned int ms)
10:               {
11:               //	8MƵ
12:               	volatile unsigned int i;
13:               	volatile unsigned char j,k;
14:               	for(i=0;i<ms;i++){
  0EDD    01CF    CLR	0x4F
  0EDE    01D0    CLR	0x50
  0EDF    0874    LD	A,0x74
  0EE0    0250    SUBA	0x50
  0EE1    1D03    SNZB	0x3,2
  0EE2    2EE5    JP	0x6E5
  0EE3    0873    LD	A,0x73
  0EE4    024F    SUBA	0x4F
  0EE5    1803    SZB	0x3,0
  0EE6    0008    RET
15:               		for(j=0;j<10;j++){
  0EE7    01D1    CLR	0x51
  0EE8    300A    LDIA	0xA
  0EE9    0251    SUBA	0x51
  0EEA    1803    SZB	0x3,0
  0EEB    2EF5    JP	0x6F5
16:               			for(k=0;k<32;k++);
  0EEC    01D2    CLR	0x52
  0EED    3020    LDIA	0x20
  0EEE    0252    SUBA	0x52
  0EEF    1803    SZB	0x3,0
  0EF0    2EF3    JP	0x6F3
  0EF1    0AD2    INCR	0x52
  0EF2    2EED    JP	0x6ED
  0EF3    0AD1    INCR	0x51
  0EF4    2EE8    JP	0x6E8
  0EF5    0ACF    INCR	0x4F
  0EF6    1903    SZB	0x3,2
  0EF7    0AD0    INCR	0x50
  0EF8    2EDF    JP	0x6DF
17:               		}
18:               	}
19:               }
---- C:\item\pan2416\PAN2416\\CMS_ID~1.03_\data\sources\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
5:                {
  0947    00CF    LD	0x4F,A
  0948    01D1    CLR	0x51
  0949    0873    LD	A,0x73
  094A    1903    SZB	0x3,2
  094B    2960    JP	0x160
  094C    01D0    CLR	0x50
  094D    0AD0    INCR	0x50
  094E    1BF3    SZB	0x73,7
  094F    2953    JP	0x153
  0950    1003    CLRB	0x3,0
  0951    0DF3    RLCR	0x73
  0952    294D    JP	0x14D
  0953    1003    CLRB	0x3,0
  0954    0DD1    RLCR	0x51
  0955    0873    LD	A,0x73
  0956    024F    SUBA	0x4F
  0957    1C03    SNZB	0x3,0
  0958    295D    JP	0x15D
  0959    0873    LD	A,0x73
  095A    02CF    SUBR	0x4F
  095B    1451    SETB	0x51,0
  095C    1003    CLRB	0x3,0
  095D    0CF3    RRCR	0x73
  095E    0BD0    SZDECR	0x50
  095F    2953    JP	0x153
  0960    0851    LD	A,0x51
  0961    0008    RET
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- C:\item\pan2416\gitforpan2416\PAV03new\FWSWES-PAV03-SCENESWITCHES-PAN2416AV\src\system.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "system.h"
3:                #include "INT0.h"
4:                #include "timer0.h"
5:                #include "timer1.h"
6:                #include "timer2.h"
7:                #include "PWM.h"
8:                #include "PORTB_interrupt.h"
9:                #include "ADC.h"
10:               #include "rf297L.h"
11:               
12:               void system_set_CPU_frequency(CPU_FREQUENCY_e CPU_Frequency);
13:               void clear_interrupt_flag(void);
14:               void system_to_sleep(void);
15:               void Enable_Interrupt(void);
16:               void Disable_Interrupt(void);
17:               
18:               void system_set_CPU_frequency(CPU_FREQUENCY_e CPU_Frequency)
19:               {
  0914    00F3    LD	0x73,A
20:               	OSCCON = CPU_Frequency;
  0915    1683    SETB	0x3,5
  0916    008F    LD	0xF,A
21:               	OSCTUNE = 0X00;
  0917    0190    CLR	0x10
  0918    0008    RET
22:               }
23:               
24:               void clear_interrupt_flag(void)
25:               {
26:               	PIR1&= ~0x4f;		//bit0==TMR1IF bit1==TMR2IF bit2==CCP1IF bit3==SSPIF bit6==ADIF
27:               	PIR2&= ~0x19;		//bit0==CCP2IF bit3==BCLIF bit4==EEIF
28:               	INTCON&= ~0x07;	//bit0==RBIF bit1==INTF bit2==T0IF
29:               }
30:               
31:               void system_to_sleep(void)
32:               {
33:               	asm("sleep");
34:               	asm("nop");
35:               }
36:               
37:               void Enable_Interrupt(void)
38:               {
39:               	INTCON |= 0x80;
  0002    178B    SETB	0xB,7
  0003    0008    RET
40:               }
41:               
42:               void Disable_Interrupt(void)
43:               {
44:               	INTCON &= ~(0x80);
45:               }
46:               
47:               void interrupt ISR(void)
48:               {
49:               	unsigned char inside_intterrupt_enable,peripheral_intterrupt_enable;
50:               	unsigned char inside_intterrupt_touch,peripheral_intterrupt_touch;
51:               	
52:               	//ȡжϱ־	
53:               	inside_intterrupt_enable = INTCON & 0x38;
  0962    1683    SETB	0x3,5
  0963    1303    CLRB	0x3,6
54:               	peripheral_intterrupt_enable = PIE1 & 0x43;
55:               	inside_intterrupt_touch = INTCON & 0x07;
  0964    1283    CLRB	0x3,5
  0965    080C    LD	A,0xC
  0966    00F2    LD	0x72,A
  0967    3043    LDIA	0x43
  0968    05F2    ANDR	0x72
56:               	peripheral_intterrupt_touch = PIR1 & 0x43;
57:               	
58:               	//תжϺ	
59:               //	if(inside_intterrupt_touch & PORTB_CHANGE_ISR_TOUCH) 	{		//RBIF
60:               //			PORTB_CHANGE_ISR();
61:               //	} 
62:               		
63:               //	if(inside_intterrupt_touch & INT0_ISR_TOUCH){							//INTF
64:               //			INT0_ISR();
65:               //	}
66:               		
67:               //	if(inside_intterrupt_touch & TIMER0_ISR_TOUCH) {						//T0IF	
68:               //			TIMER0_ISR();			
69:               //	}
70:               	
71:               	if(peripheral_intterrupt_touch & TIMER1_ISR_TOUCH) {				//TMR1IF
  0969    1C72    SNZB	0x72,0
  096A    296C    JP	0x16C
72:               			TIMER1_ISR();
  096B    2173    CALL	0x173
  096C    0871    LD	A,0x71
  096D    008A    LD	0xA,A
  096E    0E70    SWAPA	0x70
  096F    0083    LD	0x3,A
  0970    0EFE    SWAPR	0x7E
  0971    0E7E    SWAPA	0x7E
  0972    0009    RETI
73:               	}
74:               		 
75:               //	if(peripheral_intterrupt_touch & TIMER2_ISR_TOUCH) {				//TMR2IF
76:               //			TIMER2_ISR();
77:               //	}
78:               	
79:               //	if(peripheral_intterrupt_touch & ADC_ISR_TOUCH) {					//ADIF	
80:               //			ADC_ISR();
81:               //	}
82:               }
83:               
84:               
85:               void System_sleep_mode(void)
86:               {
87:               	RF_Sleep();
88:               	asm("sleep");
89:               	asm("nop");
90:               }
91:               
---- C:\item\pan2416\gitforpan2416\PAV03new\FWSWES-PAV03-SCENESWITCHES-PAN2416AV\src\timer1.c ----------------------------------------------------------------------
1:                #include "cms.h"
2:                #include "virtual_timer.h"
3:                #include "timer1.h"
4:                #include "key_scan.h"
5:                #include "recive.h"
6:                
7:                
8:                //static volatile unsigned int Timer1_set_time;
9:                //extern unsigned int sleep_flag;
10:               
11:               // Timer1_set_time = 0xffff - T_nums + Timer1_ISR_execution_total_time;
12:               // Timer1_set_time = 0xffff - 10000 + 0;
13:               #define TIME1_SET_TIME  55532
14:               
15:               extern uint16_t flag_time_key0_add;
16:               extern uint16_t flag_time_key1_add;
17:               extern uint16_t flag_time_key2_add;
18:               extern uint16_t flag_5s_add;
19:               uint16_t flag_5min_add=0;
20:               
21:               void Timer1_Init(TIMER1_DIVIDER_e TIMER1_DIVIDER);
22:               void Timer1_start(unsigned int T_nums, unsigned char Timer1_ISR_execution_total_time);
23:               void Timer1_stop(void);
24:               void TIMER1_ISR(void);
25:               
26:               /**************************************************************************
27:               *ʱ��ԴΪF = Fosc
28:               *��С��ʱʱ�� T = (1/F)*TIMER1_DIVIDER
29:               **************************************************************************/
30:               void Timer1_Init(TIMER1_DIVIDER_e TIMER1_DIVIDER)
31:               {
  0926    00F3    LD	0x73,A
32:               	T1CON = 0x00;	//TMR1GE = 0,Timer1��TMR1ON����	TMR1CS = 0;ѡ���ڲ�ʱ��FOSC
  0927    0190    CLR	0x10
33:               	T1CON |= TIMER1_DIVIDER;	//��Ƶ����	Bit5 Bit4 
  0928    0490    ORR	0x10
34:               	INTCON |= (0x40);	//PEIE = 1;		����δ�����ε��ⲿ�ж�
  0929    170B    SETB	0xB,6
35:               	PIE1 |= 0x01;		//TMR1IE = 1;	��TMR1�ж�
  092A    1683    SETB	0x3,5
  092B    140C    SETB	0xC,0
  092C    0008    RET
36:               }
37:               
38:               /*************************************************************************************
39:               *ʵ��ʱ���붨ʱʱ����ƫ��,��ͨ��Timer1_ISR_execution_total_time������
40:               *Timer1_ISR_execution_total_time == ��Timer1�жϲ��������жϺ������˳��жϺ���ִ��ʱ�䣩/TIMER1_DIVIDER,
41:               *��ʱʱ�� == T_nums * T
42:               *T = (1/F)*TIMER1_DIVIDER
43:               *************************************************************************************/
44:               void Timer1_start(unsigned int T_nums, unsigned char Timer1_ISR_execution_total_time)
45:               {
46:               	//Timer1_set_time = 0xffff - T_nums + Timer1_ISR_execution_total_time;
47:               	TMR1L = (unsigned char)(TIME1_SET_TIME);
  07F7    30EC    LDIA	0xEC
  07F8    1283    CLRB	0x3,5
  07F9    008E    LD	0xE,A
48:               	TMR1H = (unsigned char)(TIME1_SET_TIME>>8);
  07FA    30D8    LDIA	0xD8
  07FB    008F    LD	0xF,A
49:               	PIR1 &= ~(0x01);	// TMR1IF = 0;	
  07FC    100C    CLRB	0xC,0
50:               	T1CON |= 0x01;		// TMR1ON = 1;	Start Timer0
  07FD    1410    SETB	0x10,0
  07FE    0008    RET
51:               }
52:               
53:               
54:               void Timer1_stop(void)
55:               {
56:               	PIE1 &= ~(0x01);		//TMR1IE = 0;	��TMR1�ж�
57:               	T1CON &= ~(0x01);	//TMR1ON = 0;	�ض�ʱ��
58:               	PIR1 &= ~(0x01);	// TMR1IF = 0;	
59:               }
60:               
61:               void TIMER1_ISR(void)
62:               {
63:               	static unsigned int flag_1s_add=0;
64:               	static unsigned int flag_1min_add=0;
65:               	T1CON &= ~(0x01);	//TMR1ON = 0;	�ض�ʱ��
  0973    1010    CLRB	0x10,0
66:               	TMR1L = (unsigned char)(TIME1_SET_TIME);
  0974    30EC    LDIA	0xEC
  0975    008E    LD	0xE,A
67:               	TMR1H = (unsigned char)(TIME1_SET_TIME>>8);
  0976    30D8    LDIA	0xD8
  0977    008F    LD	0xF,A
68:               	//Do something
69:               	flag_time_key0_add++;
  0978    0AB0    INCR	0x30
  0979    1903    SZB	0x3,2
  097A    0AB1    INCR	0x31
70:               	flag_time_key1_add++;
  097B    0AB2    INCR	0x32
  097C    1903    SZB	0x3,2
  097D    0AB3    INCR	0x33
71:               	flag_time_key2_add++;
  097E    0AB4    INCR	0x34
  097F    1903    SZB	0x3,2
  0980    0AB5    INCR	0x35
72:               	flag_5s_add++;
  0981    0AAE    INCR	0x2E
  0982    1903    SZB	0x3,2
  0983    0AAF    INCR	0x2F
73:               	flag_5min_add++;
74:               	flag_1s_add++;
  0984    0AAC    INCR	0x2C
  0985    1903    SZB	0x3,2
  0986    0AAD    INCR	0x2D
75:               	///////////////////////////////////////////////////
76:               	PIR1 &= ~(0x01);	// TMR1IF = 0;	
  0987    100C    CLRB	0xC,0
77:               	T1CON |= 0x01;		//TMR1ON = 1;		��ʱ��
  0988    1410    SETB	0x10,0
  0989    0008    RET
78:               }
---- library_code ------------------------------------------------------------------
  000D    146D    SETB	0x6D,0
  000E    0837    LD	A,0x37
  000F    3A11    XORIA	0x11
  0010    1D03    SNZB	0x3,2
  0011    2815    JP	0x15
  0012    3010    LDIA	0x10
  0013    01A1    CLR	0x21
  0014    2822    JP	0x22
  0015    0837    LD	A,0x37
  0016    3A21    XORIA	0x21
  0017    1D03    SNZB	0x3,2
  0018    281C    JP	0x1C
  0019    3020    LDIA	0x20
  001A    01A4    CLR	0x24
  001B    2822    JP	0x22
  001C    0837    LD	A,0x37
  001D    3A41    XORIA	0x41
  001E    1D03    SNZB	0x3,2
  001F    2826    JP	0x26
  0020    3040    LDIA	0x40
  0021    01A7    CLR	0x27
  0022    01AE    CLR	0x2E
  0023    01AF    CLR	0x2F
  0024    01B7    CLR	0x37
  0025    00ED    LD	0x6D,A
  0026    158A    SETB	0xA,3
  0027    225D    CALL	0x25D
  0028    118A    CLRB	0xA,3
  0029    3A00    XORIA	0x0
  002A    1903    SZB	0x3,2
  002B    2B8A    JP	0x38A
  002C    083C    LD	A,0x3C
  002D    00E3    LD	0x63,A
  002E    083D    LD	A,0x3D
  002F    00E4    LD	0x64,A
  0030    083E    LD	A,0x3E
  0031    00E5    LD	0x65,A
  0032    083F    LD	A,0x3F
  0033    00E6    LD	0x66,A
  0034    0843    LD	A,0x43
  0035    00E7    LD	0x67,A
  0036    083B    LD	A,0x3B
  0037    00E8    LD	0x68,A
  0038    0841    LD	A,0x41
  0039    3A20    XORIA	0x20
  003A    1D03    SNZB	0x3,2
  003B    2971    JP	0x171
  003C    01EB    CLR	0x6B
  003D    2840    JP	0x40
  003E    01E9    CLR	0x69
  003F    0AEB    INCR	0x6B
  0040    3003    LDIA	0x3
  0041    026B    SUBA	0x6B
  0042    1803    SZB	0x3,0
  0043    2877    JP	0x77
  0044    3006    LDIA	0x6
  0045    00F3    LD	0x73,A
  0046    086B    LD	A,0x6B
  0047    158A    SETB	0xA,3
  0048    24EA    CALL	0x4EA
  0049    118A    CLRB	0xA,3
  004A    3EDE    ADDIA	0xDE
  004B    0084    LD	0x4,A
  004C    1383    CLRB	0x3,7
  004D    0800    LD	A,0x0
  004E    0663    XORA	0x63
  004F    1D03    SNZB	0x3,2
  0050    283E    JP	0x3E
  0051    3006    LDIA	0x6
  0052    00F3    LD	0x73,A
  0053    086B    LD	A,0x6B
  0054    158A    SETB	0xA,3
  0055    24EA    CALL	0x4EA
  0056    118A    CLRB	0xA,3
  0057    3EDF    ADDIA	0xDF
  0058    0084    LD	0x4,A
  0059    0864    LD	A,0x64
  005A    0600    XORA	0x0
  005B    1D03    SNZB	0x3,2
  005C    283E    JP	0x3E
  005D    3006    LDIA	0x6
  005E    00F3    LD	0x73,A
  005F    086B    LD	A,0x6B
  0060    158A    SETB	0xA,3
  0061    24EA    CALL	0x4EA
  0062    118A    CLRB	0xA,3
  0063    3EE0    ADDIA	0xE0
  0064    0084    LD	0x4,A
  0065    0865    LD	A,0x65
  0066    0600    XORA	0x0
  0067    1D03    SNZB	0x3,2
  0068    283E    JP	0x3E
  0069    3006    LDIA	0x6
  006A    00F3    LD	0x73,A
  006B    086B    LD	A,0x6B
  006C    158A    SETB	0xA,3
  006D    24EA    CALL	0x4EA
  006E    118A    CLRB	0xA,3
  006F    3EE1    ADDIA	0xE1
  0070    0084    LD	0x4,A
  0071    0866    LD	A,0x66
  0072    0600    XORA	0x0
  0073    1D03    SNZB	0x3,2
  0074    283E    JP	0x3E
  0075    01E9    CLR	0x69
  0076    0AE9    INCR	0x69
  0077    08E9    TESTZ	0x69
  0078    1D03    SNZB	0x3,2
  0079    28DB    JP	0xDB
  007A    084B    LD	A,0x4B
  007B    00DF    LD	0x5F,A
  007C    3006    LDIA	0x6
  007D    1003    CLRB	0x3,0
  007E    0CDF    RRCR	0x5F
  007F    3EFF    ADDIA	0xFF
  0080    1D03    SNZB	0x3,2
  0081    287D    JP	0x7D
  0082    085F    LD	A,0x5F
  0083    00EA    LD	0x6A,A
  0084    3003    LDIA	0x3
  0085    05EA    ANDR	0x6A
  0086    026A    SUBA	0x6A
  0087    1803    SZB	0x3,0
  0088    01EA    CLR	0x6A
  0089    3063    LDIA	0x63
  008A    00D3    LD	0x53,A
  008B    3004    LDIA	0x4
  008C    00D4    LD	0x54,A
  008D    3006    LDIA	0x6
  008E    00F3    LD	0x73,A
  008F    086A    LD	A,0x6A
  0090    158A    SETB	0xA,3
  0091    24EA    CALL	0x4EA
  0092    118A    CLRB	0xA,3
  0093    3E36    ADDIA	0x36
  0094    158A    SETB	0xA,3
  0095    276D    CALL	0x76D
  0096    118A    CLRB	0xA,3
  0097    3068    LDIA	0x68
  0098    00D3    LD	0x53,A
  0099    3006    LDIA	0x6
  009A    01D4    CLR	0x54
  009B    0AD4    INCR	0x54
  009C    00F3    LD	0x73,A
  009D    086A    LD	A,0x6A
  009E    158A    SETB	0xA,3
  009F    24EA    CALL	0x4EA
  00A0    118A    CLRB	0xA,3
  00A1    3E3B    ADDIA	0x3B
  00A2    158A    SETB	0xA,3
  00A3    276D    CALL	0x76D
  00A4    118A    CLRB	0xA,3
  00A5    01EB    CLR	0x6B
  00A6    3004    LDIA	0x4
  00A7    026B    SUBA	0x6B
  00A8    1803    SZB	0x3,0
  00A9    28C1    JP	0xC1
  00AA    086B    LD	A,0x6B
  00AB    3E63    ADDIA	0x63
  00AC    0084    LD	0x4,A
  00AD    1383    CLRB	0x3,7
  00AE    0800    LD	A,0x0
  00AF    00DF    LD	0x5F,A
  00B0    3006    LDIA	0x6
  00B1    00F3    LD	0x73,A
  00B2    086A    LD	A,0x6A
  00B3    158A    SETB	0xA,3
  00B4    24EA    CALL	0x4EA
  00B5    118A    CLRB	0xA,3
  00B6    00E0    LD	0x60,A
  00B7    3EDE    ADDIA	0xDE
  00B8    00E1    LD	0x61,A
  00B9    086B    LD	A,0x6B
  00BA    0761    ADDA	0x61
  00BB    00E2    LD	0x62,A
  00BC    0084    LD	0x4,A
  00BD    085F    LD	A,0x5F
  00BE    0080    LD	0x0,A
  00BF    0AEB    INCR	0x6B
  00C0    28A6    JP	0xA6
  00C1    3006    LDIA	0x6
  00C2    00F3    LD	0x73,A
  00C3    086A    LD	A,0x6A
  00C4    158A    SETB	0xA,3
  00C5    24EA    CALL	0x4EA
  00C6    118A    CLRB	0xA,3
  00C7    3EE3    ADDIA	0xE3
  00C8    0084    LD	0x4,A
  00C9    0868    LD	A,0x68
  00CA    1383    CLRB	0x3,7
  00CB    0080    LD	0x0,A
  00CC    3003    LDIA	0x3
  00CD    0AEA    INCR	0x6A
  00CE    026A    SUBA	0x6A
  00CF    1803    SZB	0x3,0
  00D0    01EA    CLR	0x6A
  00D1    303F    LDIA	0x3F
  00D2    05CB    ANDR	0x4B
  00D3    086A    LD	A,0x6A
  00D4    00DF    LD	0x5F,A
  00D5    0CDF    RRCR	0x5F
  00D6    0CDF    RRCR	0x5F
  00D7    0C5F    RRCA	0x5F
  00D8    39C0    ANDIA	0xC0
  00D9    04CB    ORR	0x4B
  00DA    28F6    JP	0xF6
  00DB    086B    LD	A,0x6B
  00DC    00EA    LD	0x6A,A
  00DD    3068    LDIA	0x68
  00DE    00D3    LD	0x53,A
  00DF    3006    LDIA	0x6
  00E0    01D4    CLR	0x54
  00E1    0AD4    INCR	0x54
  00E2    00F3    LD	0x73,A
  00E3    086A    LD	A,0x6A
  00E4    158A    SETB	0xA,3
  00E5    24EA    CALL	0x4EA
  00E6    118A    CLRB	0xA,3
  00E7    3E3B    ADDIA	0x3B
  00E8    158A    SETB	0xA,3
  00E9    276D    CALL	0x76D
  00EA    118A    CLRB	0xA,3
  00EB    3006    LDIA	0x6
  00EC    00F3    LD	0x73,A
  00ED    086A    LD	A,0x6A
  00EE    158A    SETB	0xA,3
  00EF    24EA    CALL	0x4EA
  00F0    118A    CLRB	0xA,3
  00F1    3EE3    ADDIA	0xE3
  00F2    0084    LD	0x4,A
  00F3    0868    LD	A,0x68
  00F4    1383    CLRB	0x3,7
  00F5    0080    LD	0x0,A
  00F6    3009    LDIA	0x9
  00F7    00EB    LD	0x6B,A
  00F8    300C    LDIA	0xC
  00F9    026B    SUBA	0x6B
  00FA    1803    SZB	0x3,0
  00FB    291D    JP	0x11D
  00FC    3006    LDIA	0x6
  00FD    00F3    LD	0x73,A
  00FE    086B    LD	A,0x6B
  00FF    158A    SETB	0xA,3
  0100    24EA    CALL	0x4EA
  0101    118A    CLRB	0xA,3
  0102    3EAC    ADDIA	0xAC
  0103    0084    LD	0x4,A
  0104    3001    LDIA	0x1
  0105    00DF    LD	0x5F,A
  0106    0A42    INCA	0x42
  0107    290A    JP	0x10A
  0108    1003    CLRB	0x3,0
  0109    0DDF    RLCR	0x5F
  010A    3EFF    ADDIA	0xFF
  010B    1D03    SNZB	0x3,2
  010C    2908    JP	0x108
  010D    085F    LD	A,0x5F
  010E    1383    CLRB	0x3,7
  010F    0500    ANDA	0x0
  0110    1903    SZB	0x3,2
  0111    2915    JP	0x115
  0112    01D8    CLR	0x58
  0113    0AD8    INCR	0x58
  0114    2916    JP	0x116
  0115    01D8    CLR	0x58
  0116    086B    LD	A,0x6B
  0117    3EF7    ADDIA	0xF7
  0118    158A    SETB	0xA,3
  0119    26F9    CALL	0x6F9
  011A    118A    CLRB	0xA,3
  011B    0AEB    INCR	0x6B
  011C    28F8    JP	0xF8
  011D    304B    LDIA	0x4B
  011E    01B7    CLR	0x37
  011F    00D3    LD	0x53,A
  0120    306E    LDIA	0x6E
  0121    01D4    CLR	0x54
  0122    0AD4    INCR	0x54
  0123    158A    SETB	0xA,3
  0124    276D    CALL	0x76D
  0125    118A    CLRB	0xA,3
  0126    304B    LDIA	0x4B
  0127    00D3    LD	0x53,A
  0128    306E    LDIA	0x6E
  0129    01D4    CLR	0x54
  012A    0AD4    INCR	0x54
  012B    158A    SETB	0xA,3
  012C    276D    CALL	0x76D
  012D    118A    CLRB	0xA,3
  012E    01EB    CLR	0x6B
  012F    300C    LDIA	0xC
  0130    026B    SUBA	0x6B
  0131    1803    SZB	0x3,0
  0132    2947    JP	0x147
  0133    3006    LDIA	0x6
  0134    00F3    LD	0x73,A
  0135    086B    LD	A,0x6B
  0136    158A    SETB	0xA,3
  0137    24EA    CALL	0x4EA
  0138    118A    CLRB	0xA,3
  0139    3EA8    ADDIA	0xA8
  013A    00D5    LD	0x55,A
  013B    3006    LDIA	0x6
  013C    00D6    LD	0x56,A
  013D    00F3    LD	0x73,A
  013E    086B    LD	A,0x6B
  013F    158A    SETB	0xA,3
  0140    24EA    CALL	0x4EA
  0141    118A    CLRB	0xA,3
  0142    158A    SETB	0xA,3
  0143    24D2    CALL	0x4D2
  0144    118A    CLRB	0xA,3
  0145    0AEB    INCR	0x6B
  0146    292F    JP	0x12F
  0147    304B    LDIA	0x4B
  0148    00D5    LD	0x55,A
  0149    306E    LDIA	0x6E
  014A    01D6    CLR	0x56
  014B    0AD6    INCR	0x56
  014C    158A    SETB	0xA,3
  014D    24D2    CALL	0x4D2
  014E    118A    CLRB	0xA,3
  014F    086C    LD	A,0x6C
  0150    1903    SZB	0x3,2
  0151    296B    JP	0x16B
  0152    305E    LDIA	0x5E
  0153    00CF    LD	0x4F,A
  0154    3071    LDIA	0x71
  0155    158A    SETB	0xA,3
  0156    2786    CALL	0x786
  0157    118A    CLRB	0xA,3
  0158    3005    LDIA	0x5
  0159    00F3    LD	0x73,A
  015A    01F4    CLR	0x74
  015B    158A    SETB	0xA,3
  015C    26DD    CALL	0x6DD
  015D    118A    CLRB	0xA,3
  015E    30F6    LDIA	0xF6
  015F    00CF    LD	0x4F,A
  0160    3072    LDIA	0x72
  0161    158A    SETB	0xA,3
  0162    2786    CALL	0x786
  0163    118A    CLRB	0xA,3
  0164    3005    LDIA	0x5
  0165    00F3    LD	0x73,A
  0166    01F4    CLR	0x74
  0167    158A    SETB	0xA,3
  0168    26DD    CALL	0x6DD
  0169    118A    CLRB	0xA,3
  016A    01EC    CLR	0x6C
  016B    01EE    CLR	0x6E
  016C    0AEE    INCR	0x6E
  016D    158A    SETB	0xA,3
  016E    26D0    CALL	0x6D0
  016F    01ED    CLR	0x6D
  0170    0008    RET
  0171    0841    LD	A,0x41
  0172    3A10    XORIA	0x10
  0173    1903    SZB	0x3,2
  0174    2979    JP	0x179
  0175    0841    LD	A,0x41
  0176    3A11    XORIA	0x11
  0177    1D03    SNZB	0x3,2
  0178    0008    RET
  0179    0867    LD	A,0x67
  017A    3AFF    XORIA	0xFF
  017B    1903    SZB	0x3,2
  017C    0008    RET
  017D    1E6D    SNZB	0x6D,4
  017E    2A16    JP	0x216
  017F    01EB    CLR	0x6B
  0180    2983    JP	0x183
  0181    01E9    CLR	0x69
  0182    0AEB    INCR	0x6B
  0183    3003    LDIA	0x3
  0184    026B    SUBA	0x6B
  0185    1803    SZB	0x3,0
  0186    29C6    JP	0x1C6
  0187    3006    LDIA	0x6
  0188    00F3    LD	0x73,A
  0189    086B    LD	A,0x6B
  018A    158A    SETB	0xA,3
  018B    24EA    CALL	0x4EA
  018C    118A    CLRB	0xA,3
  018D    3EA8    ADDIA	0xA8
  018E    0084    LD	0x4,A
  018F    1383    CLRB	0x3,7
  0190    0800    LD	A,0x0
  0191    0663    XORA	0x63
  0192    1D03    SNZB	0x3,2
  0193    2981    JP	0x181
  0194    3006    LDIA	0x6
  0195    00F3    LD	0x73,A
  0196    086B    LD	A,0x6B
  0197    158A    SETB	0xA,3
  0198    24EA    CALL	0x4EA
  0199    118A    CLRB	0xA,3
  019A    3EA9    ADDIA	0xA9
  019B    0084    LD	0x4,A
  019C    0864    LD	A,0x64
  019D    0600    XORA	0x0
  019E    1D03    SNZB	0x3,2
  019F    2981    JP	0x181
  01A0    3006    LDIA	0x6
  01A1    00F3    LD	0x73,A
  01A2    086B    LD	A,0x6B
  01A3    158A    SETB	0xA,3
  01A4    24EA    CALL	0x4EA
  01A5    118A    CLRB	0xA,3
  01A6    3EAA    ADDIA	0xAA
  01A7    0084    LD	0x4,A
  01A8    0865    LD	A,0x65
  01A9    0600    XORA	0x0
  01AA    1D03    SNZB	0x3,2
  01AB    2981    JP	0x181
  01AC    3006    LDIA	0x6
  01AD    00F3    LD	0x73,A
  01AE    086B    LD	A,0x6B
  01AF    158A    SETB	0xA,3
  01B0    24EA    CALL	0x4EA
  01B1    118A    CLRB	0xA,3
  01B2    3EAB    ADDIA	0xAB
  01B3    0084    LD	0x4,A
  01B4    0866    LD	A,0x66
  01B5    0600    XORA	0x0
  01B6    1D03    SNZB	0x3,2
  01B7    2981    JP	0x181
  01B8    3006    LDIA	0x6
  01B9    00F3    LD	0x73,A
  01BA    086B    LD	A,0x6B
  01BB    158A    SETB	0xA,3
  01BC    24EA    CALL	0x4EA
  01BD    118A    CLRB	0xA,3
  01BE    3EAC    ADDIA	0xAC
  01BF    0084    LD	0x4,A
  01C0    0867    LD	A,0x67
  01C1    0600    XORA	0x0
  01C2    1D03    SNZB	0x3,2
  01C3    2981    JP	0x181
  01C4    01E9    CLR	0x69
  01C5    0AE9    INCR	0x69
  01C6    08E9    TESTZ	0x69
  01C7    1D03    SNZB	0x3,2
  01C8    2A02    JP	0x202
  01C9    084B    LD	A,0x4B
  01CA    00EA    LD	0x6A,A
  01CB    3003    LDIA	0x3
  01CC    05EA    ANDR	0x6A
  01CD    026A    SUBA	0x6A
  01CE    1803    SZB	0x3,0
  01CF    01EA    CLR	0x6A
  01D0    3063    LDIA	0x63
  01D1    00D3    LD	0x53,A
  01D2    3006    LDIA	0x6
  01D3    00D4    LD	0x54,A
  01D4    00F3    LD	0x73,A
  01D5    086A    LD	A,0x6A
  01D6    158A    SETB	0xA,3
  01D7    24EA    CALL	0x4EA
  01D8    118A    CLRB	0xA,3
  01D9    158A    SETB	0xA,3
  01DA    276D    CALL	0x76D
  01DB    118A    CLRB	0xA,3
  01DC    01EB    CLR	0x6B
  01DD    3006    LDIA	0x6
  01DE    026B    SUBA	0x6B
  01DF    1803    SZB	0x3,0
  01E0    29F8    JP	0x1F8
  01E1    086B    LD	A,0x6B
  01E2    3E63    ADDIA	0x63
  01E3    0084    LD	0x4,A
  01E4    1383    CLRB	0x3,7
  01E5    0800    LD	A,0x0
  01E6    00DF    LD	0x5F,A
  01E7    3006    LDIA	0x6
  01E8    00F3    LD	0x73,A
  01E9    086A    LD	A,0x6A
  01EA    158A    SETB	0xA,3
  01EB    24EA    CALL	0x4EA
  01EC    118A    CLRB	0xA,3
  01ED    00E0    LD	0x60,A
  01EE    3EA8    ADDIA	0xA8
  01EF    00E1    LD	0x61,A
  01F0    086B    LD	A,0x6B
  01F1    0761    ADDA	0x61
  01F2    00E2    LD	0x62,A
  01F3    0084    LD	0x4,A
  01F4    085F    LD	A,0x5F
  01F5    0080    LD	0x0,A
  01F6    0AEB    INCR	0x6B
  01F7    29DD    JP	0x1DD
  01F8    3003    LDIA	0x3
  01F9    0AEA    INCR	0x6A
  01FA    026A    SUBA	0x6A
  01FB    1803    SZB	0x3,0
  01FC    01EA    CLR	0x6A
  01FD    30FC    LDIA	0xFC
  01FE    05CB    ANDR	0x4B
  01FF    086A    LD	A,0x6A
  0200    04CB    ORR	0x4B
  0201    2A12    JP	0x212
  0202    086B    LD	A,0x6B
  0203    00EA    LD	0x6A,A
  0204    3068    LDIA	0x68
  0205    00D3    LD	0x53,A
  0206    3006    LDIA	0x6
  0207    01D4    CLR	0x54
  0208    0AD4    INCR	0x54
  0209    00F3    LD	0x73,A
  020A    086A    LD	A,0x6A
  020B    158A    SETB	0xA,3
  020C    24EA    CALL	0x4EA
  020D    118A    CLRB	0xA,3
  020E    3E05    ADDIA	0x5
  020F    158A    SETB	0xA,3
  0210    276D    CALL	0x76D
  0211    118A    CLRB	0xA,3
  0212    0842    LD	A,0x42
  0213    00D8    LD	0x58,A
  0214    3000    LDIA	0x0
  0215    2B5C    JP	0x35C
  0216    1EED    SNZB	0x6D,5
  0217    2AC1    JP	0x2C1
  0218    01EB    CLR	0x6B
  0219    2A1C    JP	0x21C
  021A    01E9    CLR	0x69
  021B    0AEB    INCR	0x6B
  021C    3003    LDIA	0x3
  021D    026B    SUBA	0x6B
  021E    1803    SZB	0x3,0
  021F    2A5F    JP	0x25F
  0220    3006    LDIA	0x6
  0221    00F3    LD	0x73,A
  0222    086B    LD	A,0x6B
  0223    158A    SETB	0xA,3
  0224    24EA    CALL	0x4EA
  0225    118A    CLRB	0xA,3
  0226    3EBA    ADDIA	0xBA
  0227    0084    LD	0x4,A
  0228    1383    CLRB	0x3,7
  0229    0800    LD	A,0x0
  022A    0663    XORA	0x63
  022B    1D03    SNZB	0x3,2
  022C    2A1A    JP	0x21A
  022D    3006    LDIA	0x6
  022E    00F3    LD	0x73,A
  022F    086B    LD	A,0x6B
  0230    158A    SETB	0xA,3
  0231    24EA    CALL	0x4EA
  0232    118A    CLRB	0xA,3
  0233    3EBB    ADDIA	0xBB
  0234    0084    LD	0x4,A
  0235    0864    LD	A,0x64
  0236    0600    XORA	0x0
  0237    1D03    SNZB	0x3,2
  0238    2A1A    JP	0x21A
  0239    3006    LDIA	0x6
  023A    00F3    LD	0x73,A
  023B    086B    LD	A,0x6B
  023C    158A    SETB	0xA,3
  023D    24EA    CALL	0x4EA
  023E    118A    CLRB	0xA,3
  023F    3EBC    ADDIA	0xBC
  0240    0084    LD	0x4,A
  0241    0865    LD	A,0x65
  0242    0600    XORA	0x0
  0243    1D03    SNZB	0x3,2
  0244    2A1A    JP	0x21A
  0245    3006    LDIA	0x6
  0246    00F3    LD	0x73,A
  0247    086B    LD	A,0x6B
  0248    158A    SETB	0xA,3
  0249    24EA    CALL	0x4EA
  024A    118A    CLRB	0xA,3
  024B    3EBD    ADDIA	0xBD
  024C    0084    LD	0x4,A
  024D    0866    LD	A,0x66
  024E    0600    XORA	0x0
  024F    1D03    SNZB	0x3,2
  0250    2A1A    JP	0x21A
  0251    3006    LDIA	0x6
  0252    00F3    LD	0x73,A
  0253    086B    LD	A,0x6B
  0254    158A    SETB	0xA,3
  0255    24EA    CALL	0x4EA
  0256    118A    CLRB	0xA,3
  0257    3EBE    ADDIA	0xBE
  0258    0084    LD	0x4,A
  0259    0867    LD	A,0x67
  025A    0600    XORA	0x0
  025B    1D03    SNZB	0x3,2
  025C    2A1A    JP	0x21A
  025D    01E9    CLR	0x69
  025E    0AE9    INCR	0x69
  025F    08E9    TESTZ	0x69
  0260    1D03    SNZB	0x3,2
  0261    2AA7    JP	0x2A7
  0262    084B    LD	A,0x4B
  0263    00DF    LD	0x5F,A
  0264    1003    CLRB	0x3,0
  0265    0CDF    RRCR	0x5F
  0266    1003    CLRB	0x3,0
  0267    0CDF    RRCR	0x5F
  0268    085F    LD	A,0x5F
  0269    00EA    LD	0x6A,A
  026A    3003    LDIA	0x3
  026B    05EA    ANDR	0x6A
  026C    026A    SUBA	0x6A
  026D    1803    SZB	0x3,0
  026E    01EA    CLR	0x6A
  026F    3063    LDIA	0x63
  0270    00D3    LD	0x53,A
  0271    3006    LDIA	0x6
  0272    00D4    LD	0x54,A
  0273    00F3    LD	0x73,A
  0274    086A    LD	A,0x6A
  0275    158A    SETB	0xA,3
  0276    24EA    CALL	0x4EA
  0277    118A    CLRB	0xA,3
  0278    3E12    ADDIA	0x12
  0279    158A    SETB	0xA,3
  027A    276D    CALL	0x76D
  027B    118A    CLRB	0xA,3
  027C    01EB    CLR	0x6B
  027D    3006    LDIA	0x6
  027E    026B    SUBA	0x6B
  027F    1803    SZB	0x3,0
  0280    2A98    JP	0x298
  0281    086B    LD	A,0x6B
  0282    3E63    ADDIA	0x63
  0283    0084    LD	0x4,A
  0284    1383    CLRB	0x3,7
  0285    0800    LD	A,0x0
  0286    00DF    LD	0x5F,A
  0287    3006    LDIA	0x6
  0288    00F3    LD	0x73,A
  0289    086A    LD	A,0x6A
  028A    158A    SETB	0xA,3
  028B    24EA    CALL	0x4EA
  028C    118A    CLRB	0xA,3
  028D    00E0    LD	0x60,A
  028E    3EBA    ADDIA	0xBA
  028F    00E1    LD	0x61,A
  0290    086B    LD	A,0x6B
  0291    0761    ADDA	0x61
  0292    00E2    LD	0x62,A
  0293    0084    LD	0x4,A
  0294    085F    LD	A,0x5F
  0295    0080    LD	0x0,A
  0296    0AEB    INCR	0x6B
  0297    2A7D    JP	0x27D
  0298    3003    LDIA	0x3
  0299    0AEA    INCR	0x6A
  029A    026A    SUBA	0x6A
  029B    1803    SZB	0x3,0
  029C    01EA    CLR	0x6A
  029D    30F3    LDIA	0xF3
  029E    05CB    ANDR	0x4B
  029F    086A    LD	A,0x6A
  02A0    00DF    LD	0x5F,A
  02A1    1003    CLRB	0x3,0
  02A2    0DDF    RLCR	0x5F
  02A3    1003    CLRB	0x3,0
  02A4    0D5F    RLCA	0x5F
  02A5    04CB    ORR	0x4B
  02A6    2ABD    JP	0x2BD
  02A7    086B    LD	A,0x6B
  02A8    00EA    LD	0x6A,A
  02A9    3068    LDIA	0x68
  02AA    00D3    LD	0x53,A
  02AB    3006    LDIA	0x6
  02AC    01D4    CLR	0x54
  02AD    0AD4    INCR	0x54
  02AE    00F3    LD	0x73,A
  02AF    086A    LD	A,0x6A
  02B0    158A    SETB	0xA,3
  02B1    24EA    CALL	0x4EA
  02B2    118A    CLRB	0xA,3
  02B3    3E17    ADDIA	0x17
  02B4    158A    SETB	0xA,3
  02B5    276D    CALL	0x76D
  02B6    118A    CLRB	0xA,3
  02B7    3002    LDIA	0x2
  02B8    00F3    LD	0x73,A
  02B9    01F4    CLR	0x74
  02BA    158A    SETB	0xA,3
  02BB    26DD    CALL	0x6DD
  02BC    118A    CLRB	0xA,3
  02BD    0842    LD	A,0x42
  02BE    00D8    LD	0x58,A
  02BF    3001    LDIA	0x1
  02C0    2B5C    JP	0x35C
  02C1    1F6D    SNZB	0x6D,6
  02C2    2B60    JP	0x360
  02C3    01EB    CLR	0x6B
  02C4    2AC7    JP	0x2C7
  02C5    01E9    CLR	0x69
  02C6    0AEB    INCR	0x6B
  02C7    3003    LDIA	0x3
  02C8    026B    SUBA	0x6B
  02C9    1803    SZB	0x3,0
  02CA    2B0A    JP	0x30A
  02CB    3006    LDIA	0x6
  02CC    00F3    LD	0x73,A
  02CD    086B    LD	A,0x6B
  02CE    158A    SETB	0xA,3
  02CF    24EA    CALL	0x4EA
  02D0    118A    CLRB	0xA,3
  02D1    3ECC    ADDIA	0xCC
  02D2    0084    LD	0x4,A
  02D3    1383    CLRB	0x3,7
  02D4    0800    LD	A,0x0
  02D5    0663    XORA	0x63
  02D6    1D03    SNZB	0x3,2
  02D7    2AC5    JP	0x2C5
  02D8    3006    LDIA	0x6
  02D9    00F3    LD	0x73,A
  02DA    086B    LD	A,0x6B
  02DB    158A    SETB	0xA,3
  02DC    24EA    CALL	0x4EA
  02DD    118A    CLRB	0xA,3
  02DE    3ECD    ADDIA	0xCD
  02DF    0084    LD	0x4,A
  02E0    0864    LD	A,0x64
  02E1    0600    XORA	0x0
  02E2    1D03    SNZB	0x3,2
  02E3    2AC5    JP	0x2C5
  02E4    3006    LDIA	0x6
  02E5    00F3    LD	0x73,A
  02E6    086B    LD	A,0x6B
  02E7    158A    SETB	0xA,3
  02E8    24EA    CALL	0x4EA
  02E9    118A    CLRB	0xA,3
  02EA    3ECE    ADDIA	0xCE
  02EB    0084    LD	0x4,A
  02EC    0865    LD	A,0x65
  02ED    0600    XORA	0x0
  02EE    1D03    SNZB	0x3,2
  02EF    2AC5    JP	0x2C5
  02F0    3006    LDIA	0x6
  02F1    00F3    LD	0x73,A
  02F2    086B    LD	A,0x6B
  02F3    158A    SETB	0xA,3
  02F4    24EA    CALL	0x4EA
  02F5    118A    CLRB	0xA,3
  02F6    3ECF    ADDIA	0xCF
  02F7    0084    LD	0x4,A
  02F8    0866    LD	A,0x66
  02F9    0600    XORA	0x0
  02FA    1D03    SNZB	0x3,2
  02FB    2AC5    JP	0x2C5
  02FC    3006    LDIA	0x6
  02FD    00F3    LD	0x73,A
  02FE    086B    LD	A,0x6B
  02FF    158A    SETB	0xA,3
  0300    24EA    CALL	0x4EA
  0301    118A    CLRB	0xA,3
  0302    3ED0    ADDIA	0xD0
  0303    0084    LD	0x4,A
  0304    0867    LD	A,0x67
  0305    0600    XORA	0x0
  0306    1D03    SNZB	0x3,2
  0307    2AC5    JP	0x2C5
  0308    01E9    CLR	0x69
  0309    0AE9    INCR	0x69
  030A    08E9    TESTZ	0x69
  030B    1D03    SNZB	0x3,2
  030C    2B49    JP	0x349
  030D    0E4B    SWAPA	0x4B
  030E    390F    ANDIA	0xF
  030F    00EA    LD	0x6A,A
  0310    3003    LDIA	0x3
  0311    05EA    ANDR	0x6A
  0312    026A    SUBA	0x6A
  0313    1803    SZB	0x3,0
  0314    01EA    CLR	0x6A
  0315    3063    LDIA	0x63
  0316    00D3    LD	0x53,A
  0317    3006    LDIA	0x6
  0318    00D4    LD	0x54,A
  0319    00F3    LD	0x73,A
  031A    086A    LD	A,0x6A
  031B    158A    SETB	0xA,3
  031C    24EA    CALL	0x4EA
  031D    118A    CLRB	0xA,3
  031E    3E24    ADDIA	0x24
  031F    158A    SETB	0xA,3
  0320    276D    CALL	0x76D
  0321    118A    CLRB	0xA,3
  0322    01EB    CLR	0x6B
  0323    3006    LDIA	0x6
  0324    026B    SUBA	0x6B
  0325    1803    SZB	0x3,0
  0326    2B3E    JP	0x33E
  0327    086B    LD	A,0x6B
  0328    3E63    ADDIA	0x63
  0329    0084    LD	0x4,A
  032A    1383    CLRB	0x3,7
  032B    0800    LD	A,0x0
  032C    00DF    LD	0x5F,A
  032D    3006    LDIA	0x6
  032E    00F3    LD	0x73,A
  032F    086A    LD	A,0x6A
  0330    158A    SETB	0xA,3
  0331    24EA    CALL	0x4EA
  0332    118A    CLRB	0xA,3
  0333    00E0    LD	0x60,A
  0334    3ECC    ADDIA	0xCC
  0335    00E1    LD	0x61,A
  0336    086B    LD	A,0x6B
  0337    0761    ADDA	0x61
  0338    00E2    LD	0x62,A
  0339    0084    LD	0x4,A
  033A    085F    LD	A,0x5F
  033B    0080    LD	0x0,A
  033C    0AEB    INCR	0x6B
  033D    2B23    JP	0x323
  033E    3003    LDIA	0x3
  033F    0AEA    INCR	0x6A
  0340    026A    SUBA	0x6A
  0341    1803    SZB	0x3,0
  0342    01EA    CLR	0x6A
  0343    30CF    LDIA	0xCF
  0344    05CB    ANDR	0x4B
  0345    0E6A    SWAPA	0x6A
  0346    39F0    ANDIA	0xF0
  0347    04CB    ORR	0x4B
  0348    2B59    JP	0x359
  0349    086B    LD	A,0x6B
  034A    00EA    LD	0x6A,A
  034B    3068    LDIA	0x68
  034C    00D3    LD	0x53,A
  034D    3006    LDIA	0x6
  034E    01D4    CLR	0x54
  034F    0AD4    INCR	0x54
  0350    00F3    LD	0x73,A
  0351    086A    LD	A,0x6A
  0352    158A    SETB	0xA,3
  0353    24EA    CALL	0x4EA
  0354    118A    CLRB	0xA,3
  0355    3E29    ADDIA	0x29
  0356    158A    SETB	0xA,3
  0357    276D    CALL	0x76D
  0358    118A    CLRB	0xA,3
  0359    0842    LD	A,0x42
  035A    00D8    LD	0x58,A
  035B    3002    LDIA	0x2
  035C    158A    SETB	0xA,3
  035D    26F9    CALL	0x6F9
  035E    118A    CLRB	0xA,3
  035F    01B7    CLR	0x37
  0360    304B    LDIA	0x4B
  0361    00D3    LD	0x53,A
  0362    306E    LDIA	0x6E
  0363    01D4    CLR	0x54
  0364    0AD4    INCR	0x54
  0365    158A    SETB	0xA,3
  0366    276D    CALL	0x76D
  0367    118A    CLRB	0xA,3
  0368    304B    LDIA	0x4B
  0369    00D3    LD	0x53,A
  036A    306E    LDIA	0x6E
  036B    01D4    CLR	0x54
  036C    0AD4    INCR	0x54
  036D    158A    SETB	0xA,3
  036E    276D    CALL	0x76D
  036F    118A    CLRB	0xA,3
  0370    300C    LDIA	0xC
  0371    01EB    CLR	0x6B
  0372    026B    SUBA	0x6B
  0373    1803    SZB	0x3,0
  0374    2947    JP	0x147
  0375    3006    LDIA	0x6
  0376    00F3    LD	0x73,A
  0377    086B    LD	A,0x6B
  0378    158A    SETB	0xA,3
  0379    24EA    CALL	0x4EA
  037A    118A    CLRB	0xA,3
  037B    3EA8    ADDIA	0xA8
  037C    00D5    LD	0x55,A
  037D    3006    LDIA	0x6
  037E    00D6    LD	0x56,A
  037F    00F3    LD	0x73,A
  0380    086B    LD	A,0x6B
  0381    158A    SETB	0xA,3
  0382    24EA    CALL	0x4EA
  0383    118A    CLRB	0xA,3
  0384    158A    SETB	0xA,3
  0385    24D2    CALL	0x4D2
  0386    118A    CLRB	0xA,3
  0387    300C    LDIA	0xC
  0388    0AEB    INCR	0x6B
  0389    2B72    JP	0x372
  038A    3001    LDIA	0x1
  038B    022F    SUBA	0x2F
  038C    30F5    LDIA	0xF5
  038D    1903    SZB	0x3,2
  038E    022E    SUBA	0x2E
  038F    1C03    SNZB	0x3,0
  0390    0008    RET
  0391    01EE    CLR	0x6E
  0392    0AEE    INCR	0x6E
  0393    01ED    CLR	0x6D
  0394    0008    RET
  0395    158A    SETB	0xA,3
  0396    225D    CALL	0x25D
  0397    118A    CLRB	0xA,3
  0398    3A00    XORIA	0x0
  0399    1903    SZB	0x3,2
  039A    0008    RET
  039B    0841    LD	A,0x41
  039C    3A20    XORIA	0x20
  039D    1D03    SNZB	0x3,2
  039E    2C20    JP	0x420
  039F    0843    LD	A,0x43
  03A0    3AFF    XORIA	0xFF
  03A1    1903    SZB	0x3,2
  03A2    2F96    JP	0x796
  03A3    3009    LDIA	0x9
  03A4    00EB    LD	0x6B,A
  03A5    300C    LDIA	0xC
  03A6    026B    SUBA	0x6B
  03A7    1803    SZB	0x3,0
  03A8    2F96    JP	0x796
  03A9    3006    LDIA	0x6
  03AA    00F3    LD	0x73,A
  03AB    086B    LD	A,0x6B
  03AC    158A    SETB	0xA,3
  03AD    24EA    CALL	0x4EA
  03AE    118A    CLRB	0xA,3
  03AF    3EA8    ADDIA	0xA8
  03B0    0084    LD	0x4,A
  03B1    083C    LD	A,0x3C
  03B2    1383    CLRB	0x3,7
  03B3    0600    XORA	0x0
  03B4    1D03    SNZB	0x3,2
  03B5    2C1E    JP	0x41E
  03B6    3006    LDIA	0x6
  03B7    00F3    LD	0x73,A
  03B8    086B    LD	A,0x6B
  03B9    158A    SETB	0xA,3
  03BA    24EA    CALL	0x4EA
  03BB    118A    CLRB	0xA,3
  03BC    3EA9    ADDIA	0xA9
  03BD    0084    LD	0x4,A
  03BE    083D    LD	A,0x3D
  03BF    0600    XORA	0x0
  03C0    1D03    SNZB	0x3,2
  03C1    2C1E    JP	0x41E
  03C2    3006    LDIA	0x6
  03C3    00F3    LD	0x73,A
  03C4    086B    LD	A,0x6B
  03C5    158A    SETB	0xA,3
  03C6    24EA    CALL	0x4EA
  03C7    118A    CLRB	0xA,3
  03C8    3EAA    ADDIA	0xAA
  03C9    0084    LD	0x4,A
  03CA    083E    LD	A,0x3E
  03CB    0600    XORA	0x0
  03CC    1D03    SNZB	0x3,2
  03CD    2C1E    JP	0x41E
  03CE    3006    LDIA	0x6
  03CF    00F3    LD	0x73,A
  03D0    086B    LD	A,0x6B
  03D1    158A    SETB	0xA,3
  03D2    24EA    CALL	0x4EA
  03D3    118A    CLRB	0xA,3
  03D4    3EAB    ADDIA	0xAB
  03D5    0084    LD	0x4,A
  03D6    083F    LD	A,0x3F
  03D7    0600    XORA	0x0
  03D8    1D03    SNZB	0x3,2
  03D9    2C1E    JP	0x41E
  03DA    3006    LDIA	0x6
  03DB    00F3    LD	0x73,A
  03DC    086B    LD	A,0x6B
  03DD    158A    SETB	0xA,3
  03DE    24EA    CALL	0x4EA
  03DF    118A    CLRB	0xA,3
  03E0    3EAD    ADDIA	0xAD
  03E1    0084    LD	0x4,A
  03E2    083B    LD	A,0x3B
  03E3    0600    XORA	0x0
  03E4    1903    SZB	0x3,2
  03E5    2F96    JP	0x796
  03E6    3006    LDIA	0x6
  03E7    00F3    LD	0x73,A
  03E8    086B    LD	A,0x6B
  03E9    158A    SETB	0xA,3
  03EA    24EA    CALL	0x4EA
  03EB    118A    CLRB	0xA,3
  03EC    3EAD    ADDIA	0xAD
  03ED    0084    LD	0x4,A
  03EE    083B    LD	A,0x3B
  03EF    0080    LD	0x0,A
  03F0    3006    LDIA	0x6
  03F1    0242    SUBA	0x42
  03F2    1803    SZB	0x3,0
  03F3    2F96    JP	0x796
  03F4    158A    SETB	0xA,3
  03F5    26D0    CALL	0x6D0
  03F6    118A    CLRB	0xA,3
  03F7    3009    LDIA	0x9
  03F8    00EB    LD	0x6B,A
  03F9    300C    LDIA	0xC
  03FA    026B    SUBA	0x6B
  03FB    1803    SZB	0x3,0
  03FC    2F96    JP	0x796
  03FD    3006    LDIA	0x6
  03FE    00F3    LD	0x73,A
  03FF    086B    LD	A,0x6B
  0400    158A    SETB	0xA,3
  0401    24EA    CALL	0x4EA
  0402    118A    CLRB	0xA,3
  0403    3EAC    ADDIA	0xAC
  0404    0084    LD	0x4,A
  0405    3001    LDIA	0x1
  0406    00DF    LD	0x5F,A
  0407    0A42    INCA	0x42
  0408    2C0B    JP	0x40B
  0409    1003    CLRB	0x3,0
  040A    0DDF    RLCR	0x5F
  040B    3EFF    ADDIA	0xFF
  040C    1D03    SNZB	0x3,2
  040D    2C09    JP	0x409
  040E    085F    LD	A,0x5F
  040F    1383    CLRB	0x3,7
  0410    0500    ANDA	0x0
  0411    1903    SZB	0x3,2
  0412    2C16    JP	0x416
  0413    01D8    CLR	0x58
  0414    0AD8    INCR	0x58
  0415    2C17    JP	0x417
  0416    01D8    CLR	0x58
  0417    086B    LD	A,0x6B
  0418    3EF7    ADDIA	0xF7
  0419    158A    SETB	0xA,3
  041A    26F9    CALL	0x6F9
  041B    118A    CLRB	0xA,3
  041C    0AEB    INCR	0x6B
  041D    2BF9    JP	0x3F9
  041E    0AEB    INCR	0x6B
  041F    2BA5    JP	0x3A5
  0420    0841    LD	A,0x41
  0421    3A21    XORIA	0x21
  0422    1D03    SNZB	0x3,2
  0423    2CF8    JP	0x4F8
  0424    01E9    CLR	0x69
  0425    01EB    CLR	0x6B
  0426    2C28    JP	0x428
  0427    0AEB    INCR	0x6B
  0428    300C    LDIA	0xC
  0429    026B    SUBA	0x6B
  042A    1803    SZB	0x3,0
  042B    2C75    JP	0x475
  042C    3006    LDIA	0x6
  042D    00F3    LD	0x73,A
  042E    086B    LD	A,0x6B
  042F    158A    SETB	0xA,3
  0430    24EA    CALL	0x4EA
  0431    118A    CLRB	0xA,3
  0432    3EA8    ADDIA	0xA8
  0433    0084    LD	0x4,A
  0434    083C    LD	A,0x3C
  0435    1383    CLRB	0x3,7
  0436    0600    XORA	0x0
  0437    1D03    SNZB	0x3,2
  0438    2C27    JP	0x427
  0439    3006    LDIA	0x6
  043A    00F3    LD	0x73,A
  043B    086B    LD	A,0x6B
  043C    158A    SETB	0xA,3
  043D    24EA    CALL	0x4EA
  043E    118A    CLRB	0xA,3
  043F    3EA9    ADDIA	0xA9
  0440    0084    LD	0x4,A
  0441    083D    LD	A,0x3D
  0442    0600    XORA	0x0
  0443    1D03    SNZB	0x3,2
  0444    2C27    JP	0x427
  0445    3006    LDIA	0x6
  0446    00F3    LD	0x73,A
  0447    086B    LD	A,0x6B
  0448    158A    SETB	0xA,3
  0449    24EA    CALL	0x4EA
  044A    118A    CLRB	0xA,3
  044B    3EAA    ADDIA	0xAA
  044C    0084    LD	0x4,A
  044D    083E    LD	A,0x3E
  044E    0600    XORA	0x0
  044F    1D03    SNZB	0x3,2
  0450    2C27    JP	0x427
  0451    3006    LDIA	0x6
  0452    00F3    LD	0x73,A
  0453    086B    LD	A,0x6B
  0454    158A    SETB	0xA,3
  0455    24EA    CALL	0x4EA
  0456    118A    CLRB	0xA,3
  0457    3EAB    ADDIA	0xAB
  0458    0084    LD	0x4,A
  0459    083F    LD	A,0x3F
  045A    0600    XORA	0x0
  045B    1D03    SNZB	0x3,2
  045C    2C27    JP	0x427
  045D    3006    LDIA	0x6
  045E    00F3    LD	0x73,A
  045F    086B    LD	A,0x6B
  0460    158A    SETB	0xA,3
  0461    24EA    CALL	0x4EA
  0462    118A    CLRB	0xA,3
  0463    3EAD    ADDIA	0xAD
  0464    0084    LD	0x4,A
  0465    083B    LD	A,0x3B
  0466    0600    XORA	0x0
  0467    1903    SZB	0x3,2
  0468    2C75    JP	0x475
  0469    3006    LDIA	0x6
  046A    00F3    LD	0x73,A
  046B    086B    LD	A,0x6B
  046C    158A    SETB	0xA,3
  046D    24EA    CALL	0x4EA
  046E    118A    CLRB	0xA,3
  046F    3EAD    ADDIA	0xAD
  0470    0084    LD	0x4,A
  0471    083B    LD	A,0x3B
  0472    0080    LD	0x0,A
  0473    01E9    CLR	0x69
  0474    0AE9    INCR	0x69
  0475    0869    LD	A,0x69
  0476    1903    SZB	0x3,2
  0477    2F96    JP	0x796
  0478    3006    LDIA	0x6
  0479    0242    SUBA	0x42
  047A    1803    SZB	0x3,0
  047B    2F96    JP	0x796
  047C    3002    LDIA	0x2
  047D    0243    SUBA	0x43
  047E    1803    SZB	0x3,0
  047F    2F96    JP	0x796
  0480    3003    LDIA	0x3
  0481    0244    SUBA	0x44
  0482    1803    SZB	0x3,0
  0483    2F96    JP	0x796
  0484    3006    LDIA	0x6
  0485    08C3    TESTZ	0x43
  0486    00F3    LD	0x73,A
  0487    1D03    SNZB	0x3,2
  0488    2C9D    JP	0x49D
  0489    0844    LD	A,0x44
  048A    158A    SETB	0xA,3
  048B    24EA    CALL	0x4EA
  048C    118A    CLRB	0xA,3
  048D    3EE2    ADDIA	0xE2
  048E    0084    LD	0x4,A
  048F    3001    LDIA	0x1
  0490    00DF    LD	0x5F,A
  0491    0A42    INCA	0x42
  0492    2C95    JP	0x495
  0493    1003    CLRB	0x3,0
  0494    0DDF    RLCR	0x5F
  0495    3EFF    ADDIA	0xFF
  0496    1D03    SNZB	0x3,2
  0497    2C93    JP	0x493
  0498    085F    LD	A,0x5F
  0499    3AFF    XORIA	0xFF
  049A    1383    CLRB	0x3,7
  049B    0580    ANDR	0x0
  049C    2CAF    JP	0x4AF
  049D    0844    LD	A,0x44
  049E    158A    SETB	0xA,3
  049F    24EA    CALL	0x4EA
  04A0    118A    CLRB	0xA,3
  04A1    3EE2    ADDIA	0xE2
  04A2    0084    LD	0x4,A
  04A3    3001    LDIA	0x1
  04A4    00DF    LD	0x5F,A
  04A5    0A42    INCA	0x42
  04A6    2CA9    JP	0x4A9
  04A7    1003    CLRB	0x3,0
  04A8    0DDF    RLCR	0x5F
  04A9    3EFF    ADDIA	0xFF
  04AA    1D03    SNZB	0x3,2
  04AB    2CA7    JP	0x4A7
  04AC    085F    LD	A,0x5F
  04AD    1383    CLRB	0x3,7
  04AE    0480    ORR	0x0
  04AF    3006    LDIA	0x6
  04B0    00F3    LD	0x73,A
  04B1    0844    LD	A,0x44
  04B2    158A    SETB	0xA,3
  04B3    24EA    CALL	0x4EA
  04B4    118A    CLRB	0xA,3
  04B5    3EE2    ADDIA	0xE2
  04B6    00D3    LD	0x53,A
  04B7    3006    LDIA	0x6
  04B8    01D4    CLR	0x54
  04B9    0AD4    INCR	0x54
  04BA    00F3    LD	0x73,A
  04BB    0844    LD	A,0x44
  04BC    158A    SETB	0xA,3
  04BD    24EA    CALL	0x4EA
  04BE    118A    CLRB	0xA,3
  04BF    3E3A    ADDIA	0x3A
  04C0    158A    SETB	0xA,3
  04C1    276D    CALL	0x76D
  04C2    118A    CLRB	0xA,3
  04C3    01F3    CLR	0x73
  04C4    0AF3    INCR	0x73
  04C5    01F4    CLR	0x74
  04C6    158A    SETB	0xA,3
  04C7    26DD    CALL	0x6DD
  04C8    118A    CLRB	0xA,3
  04C9    01EB    CLR	0x6B
  04CA    300C    LDIA	0xC
  04CB    026B    SUBA	0x6B
  04CC    1803    SZB	0x3,0
  04CD    2CE2    JP	0x4E2
  04CE    3006    LDIA	0x6
  04CF    00F3    LD	0x73,A
  04D0    086B    LD	A,0x6B
  04D1    158A    SETB	0xA,3
  04D2    24EA    CALL	0x4EA
  04D3    118A    CLRB	0xA,3
  04D4    3EA8    ADDIA	0xA8
  04D5    00D5    LD	0x55,A
  04D6    3006    LDIA	0x6
  04D7    00D6    LD	0x56,A
  04D8    00F3    LD	0x73,A
  04D9    086B    LD	A,0x6B
  04DA    158A    SETB	0xA,3
  04DB    24EA    CALL	0x4EA
  04DC    118A    CLRB	0xA,3
  04DD    158A    SETB	0xA,3
  04DE    24D2    CALL	0x4D2
  04DF    118A    CLRB	0xA,3
  04E0    0AEB    INCR	0x6B
  04E1    2CCA    JP	0x4CA
  04E2    304B    LDIA	0x4B
  04E3    00D5    LD	0x55,A
  04E4    306E    LDIA	0x6E
  04E5    01D6    CLR	0x56
  04E6    0AD6    INCR	0x56
  04E7    158A    SETB	0xA,3
  04E8    24D2    CALL	0x4D2
  04E9    118A    CLRB	0xA,3
  04EA    0B43    SZDECA	0x43
  04EB    2CEF    JP	0x4EF
  04EC    01D8    CLR	0x58
  04ED    0AD8    INCR	0x58
  04EE    2CF3    JP	0x4F3
  04EF    08C3    TESTZ	0x43
  04F0    1D03    SNZB	0x3,2
  04F1    2F93    JP	0x793
  04F2    01D8    CLR	0x58
  04F3    0844    LD	A,0x44
  04F4    158A    SETB	0xA,3
  04F5    26F9    CALL	0x6F9
  04F6    118A    CLRB	0xA,3
  04F7    2F93    JP	0x793
  04F8    0841    LD	A,0x41
  04F9    3A10    XORIA	0x10
  04FA    1903    SZB	0x3,2
  04FB    2D00    JP	0x500
  04FC    0841    LD	A,0x41
  04FD    3A11    XORIA	0x11
  04FE    1D03    SNZB	0x3,2
  04FF    2E7F    JP	0x67F
  0500    0843    LD	A,0x43
  0501    3AFF    XORIA	0xFF
  0502    1903    SZB	0x3,2
  0503    2DD9    JP	0x5D9
  0504    01EB    CLR	0x6B
  0505    3009    LDIA	0x9
  0506    026B    SUBA	0x6B
  0507    1803    SZB	0x3,0
  0508    2F96    JP	0x796
  0509    0B6C    SZDECA	0x6C
  050A    2D1B    JP	0x51B
  050B    083C    LD	A,0x3C
  050C    3A11    XORIA	0x11
  050D    1D03    SNZB	0x3,2
  050E    2D1B    JP	0x51B
  050F    083D    LD	A,0x3D
  0510    3A56    XORIA	0x56
  0511    1D03    SNZB	0x3,2
  0512    2D1B    JP	0x51B
  0513    083E    LD	A,0x3E
  0514    3A32    XORIA	0x32
  0515    1D03    SNZB	0x3,2
  0516    2D1B    JP	0x51B
  0517    083F    LD	A,0x3F
  0518    3AF9    XORIA	0xF9
  0519    1903    SZB	0x3,2
  051A    2D4C    JP	0x54C
  051B    3006    LDIA	0x6
  051C    00F3    LD	0x73,A
  051D    086B    LD	A,0x6B
  051E    158A    SETB	0xA,3
  051F    24EA    CALL	0x4EA
  0520    118A    CLRB	0xA,3
  0521    3EA8    ADDIA	0xA8
  0522    0084    LD	0x4,A
  0523    083C    LD	A,0x3C
  0524    1383    CLRB	0x3,7
  0525    0600    XORA	0x0
  0526    1D03    SNZB	0x3,2
  0527    2DD7    JP	0x5D7
  0528    3006    LDIA	0x6
  0529    00F3    LD	0x73,A
  052A    086B    LD	A,0x6B
  052B    158A    SETB	0xA,3
  052C    24EA    CALL	0x4EA
  052D    118A    CLRB	0xA,3
  052E    3EA9    ADDIA	0xA9
  052F    0084    LD	0x4,A
  0530    083D    LD	A,0x3D
  0531    0600    XORA	0x0
  0532    1D03    SNZB	0x3,2
  0533    2DD7    JP	0x5D7
  0534    3006    LDIA	0x6
  0535    00F3    LD	0x73,A
  0536    086B    LD	A,0x6B
  0537    158A    SETB	0xA,3
  0538    24EA    CALL	0x4EA
  0539    118A    CLRB	0xA,3
  053A    3EAA    ADDIA	0xAA
  053B    0084    LD	0x4,A
  053C    083E    LD	A,0x3E
  053D    0600    XORA	0x0
  053E    1D03    SNZB	0x3,2
  053F    2DD7    JP	0x5D7
  0540    3006    LDIA	0x6
  0541    00F3    LD	0x73,A
  0542    086B    LD	A,0x6B
  0543    158A    SETB	0xA,3
  0544    24EA    CALL	0x4EA
  0545    118A    CLRB	0xA,3
  0546    3EAB    ADDIA	0xAB
  0547    0084    LD	0x4,A
  0548    083F    LD	A,0x3F
  0549    0600    XORA	0x0
  054A    1D03    SNZB	0x3,2
  054B    2DD7    JP	0x5D7
  054C    3006    LDIA	0x6
  054D    00F3    LD	0x73,A
  054E    086B    LD	A,0x6B
  054F    158A    SETB	0xA,3
  0550    24EA    CALL	0x4EA
  0551    118A    CLRB	0xA,3
  0552    3EAD    ADDIA	0xAD
  0553    0084    LD	0x4,A
  0554    083B    LD	A,0x3B
  0555    1383    CLRB	0x3,7
  0556    0600    XORA	0x0
  0557    1903    SZB	0x3,2
  0558    2DD7    JP	0x5D7
  0559    3006    LDIA	0x6
  055A    00F3    LD	0x73,A
  055B    086B    LD	A,0x6B
  055C    158A    SETB	0xA,3
  055D    24EA    CALL	0x4EA
  055E    118A    CLRB	0xA,3
  055F    3EAD    ADDIA	0xAD
  0560    0084    LD	0x4,A
  0561    083B    LD	A,0x3B
  0562    0080    LD	0x0,A
  0563    3006    LDIA	0x6
  0564    00F3    LD	0x73,A
  0565    086B    LD	A,0x6B
  0566    158A    SETB	0xA,3
  0567    24EA    CALL	0x4EA
  0568    118A    CLRB	0xA,3
  0569    3EAC    ADDIA	0xAC
  056A    0084    LD	0x4,A
  056B    0843    LD	A,0x43
  056C    0600    XORA	0x0
  056D    1D03    SNZB	0x3,2
  056E    2DD7    JP	0x5D7
  056F    08EA    TESTZ	0x6A
  0570    1D03    SNZB	0x3,2
  0571    2D77    JP	0x577
  0572    01EA    CLR	0x6A
  0573    0AEA    INCR	0x6A
  0574    158A    SETB	0xA,3
  0575    26D0    CALL	0x6D0
  0576    118A    CLRB	0xA,3
  0577    08C4    TESTZ	0x44
  0578    1D03    SNZB	0x3,2
  0579    2DC0    JP	0x5C0
  057A    3003    LDIA	0x3
  057B    026B    SUBA	0x6B
  057C    1803    SZB	0x3,0
  057D    2D93    JP	0x593
  057E    08F6    TESTZ	0x76
  057F    1D03    SNZB	0x3,2
  0580    2DD7    JP	0x5D7
  0581    0842    LD	A,0x42
  0582    3A02    XORIA	0x2
  0583    1D03    SNZB	0x3,2
  0584    2D8C    JP	0x58C
  0585    3002    LDIA	0x2
  0586    00D8    LD	0x58,A
  0587    3000    LDIA	0x0
  0588    158A    SETB	0xA,3
  0589    26F9    CALL	0x6F9
  058A    118A    CLRB	0xA,3
  058B    2DD7    JP	0x5D7
  058C    0842    LD	A,0x42
  058D    00D8    LD	0x58,A
  058E    3000    LDIA	0x0
  058F    158A    SETB	0xA,3
  0590    26F9    CALL	0x6F9
  0591    118A    CLRB	0xA,3
  0592    2DD7    JP	0x5D7
  0593    3006    LDIA	0x6
  0594    026B    SUBA	0x6B
  0595    1803    SZB	0x3,0
  0596    2DAC    JP	0x5AC
  0597    08F7    TESTZ	0x77
  0598    1D03    SNZB	0x3,2
  0599    2DD7    JP	0x5D7
  059A    0842    LD	A,0x42
  059B    3A02    XORIA	0x2
  059C    1D03    SNZB	0x3,2
  059D    2DA5    JP	0x5A5
  059E    3002    LDIA	0x2
  059F    00D8    LD	0x58,A
  05A0    3001    LDIA	0x1
  05A1    158A    SETB	0xA,3
  05A2    26F9    CALL	0x6F9
  05A3    118A    CLRB	0xA,3
  05A4    2DD7    JP	0x5D7
  05A5    0842    LD	A,0x42
  05A6    00D8    LD	0x58,A
  05A7    3001    LDIA	0x1
  05A8    158A    SETB	0xA,3
  05A9    26F9    CALL	0x6F9
  05AA    118A    CLRB	0xA,3
  05AB    2DD7    JP	0x5D7
  05AC    08F8    TESTZ	0x78
  05AD    1D03    SNZB	0x3,2
  05AE    2DD7    JP	0x5D7
  05AF    0842    LD	A,0x42
  05B0    3A02    XORIA	0x2
  05B1    1D03    SNZB	0x3,2
  05B2    2DB9    JP	0x5B9
  05B3    3002    LDIA	0x2
  05B4    00D8    LD	0x58,A
  05B5    158A    SETB	0xA,3
  05B6    26F9    CALL	0x6F9
  05B7    118A    CLRB	0xA,3
  05B8    2DD7    JP	0x5D7
  05B9    0842    LD	A,0x42
  05BA    00D8    LD	0x58,A
  05BB    3002    LDIA	0x2
  05BC    158A    SETB	0xA,3
  05BD    26F9    CALL	0x6F9
  05BE    118A    CLRB	0xA,3
  05BF    2DD7    JP	0x5D7
  05C0    01AC    CLR	0x2C
  05C1    01AD    CLR	0x2D
  05C2    0B36    SZDECA	0x36
  05C3    2DC6    JP	0x5C6
  05C4    01A9    CLR	0x29
  05C5    01B6    CLR	0x36
  05C6    3003    LDIA	0x3
  05C7    026B    SUBA	0x6B
  05C8    1803    SZB	0x3,0
  05C9    2DCC    JP	0x5CC
  05CA    1429    SETB	0x29,0
  05CB    2DD3    JP	0x5D3
  05CC    3006    LDIA	0x6
  05CD    026B    SUBA	0x6B
  05CE    1803    SZB	0x3,0
  05CF    2DD2    JP	0x5D2
  05D0    14A9    SETB	0x29,1
  05D1    2DD3    JP	0x5D3
  05D2    1529    SETB	0x29,2
  05D3    0842    LD	A,0x42
  05D4    00AA    LD	0x2A,A
  05D5    0844    LD	A,0x44
  05D6    00AB    LD	0x2B,A
  05D7    0AEB    INCR	0x6B
  05D8    2D05    JP	0x505
  05D9    01EB    CLR	0x6B
  05DA    3009    LDIA	0x9
  05DB    026B    SUBA	0x6B
  05DC    1803    SZB	0x3,0
  05DD    2F96    JP	0x796
  05DE    0B6C    SZDECA	0x6C
  05DF    2DF0    JP	0x5F0
  05E0    083C    LD	A,0x3C
  05E1    3A11    XORIA	0x11
  05E2    1D03    SNZB	0x3,2
  05E3    2DF0    JP	0x5F0
  05E4    083D    LD	A,0x3D
  05E5    3A56    XORIA	0x56
  05E6    1D03    SNZB	0x3,2
  05E7    2DF0    JP	0x5F0
  05E8    083E    LD	A,0x3E
  05E9    3A32    XORIA	0x32
  05EA    1D03    SNZB	0x3,2
  05EB    2DF0    JP	0x5F0
  05EC    083F    LD	A,0x3F
  05ED    3AF9    XORIA	0xF9
  05EE    1903    SZB	0x3,2
  05EF    2E21    JP	0x621
  05F0    3006    LDIA	0x6
  05F1    00F3    LD	0x73,A
  05F2    086B    LD	A,0x6B
  05F3    158A    SETB	0xA,3
  05F4    24EA    CALL	0x4EA
  05F5    118A    CLRB	0xA,3
  05F6    3EA8    ADDIA	0xA8
  05F7    0084    LD	0x4,A
  05F8    083C    LD	A,0x3C
  05F9    1383    CLRB	0x3,7
  05FA    0600    XORA	0x0
  05FB    1D03    SNZB	0x3,2
  05FC    2E7D    JP	0x67D
  05FD    3006    LDIA	0x6
  05FE    00F3    LD	0x73,A
  05FF    086B    LD	A,0x6B
  0600    158A    SETB	0xA,3
  0601    24EA    CALL	0x4EA
  0602    118A    CLRB	0xA,3
  0603    3EA9    ADDIA	0xA9
  0604    0084    LD	0x4,A
  0605    083D    LD	A,0x3D
  0606    0600    XORA	0x0
  0607    1D03    SNZB	0x3,2
  0608    2E7D    JP	0x67D
  0609    3006    LDIA	0x6
  060A    00F3    LD	0x73,A
  060B    086B    LD	A,0x6B
  060C    158A    SETB	0xA,3
  060D    24EA    CALL	0x4EA
  060E    118A    CLRB	0xA,3
  060F    3EAA    ADDIA	0xAA
  0610    0084    LD	0x4,A
  0611    083E    LD	A,0x3E
  0612    0600    XORA	0x0
  0613    1D03    SNZB	0x3,2
  0614    2E7D    JP	0x67D
  0615    3006    LDIA	0x6
  0616    00F3    LD	0x73,A
  0617    086B    LD	A,0x6B
  0618    158A    SETB	0xA,3
  0619    24EA    CALL	0x4EA
  061A    118A    CLRB	0xA,3
  061B    3EAB    ADDIA	0xAB
  061C    0084    LD	0x4,A
  061D    083F    LD	A,0x3F
  061E    0600    XORA	0x0
  061F    1D03    SNZB	0x3,2
  0620    2E7D    JP	0x67D
  0621    3006    LDIA	0x6
  0622    00F3    LD	0x73,A
  0623    086B    LD	A,0x6B
  0624    158A    SETB	0xA,3
  0625    24EA    CALL	0x4EA
  0626    118A    CLRB	0xA,3
  0627    3EAD    ADDIA	0xAD
  0628    0084    LD	0x4,A
  0629    083B    LD	A,0x3B
  062A    1383    CLRB	0x3,7
  062B    0600    XORA	0x0
  062C    1903    SZB	0x3,2
  062D    2E7D    JP	0x67D
  062E    3006    LDIA	0x6
  062F    00F3    LD	0x73,A
  0630    086B    LD	A,0x6B
  0631    158A    SETB	0xA,3
  0632    24EA    CALL	0x4EA
  0633    118A    CLRB	0xA,3
  0634    3EAD    ADDIA	0xAD
  0635    0084    LD	0x4,A
  0636    083B    LD	A,0x3B
  0637    0080    LD	0x0,A
  0638    158A    SETB	0xA,3
  0639    26D0    CALL	0x6D0
  063A    118A    CLRB	0xA,3
  063B    08C4    TESTZ	0x44
  063C    1D03    SNZB	0x3,2
  063D    2E70    JP	0x670
  063E    08F6    TESTZ	0x76
  063F    1D03    SNZB	0x3,2
  0640    2E4D    JP	0x64D
  0641    0842    LD	A,0x42
  0642    3A02    XORIA	0x2
  0643    1D03    SNZB	0x3,2
  0644    2E47    JP	0x647
  0645    3002    LDIA	0x2
  0646    2E48    JP	0x648
  0647    0842    LD	A,0x42
  0648    00D8    LD	0x58,A
  0649    3000    LDIA	0x0
  064A    158A    SETB	0xA,3
  064B    26F9    CALL	0x6F9
  064C    118A    CLRB	0xA,3
  064D    08F7    TESTZ	0x77
  064E    1D03    SNZB	0x3,2
  064F    2E5C    JP	0x65C
  0650    0842    LD	A,0x42
  0651    3A02    XORIA	0x2
  0652    1D03    SNZB	0x3,2
  0653    2E56    JP	0x656
  0654    3002    LDIA	0x2
  0655    2E57    JP	0x657
  0656    0842    LD	A,0x42
  0657    00D8    LD	0x58,A
  0658    3001    LDIA	0x1
  0659    158A    SETB	0xA,3
  065A    26F9    CALL	0x6F9
  065B    118A    CLRB	0xA,3
  065C    08F8    TESTZ	0x78
  065D    1D03    SNZB	0x3,2
  065E    2E7D    JP	0x67D
  065F    0842    LD	A,0x42
  0660    3A02    XORIA	0x2
  0661    1D03    SNZB	0x3,2
  0662    2E69    JP	0x669
  0663    3002    LDIA	0x2
  0664    00D8    LD	0x58,A
  0665    158A    SETB	0xA,3
  0666    26F9    CALL	0x6F9
  0667    118A    CLRB	0xA,3
  0668    2E7D    JP	0x67D
  0669    0842    LD	A,0x42
  066A    00D8    LD	0x58,A
  066B    3002    LDIA	0x2
  066C    158A    SETB	0xA,3
  066D    26F9    CALL	0x6F9
  066E    118A    CLRB	0xA,3
  066F    2E7D    JP	0x67D
  0670    01AC    CLR	0x2C
  0671    01AD    CLR	0x2D
  0672    0B36    SZDECA	0x36
  0673    2E76    JP	0x676
  0674    01A9    CLR	0x29
  0675    01B6    CLR	0x36
  0676    1429    SETB	0x29,0
  0677    14A9    SETB	0x29,1
  0678    1529    SETB	0x29,2
  0679    0842    LD	A,0x42
  067A    00AA    LD	0x2A,A
  067B    0844    LD	A,0x44
  067C    00AB    LD	0x2B,A
  067D    0AEB    INCR	0x6B
  067E    2DDA    JP	0x5DA
  067F    0841    LD	A,0x41
  0680    3A30    XORIA	0x30
  0681    1D03    SNZB	0x3,2
  0682    2F96    JP	0x796
  0683    3006    LDIA	0x6
  0684    00F3    LD	0x73,A
  0685    086B    LD	A,0x6B
  0686    158A    SETB	0xA,3
  0687    24EA    CALL	0x4EA
  0688    118A    CLRB	0xA,3
  0689    3EAD    ADDIA	0xAD
  068A    0084    LD	0x4,A
  068B    083B    LD	A,0x3B
  068C    1383    CLRB	0x3,7
  068D    0600    XORA	0x0
  068E    1903    SZB	0x3,2
  068F    2EF5    JP	0x6F5
  0690    3006    LDIA	0x6
  0691    00F3    LD	0x73,A
  0692    086B    LD	A,0x6B
  0693    158A    SETB	0xA,3
  0694    24EA    CALL	0x4EA
  0695    118A    CLRB	0xA,3
  0696    3EAD    ADDIA	0xAD
  0697    0084    LD	0x4,A
  0698    083B    LD	A,0x3B
  0699    0080    LD	0x0,A
  069A    01E9    CLR	0x69
  069B    01EB    CLR	0x6B
  069C    2EBB    JP	0x6BB
  069D    3006    LDIA	0x6
  069E    00F3    LD	0x73,A
  069F    086B    LD	A,0x6B
  06A0    158A    SETB	0xA,3
  06A1    24EA    CALL	0x4EA
  06A2    118A    CLRB	0xA,3
  06A3    3EAC    ADDIA	0xAC
  06A4    0084    LD	0x4,A
  06A5    0843    LD	A,0x43
  06A6    0600    XORA	0x0
  06A7    1D03    SNZB	0x3,2
  06A8    2EBA    JP	0x6BA
  06A9    3001    LDIA	0x1
  06AA    00DF    LD	0x5F,A
  06AB    3003    LDIA	0x3
  06AC    00F3    LD	0x73,A
  06AD    086B    LD	A,0x6B
  06AE    158A    SETB	0xA,3
  06AF    2147    CALL	0x147
  06B0    118A    CLRB	0xA,3
  06B1    3E01    ADDIA	0x1
  06B2    2EB5    JP	0x6B5
  06B3    1003    CLRB	0x3,0
  06B4    0DDF    RLCR	0x5F
  06B5    3EFF    ADDIA	0xFF
  06B6    1D03    SNZB	0x3,2
  06B7    2EB3    JP	0x6B3
  06B8    085F    LD	A,0x5F
  06B9    04E9    ORR	0x69
  06BA    0AEB    INCR	0x6B
  06BB    3009    LDIA	0x9
  06BC    026B    SUBA	0x6B
  06BD    1803    SZB	0x3,0
  06BE    2EF5    JP	0x6F5
  06BF    3006    LDIA	0x6
  06C0    00F3    LD	0x73,A
  06C1    086B    LD	A,0x6B
  06C2    158A    SETB	0xA,3
  06C3    24EA    CALL	0x4EA
  06C4    118A    CLRB	0xA,3
  06C5    3EA8    ADDIA	0xA8
  06C6    0084    LD	0x4,A
  06C7    083C    LD	A,0x3C
  06C8    0600    XORA	0x0
  06C9    1D03    SNZB	0x3,2
  06CA    2EBA    JP	0x6BA
  06CB    3006    LDIA	0x6
  06CC    00F3    LD	0x73,A
  06CD    086B    LD	A,0x6B
  06CE    158A    SETB	0xA,3
  06CF    24EA    CALL	0x4EA
  06D0    118A    CLRB	0xA,3
  06D1    3EA9    ADDIA	0xA9
  06D2    0084    LD	0x4,A
  06D3    083D    LD	A,0x3D
  06D4    0600    XORA	0x0
  06D5    1D03    SNZB	0x3,2
  06D6    2EBA    JP	0x6BA
  06D7    3006    LDIA	0x6
  06D8    00F3    LD	0x73,A
  06D9    086B    LD	A,0x6B
  06DA    158A    SETB	0xA,3
  06DB    24EA    CALL	0x4EA
  06DC    118A    CLRB	0xA,3
  06DD    3EAA    ADDIA	0xAA
  06DE    0084    LD	0x4,A
  06DF    083E    LD	A,0x3E
  06E0    0600    XORA	0x0
  06E1    1D03    SNZB	0x3,2
  06E2    2EBA    JP	0x6BA
  06E3    3006    LDIA	0x6
  06E4    00F3    LD	0x73,A
  06E5    086B    LD	A,0x6B
  06E6    158A    SETB	0xA,3
  06E7    24EA    CALL	0x4EA
  06E8    118A    CLRB	0xA,3
  06E9    3EAB    ADDIA	0xAB
  06EA    0084    LD	0x4,A
  06EB    083F    LD	A,0x3F
  06EC    0600    XORA	0x0
  06ED    1D03    SNZB	0x3,2
  06EE    2EBA    JP	0x6BA
  06EF    0843    LD	A,0x43
  06F0    3AFF    XORIA	0xFF
  06F1    1D03    SNZB	0x3,2
  06F2    2E9D    JP	0x69D
  06F3    3007    LDIA	0x7
  06F4    04E9    ORR	0x69
  06F5    0869    LD	A,0x69
  06F6    1903    SZB	0x3,2
  06F7    2F96    JP	0x796
  06F8    3003    LDIA	0x3
  06F9    0242    SUBA	0x42
  06FA    1803    SZB	0x3,0
  06FB    2F96    JP	0x796
  06FC    01EB    CLR	0x6B
  06FD    3003    LDIA	0x3
  06FE    026B    SUBA	0x6B
  06FF    1803    SZB	0x3,0
  0700    2F8B    JP	0x78B
  0701    3001    LDIA	0x1
  0702    00DF    LD	0x5F,A
  0703    0A6B    INCA	0x6B
  0704    2F07    JP	0x707
  0705    1003    CLRB	0x3,0
  0706    0DDF    RLCR	0x5F
  0707    3EFF    ADDIA	0xFF
  0708    1D03    SNZB	0x3,2
  0709    2F05    JP	0x705
  070A    085F    LD	A,0x5F
  070B    0569    ANDA	0x69
  070C    1903    SZB	0x3,2
  070D    2F89    JP	0x789
  070E    08C2    TESTZ	0x42
  070F    1D03    SNZB	0x3,2
  0710    2F2F    JP	0x72F
  0711    3001    LDIA	0x1
  0712    00DF    LD	0x5F,A
  0713    086B    LD	A,0x6B
  0714    00E0    LD	0x60,A
  0715    0760    ADDA	0x60
  0716    3E01    ADDIA	0x1
  0717    2F1A    JP	0x71A
  0718    1003    CLRB	0x3,0
  0719    0DDF    RLCR	0x5F
  071A    3EFF    ADDIA	0xFF
  071B    1D03    SNZB	0x3,2
  071C    2F18    JP	0x718
  071D    085F    LD	A,0x5F
  071E    04CC    ORR	0x4C
  071F    3001    LDIA	0x1
  0720    00DF    LD	0x5F,A
  0721    1403    SETB	0x3,0
  0722    0D6B    RLCA	0x6B
  0723    3E01    ADDIA	0x1
  0724    2F27    JP	0x727
  0725    1003    CLRB	0x3,0
  0726    0DDF    RLCR	0x5F
  0727    3EFF    ADDIA	0xFF
  0728    1D03    SNZB	0x3,2
  0729    2F25    JP	0x725
  072A    085F    LD	A,0x5F
  072B    3AFF    XORIA	0xFF
  072C    05CC    ANDR	0x4C
  072D    01D8    CLR	0x58
  072E    2F50    JP	0x750
  072F    0B42    SZDECA	0x42
  0730    2F52    JP	0x752
  0731    3001    LDIA	0x1
  0732    00DF    LD	0x5F,A
  0733    086B    LD	A,0x6B
  0734    00E0    LD	0x60,A
  0735    0760    ADDA	0x60
  0736    3E01    ADDIA	0x1
  0737    2F3A    JP	0x73A
  0738    1003    CLRB	0x3,0
  0739    0DDF    RLCR	0x5F
  073A    3EFF    ADDIA	0xFF
  073B    1D03    SNZB	0x3,2
  073C    2F38    JP	0x738
  073D    085F    LD	A,0x5F
  073E    3AFF    XORIA	0xFF
  073F    05CC    ANDR	0x4C
  0740    3001    LDIA	0x1
  0741    00DF    LD	0x5F,A
  0742    1403    SETB	0x3,0
  0743    0D6B    RLCA	0x6B
  0744    3E01    ADDIA	0x1
  0745    2F48    JP	0x748
  0746    1003    CLRB	0x3,0
  0747    0DDF    RLCR	0x5F
  0748    3EFF    ADDIA	0xFF
  0749    1D03    SNZB	0x3,2
  074A    2F46    JP	0x746
  074B    085F    LD	A,0x5F
  074C    3AFF    XORIA	0xFF
  074D    05CC    ANDR	0x4C
  074E    01D8    CLR	0x58
  074F    0AD8    INCR	0x58
  0750    086B    LD	A,0x6B
  0751    2F86    JP	0x786
  0752    0842    LD	A,0x42
  0753    3A02    XORIA	0x2
  0754    1D03    SNZB	0x3,2
  0755    2F89    JP	0x789
  0756    3001    LDIA	0x1
  0757    00DF    LD	0x5F,A
  0758    1403    SETB	0x3,0
  0759    0D6B    RLCA	0x6B
  075A    3E01    ADDIA	0x1
  075B    2F5E    JP	0x75E
  075C    1003    CLRB	0x3,0
  075D    0DDF    RLCR	0x5F
  075E    3EFF    ADDIA	0xFF
  075F    1D03    SNZB	0x3,2
  0760    2F5C    JP	0x75C
  0761    085F    LD	A,0x5F
  0762    04CC    ORR	0x4C
  0763    3001    LDIA	0x1
  0764    00DF    LD	0x5F,A
  0765    086B    LD	A,0x6B
  0766    00E0    LD	0x60,A
  0767    0760    ADDA	0x60
  0768    3E01    ADDIA	0x1
  0769    2F6C    JP	0x76C
  076A    1003    CLRB	0x3,0
  076B    0DDF    RLCR	0x5F
  076C    3EFF    ADDIA	0xFF
  076D    1D03    SNZB	0x3,2
  076E    2F6A    JP	0x76A
  076F    085F    LD	A,0x5F
  0770    3AFF    XORIA	0xFF
  0771    05CC    ANDR	0x4C
  0772    08EB    TESTZ	0x6B
  0773    1D03    SNZB	0x3,2
  0774    2F79    JP	0x779
  0775    0820    LD	A,0x20
  0776    00D8    LD	0x58,A
  0777    3000    LDIA	0x0
  0778    2F86    JP	0x786
  0779    0B6B    SZDECA	0x6B
  077A    2F7F    JP	0x77F
  077B    0823    LD	A,0x23
  077C    00D8    LD	0x58,A
  077D    3001    LDIA	0x1
  077E    2F86    JP	0x786
  077F    086B    LD	A,0x6B
  0780    3A02    XORIA	0x2
  0781    1D03    SNZB	0x3,2
  0782    2F89    JP	0x789
  0783    0826    LD	A,0x26
  0784    00D8    LD	0x58,A
  0785    3002    LDIA	0x2
  0786    158A    SETB	0xA,3
  0787    26F9    CALL	0x6F9
  0788    118A    CLRB	0xA,3
  0789    0AEB    INCR	0x6B
  078A    2EFD    JP	0x6FD
  078B    304C    LDIA	0x4C
  078C    00D3    LD	0x53,A
  078D    3070    LDIA	0x70
  078E    01D4    CLR	0x54
  078F    0AD4    INCR	0x54
  0790    158A    SETB	0xA,3
  0791    276D    CALL	0x76D
  0792    118A    CLRB	0xA,3
  0793    158A    SETB	0xA,3
  0794    26D0    CALL	0x6D0
  0795    118A    CLRB	0xA,3
  0796    3064    LDIA	0x64
  0797    00F3    LD	0x73,A
  0798    01F4    CLR	0x74
  0799    158A    SETB	0xA,3
  079A    26DD    CALL	0x6DD
  079B    118A    CLRB	0xA,3
  079C    158A    SETB	0xA,3
  079D    23FF    CALL	0x3FF
  079E    158A    SETB	0xA,3
  079F    2C0F    JP	0x40F
  07A0    0008    RET
---- stringtab ------------------------------------------------------------------
  0800    3008    LDIA	0x8
  0801    008A    LD	0xA,A
  0802    0804    LD	A,0x4
  0803    0A84    INCR	0x4
  0804    0782    ADDR	0x2
  0805    3400    RET	0x0
  0806    34D6    RET	0xD6
  0807    34C5    RET	0xC5
  0808    3444    RET	0x44
  0809    3420    RET	0x20
  080A    3459    RET	0x59
  080B    34DE    RET	0xDE
  080C    34E1    RET	0xE1
  080D    348F    RET	0x8F
  080E    341B    RET	0x1B
  080F    34A5    RET	0xA5
  0810    34AF    RET	0xAF
  0811    3442    RET	0x42
  0812    347B    RET	0x7B
  0813    344E    RET	0x4E
  0814    34CD    RET	0xCD
  0815    3460    RET	0x60
  0816    34EB    RET	0xEB
  0817    3462    RET	0x62
  0818    3422    RET	0x22
  0819    3490    RET	0x90
  081A    342C    RET	0x2C
  081B    34EF    RET	0xEF
  081C    34F0    RET	0xF0
  081D    34C7    RET	0xC7
  081E    348D    RET	0x8D
  081F    34D2    RET	0xD2
  0820    3457    RET	0x57
  0821    34A1    RET	0xA1
  0822    343D    RET	0x3D
  0823    34A7    RET	0xA7
  0824    3466    RET	0x66
  0825    34B0    RET	0xB0
  0826    3475    RET	0x75
  0827    3431    RET	0x31
  0828    3411    RET	0x11
  0829    3448    RET	0x48
  082A    3496    RET	0x96
  082B    3477    RET	0x77
  082C    34F8    RET	0xF8
  082D    34E3    RET	0xE3
  082E    3446    RET	0x46
  082F    34E9    RET	0xE9
  0830    34C7    RET	0xC7
  0831    348D    RET	0x8D
  0832    34D2    RET	0xD2
  0833    3457    RET	0x57
  0834    34A1    RET	0xA1
  0835    343D    RET	0x3D
  0836    34A7    RET	0xA7
  0837    3466    RET	0x66
  0838    34B0    RET	0xB0
  0839    3475    RET	0x75
  083A    3431    RET	0x31
  083B    3411    RET	0x11
  083C    3448    RET	0x48
  083D    3496    RET	0x96
  083E    3477    RET	0x77
  083F    34F8    RET	0xF8
  0840    34E3    RET	0xE3
  0841    3446    RET	0x46
  0842    34E9    RET	0xE9
  0843    34AB    RET	0xAB
  0844    34D0    RET	0xD0
  0845    3441    RET	0x41
  0846    3492    RET	0x92
  0847    3453    RET	0x53
  0848    342A    RET	0x2A
  0849    34FC    RET	0xFC
  084A    34AB    RET	0xAB
  084B    34CE    RET	0xCE
  084C    3426    RET	0x26
  084D    340D    RET	0xD
  084E    341E    RET	0x1E
  084F    3499    RET	0x99
  0850    3478    RET	0x78
  0851    3400    RET	0x0
  0852    3422    RET	0x22
  0853    3499    RET	0x99
  0854    34DE    RET	0xDE
  0855    3445    RET	0x45
  0856    3421    RET	0x21
  0857    343F    RET	0x3F
  0858    342D    RET	0x2D
  0859    345C    RET	0x5C
  085A    3440    RET	0x40
  085B    3445    RET	0x45
  085C    3421    RET	0x21
  085D    343F    RET	0x3F
  085E    342D    RET	0x2D
  085F    345C    RET	0x5C
  0860    3440    RET	0x40
  0861    340A    RET	0xA
  0862    346D    RET	0x6D
  0863    3467    RET	0x67
  0864    349C    RET	0x9C
  0865    3446    RET	0x46
  0866    340A    RET	0xA
  0867    346D    RET	0x6D
  0868    3467    RET	0x67
  0869    349C    RET	0x9C
  086A    3446    RET	0x46
  086B    340B    RET	0xB
  086C    34DF    RET	0xDF
  086D    3402    RET	0x2
  086E    3416    RET	0x16
  086F    3433    RET	0x33
  0870    3427    RET	0x27
  0871    340B    RET	0xB
  0872    34DF    RET	0xDF
  0873    3402    RET	0x2
  0874    3416    RET	0x16
  0875    3433    RET	0x33
  0876    3427    RET	0x27
  0877    342D    RET	0x2D
  0878    34D7    RET	0xD7
  0879    34B9    RET	0xB9
  087A    34CC    RET	0xCC
  087B    34CC    RET	0xCC
  087C    34CC    RET	0xCC
  087D    34E1    RET	0xE1
  087E    3401    RET	0x1
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280B    JP	0xB
  000B    158A    SETB	0xA,3
  000C    292D    JP	0x12D
---- start_initialization ------------------------------------------------------------------
  07EF    0064    CLRWDT
  07F0    0180    CLR	0x0
  07F1    0A84    INCR	0x4
  07F2    0604    XORA	0x4
  07F3    1903    SZB	0x3,2
  07F4    3400    RET	0x0
  07F5    0604    XORA	0x4
  07F6    2FF0    JP	0x7F0
  092D    3020    LDIA	0x20
  092E    01F6    CLR	0x76
  092F    01F7    CLR	0x77
  0930    01F8    CLR	0x78
  0931    01F9    CLR	0x79
  0932    01FA    CLR	0x7A
  0933    1383    CLRB	0x3,7
  0934    0084    LD	0x4,A
  0935    304F    LDIA	0x4F
  0936    118A    CLRB	0xA,3
  0937    27EF    CALL	0x7EF
  0938    158A    SETB	0xA,3
  0939    30A0    LDIA	0xA0
  093A    0084    LD	0x4,A
  093B    30F0    LDIA	0xF0
  093C    118A    CLRB	0xA,3
  093D    27EF    CALL	0x7EF
  093E    3001    LDIA	0x1
  093F    00EC    LD	0x6C,A
  0940    3010    LDIA	0x10
  0941    00ED    LD	0x6D,A
  0942    3001    LDIA	0x1
  0943    00EE    LD	0x6E,A
  0944    0183    CLR	0x3
  0945    118A    CLRB	0xA,3
  0946    2FA1    JP	0x7A1
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    158A    SETB	0xA,3
  000A    2962    JP	0x162
---- common_function ------------------------------------------------------------------
  0CEA    00F5    LD	0x75,A
  0CEB    01F4    CLR	0x74
  0CEC    0873    LD	A,0x73
  0CED    1875    SZB	0x75,0
  0CEE    07F4    ADDR	0x74
  0CEF    1003    CLRB	0x3,0
  0CF0    0DF3    RLCR	0x73
  0CF1    1003    CLRB	0x3,0
  0CF2    0CF5    RRCR	0x75
  0CF3    08F5    TESTZ	0x75
  0CF4    1D03    SNZB	0x3,2
  0CF5    2CEC    JP	0x4EC
  0CF6    0874    LD	A,0x74
  0CF7    0008    RET
